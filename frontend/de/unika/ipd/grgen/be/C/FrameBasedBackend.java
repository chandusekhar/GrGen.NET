/*
 GrGen: graph rewrite generator tool.
 Copyright (C) 2005  IPD Goos, Universit"at Karlsruhe, Germany

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */


/**
 * A GrGen Backend which generates C code for a frame-based
 * graph model impl and a frame based graph matcher
 * @author Veit Batz
 * @version $Id$
 */
package de.unika.ipd.grgen.be.C;

import java.io.File;
import java.io.PrintStream;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeSet;

import de.unika.ipd.grgen.Sys;
import de.unika.ipd.grgen.be.Backend;
import de.unika.ipd.grgen.be.BackendFactory;
import de.unika.ipd.grgen.be.C.fb.AttrTypeDescriptor;
import de.unika.ipd.grgen.be.C.fb.EnumDescriptor;
import de.unika.ipd.grgen.be.C.fb.MoreInformationCollector;
import de.unika.ipd.grgen.ir.Action;
import de.unika.ipd.grgen.ir.Assignment;
import de.unika.ipd.grgen.ir.Constant;
import de.unika.ipd.grgen.ir.Edge;
import de.unika.ipd.grgen.ir.EdgeType;
import de.unika.ipd.grgen.ir.Entity;
import de.unika.ipd.grgen.ir.EnumItem;
import de.unika.ipd.grgen.ir.Expression;
import de.unika.ipd.grgen.ir.Graph;
import de.unika.ipd.grgen.ir.IR;
import de.unika.ipd.grgen.ir.InheritanceType;
import de.unika.ipd.grgen.ir.MatchingAction;
import de.unika.ipd.grgen.ir.Node;
import de.unika.ipd.grgen.ir.NodeType;
import de.unika.ipd.grgen.ir.Operator;
import de.unika.ipd.grgen.ir.PatternGraph;
import de.unika.ipd.grgen.ir.Qualification;
import de.unika.ipd.grgen.ir.RetypedNode;
import de.unika.ipd.grgen.ir.Rule;
import de.unika.ipd.grgen.ir.Type;
import de.unika.ipd.grgen.ir.Unit;
import de.unika.ipd.grgen.util.Annotated;
import de.unika.ipd.grgen.util.Annotations;

public class FrameBasedBackend extends MoreInformationCollector implements Backend, BackendFactory {

	// TODO use or remove it
	// private final int OUT = 0;
	// private final int IN = 1;

	protected final boolean emit_subgraph_info = true;

	/* binary operator symbols of the C-language */
	// ATTENTION: the forst two shift operations are signed shifts
	// 		the second right shift is signed. This Backend simply gens
	//		C-bitwise-shift-operations on signed integers, for simplicity ;-)
	private String[] opSymbols = {
		null, "||", "&&", "|", "^", "&",
			"==", "!=", "<", "<=", ">", ">=", "<<", ">>", ">>", "+",
			"-", "*", "/", "%", null, null, null, null
	};

	//Kann man das entfernen???
	//ToDo: Pruefe das, ob man diese Methode wegschmeissen kann!!!

	/**
	 * Method makeEvals
	 *
	 * @param    ps                  a  PrintStream
	 *
	 */
	protected void makeEvals(PrintStream ps) {
		// TODO
	}

//	// The unit to generate code for.
//	protected Unit unit;
//	// keine Ahnung wozu das gut sein soll
//	protected Sys system;
//	// The output path as handed over by the frontend.
//	private File path;

	/**
	 * Create a new backend.
	 * @return A new backend.
	 */
	public Backend getBackend() {
		return this;
	}

	/**
	 * Initializes the FrameBasedBackend
	 * @see de.unika.ipd.grgen.be.Backend#init(de.unika.ipd.grgen.ir.Unit, de.unika.ipd.grgen.Sys, java.io.File)
	 */
	public void init(Unit unit, Sys system, File outputPath) {
		super.init(unit, system, outputPath);
//		this.unit = unit;
//		this.path = outputPath;
//		this.system = system;
//		path.mkdirs();
	}

	/**
	 * Starts the C-code Genration of the FrameBasedBackend
	 * @see de.unika.ipd.grgen.be.Backend#generate()
	 */
	public void generate() {
		// Emit an include file for Makefiles
		PrintStream ps = openFile("unit.mak");
		ps.println("#\n# generated by grgen, don't edit\n#");
		ps.println("UNIT_NAME = " + formatId(unit.getUnitName()));
		closeFile(ps);

		System.out.println("The frame-based GrGen backend...");
		System.out.println("  generating information about node and edge types...");

		// the StringBuffer the generated C code to be stored in
		StringBuffer sb = new StringBuffer();
		//collect information needed for the generation of the graph type model
		collectGraphTypeModelInfo();
		//gen information about number of types, enums,...
		genGraphTypeInfo(sb);
		// write StrinBuffer to file
		writeFile("graph_type_info.inc", sb);

		//gen informations desribing the graph type system specified by the
		//current *.grg-file
		sb = new StringBuffer();
		genGraphTypeDescr(sb);
		// write StrinBuffer to file
		writeFile("graph_type_descr.inc", sb);

		System.out.println("  generating graph validation information...");

		//generate code for graph validation and write it to file "valid_info.inc"
		genValidateStatements();

		System.out.println("  generating graph action descriptions...");

		//collect informations needed for the action code genaration
		collectActionInfo();
		//gen some info about numbers of things concerning the actions specified
		//in the current grg-file.
		sb = new StringBuffer();
		genActionsInfo(sb);
		writeFile("actions_info.inc", sb);
		//gen description of the actions, conditions and evals specified by the grg file
		sb = new StringBuffer();
		genActionsDescr(sb);
		writeFile("actions_descr.inc", sb);

		System.out.println("  generating C code for the graph matching conditions...");

		//gen the C-code of the conditions
		sb = new StringBuffer();
		genConditionsCode(sb);
		writeFile("conditions_code.inc", sb);

		System.out.println("  generating C code for the graph matching evals...");

		//gen the C-code of the evals
		sb = new StringBuffer();
		collectEvalInfo();
		genEvalsCode(sb);
		writeFile("evals_code.inc", sb);

		System.out.println("  generating XML overview...");

		// write an overview of all generated Ids
		ps = openFile("overview.xml");
		writeOverview(ps);
		closeFile(ps);

		System.out.println("  done!");
	}


	private void genActualActions(StringBuffer sb) {
		sb.append(
			"\n\n\n\n\n\n" +
				"/* + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + " +
				" + + + + + + + + + + + + + + + + + + + + + + + + + + + + + */" +
				"\n\n\n\n" +
				"/* Following data represents the graph actions with some\n" +
				" * first matcher programs (generated in a naive way) for\n" +
				" * the VM doing the graph matches. These programs will be\n" +
				" * replaced by more sophisticated ones at the running time of\n" +
				" * the generated graph replacement system. Those programs can\n" +
				" * not be computed statically because they require information\n" +
				" * the graph existing at runtime */\n\n\n\n\n");

		// for all actions gen matcher programs
		for ( Iterator<Action> act_it = actionMap.keySet().iterator(); act_it.hasNext(); ) {

			MatchingAction action = (MatchingAction) act_it.next();
			Graph pattern = action.getPattern();

			sb.append(
				"\n\n\n\n" +
					"/* ---------------------- matcher programs and all the rest " +
					"for action " + actionMap.get(action) +
					" ---------------------- */\n\n\n");

			//start generating programs beginning with the already computed start node
			int act_id = actionMap.get(action).intValue();
			Node startNode = start_node[act_id];
			//perform a deep first search on the pattern
			//graph while emiting matcher operations
			Collection<Expression> alreadyCheckedConditions = new HashSet<Expression>();
			Collection<Collection<InheritanceType>> alreadyCheckedTypeConditions = new HashSet<Collection<InheritanceType>>();
			int[] n_matcher_ops = new int[max_n_negative_patterns+1];

			n_matcher_ops[0] = genOpSequence(startNode, action, alreadyCheckedConditions, alreadyCheckedTypeConditions, sb);

			for(Iterator<PatternGraph> neg_it = negMap[act_id].keySet().iterator(); neg_it.hasNext(); ) {
				PatternGraph neg_pattern = neg_it.next();

				int neg_num = ((Integer)negMap[act_id].get(neg_pattern)).intValue();

				n_matcher_ops[neg_num+1] = genNegOpSequence(action, neg_pattern, alreadyCheckedConditions, alreadyCheckedTypeConditions, sb);
			}

			//get the actions kind
			String act_kind = action instanceof Rule ?
				"gr_action_kind_rule" : "gr_action_kind_test";
			//get the replacement graph
			String replGraph = action instanceof Rule ?
				"&replacement_graph_of_action_" + act_id : "NULL";

			sb.append("static fb_acts_graph_t *negative_pattern_graphs_of_act_" + act_id + "[] = {\n  ");
			for(int i=0; i<n_negative_patterns[act_id]; i++) {
				sb.append("&negative_pattern_graph_" + i + "_of_action_" + act_id + ", ");
			}
			sb.append("\n};\n\n");

			//gen C-arrays of pattern node names
			int n_pat_nodes = action.getPattern().getNodes().size();
			Iterator<Node> pattern_node_it =
				action.getPattern().getNodes().iterator();
			sb.append(
				"static const char *pattern_node_names_of_act_" + act_id + "[" + n_pat_nodes + "] = {\n  ");
			for ( ; pattern_node_it.hasNext(); ) {
				Node node = pattern_node_it.next();
				sb.append("\"" + node.getIdent().toString() + "\"");
				if (pattern_node_it.hasNext())
					sb.append(", ");
			}
			sb.append("\n};\n");
			//gen C-arrays of pattern edge names
			int n_pat_edges = action.getPattern().getEdges().size();
			String pat_edge_name_array = "NULL";
			if (n_pat_edges > 0) {
				Iterator<Edge> pattern_edge_it =
					action.getPattern().getEdges().iterator();
				sb.append(
					"static const char *pattern_edge_names_of_act_" + act_id + "[" + n_pat_edges + "] = {\n  ");
				for ( ; pattern_edge_it.hasNext(); ) {
					Edge edge = pattern_edge_it.next();
					sb.append("\"" + edge.getIdent().toString() + "\"");
					if (pattern_edge_it.hasNext())
						sb.append(", ");
				}
				sb.append("\n};\n");
				pat_edge_name_array = "pattern_edge_names_of_act_" + act_id;
			}

			/*			//create a C-array of ptrs to matcher ops representing the whole matcher program
			 if (n_matcher_ops > 0) {
			 sb.append(
			 "fb_matcher_op_t *matcher_program_of_action_" + act_id +
			 "[" + n_matcher_ops + "] = {\n");
			 for (int i = 0; i < n_matcher_ops; i++) {
			 sb.append("  &mop_" + i + "_of_action_" + act_id);
			 if (i < (n_matcher_ops - 1)) sb.append(",");
			 sb.append("\n");
			 }
			 sb.append("};\n");
			 }
			 */
			//create a C-array of ptrs to matcher ops representing the matcher programs
			for(int pattern_num = 0; pattern_num < n_negative_patterns[act_id] + 1; pattern_num++) {
				if (n_matcher_ops[pattern_num] > 0) {
					sb.append(
						"static fb_matcher_op_t *matcher_program_" + pattern_num + "_of_action_" + act_id +
							"[" + n_matcher_ops[pattern_num] + "] = {\n");
					for (int i = 0; i < n_matcher_ops[pattern_num]; i++) {
						sb.append("  &mop_" + i + "_of_pattern_" + pattern_num + "_of_action_" + act_id);
						if (i < (n_matcher_ops[pattern_num] - 1)) sb.append(",");
						sb.append("\n");
					}
					sb.append("};\n");
				}
				else {
					sb.append("static fb_matcher_op_t *matcher_program_" + pattern_num + "_of_action_" + act_id + "[0] = {};\n");
				}
			}

			//gen the list of matcher progs
			sb.append("static fb_matcher_op_t **matcher_programs_of_action_" + act_id + "[" + (n_negative_patterns[act_id] + 1) + "] = {\n");
			for(int i = 0; i < n_negative_patterns[act_id] + 1; i++) {
				sb.append("  matcher_program_" + i +"_of_action_" + act_id);
				if (i < (n_negative_patterns[act_id])) sb.append(",");
				sb.append("\n");
			}
			sb.append("};\n\n");

			//get the number of pattern nodes to be removed by the replacement step
			int n_remove_nodes = 0;
			String remove_nodes_array = "NULL";
			Collection<Node> remove_nodes = new HashSet<Node>();
			if (action instanceof Rule) {
				Graph replacement = ((Rule) action).getRight();
				//compute all pattern nodes to be removed  in the replace step.
				remove_nodes.addAll(pattern.getNodes());
				remove_nodes.removeAll(replacement.getNodes());
				n_remove_nodes = remove_nodes.size();
				//if the set of nodes to be removed is not empty gen a C-array
				//of their patter nodes numbers
				if (n_remove_nodes > 0) {
					sb.append(
						"static int remove_nodes_of_action_" + act_id +
							"[" + n_remove_nodes + "] = {\n  ");
					for (Iterator<Node> it = remove_nodes.iterator(); it.hasNext(); ) {
						Node node = it.next();
						Integer node_num =
							(Integer) pattern_node_num[act_id].get(node);
						sb.append(node_num);
						if (it.hasNext()) sb.append(", ");
					}
					sb.append("\n};\n");
					remove_nodes_array = "remove_nodes_of_action_" + act_id;
				}
			}

			//get the number of pattern edges explicitly to be
			//removed by the replacement step
			int n_remove_edges = 0;
			String remove_edges_array = "NULL";
			Collection<Edge> remove_edges = new HashSet<Edge>();
			if (action instanceof Rule) {
				Graph replacement = ((Rule) action).getRight();
				//compute all pattern nodes to be removed  in the replace step.
				remove_edges.addAll(pattern.getEdges());
				remove_edges.removeAll(replacement.getEdges());
				n_remove_edges = remove_edges.size();
				//if the set of edges explicitly to be removed is not
				//empty gen a C-array of their patter nodes numbers
				if (n_remove_edges > 0) {
					sb.append(
						"static int remove_edges_of_action_" + act_id +
							"[" + n_remove_edges + "] = {\n  ");
					for (Iterator<Edge> it = remove_edges.iterator(); it.hasNext(); ) {
						Edge edge = it.next();
						Integer edge_num =
							(Integer) pattern_edge_num[act_id].get(edge);
						sb.append(edge_num);
						if (it.hasNext()) sb.append(", ");
					}
					sb.append("\n};\n");
					remove_edges_array = "remove_edges_of_action_" + act_id;
				}
			}
			//gen the array of replacement edges newly to be inserted by
			//the current action
			int n_new_edges = 0;

			// TODO use or remove it
			// String new_edges_array = "NULL";

			if (action instanceof Rule) {
				n_new_edges = newEdgesOfAction[act_id].size();
				if (n_new_edges > 0) {
					sb.append(
						"static fb_acts_edge_t *new_edges_of_action_" + act_id + "[" + n_new_edges + "] = { \n");
					Iterator<Edge> new_edge_it =
						newEdgesOfAction[act_id].iterator();
					for ( ; new_edge_it.hasNext() ; ) {
						Edge edge = new_edge_it.next();
						int edge_num =
							((Integer) replacement_edge_num[act_id].get(edge)).intValue();
						sb.append("  &replacement_edge_" + edge_num + "_of_action_" + act_id);
						if (new_edge_it.hasNext()) sb.append(",");
						sb.append("\n");
					}
					sb.append(" };\n");
					// new_edges_array = "new_edges_of_action_" + act_id;
				}
			}

			//gen C-struct of the current action
			sb.append(
				"static fb_action_t action_" + act_id + " = {\n" +
					"  \"" + action.getIdent().toString() + "\", " +
					"(gr_id_t) " + act_id + ", " + act_kind + ",\n" +
					"  &pattern_graph_of_action_" + act_id + ", " + replGraph + ",\n  " +
					n_negative_patterns[act_id] + ",\n" +
					"  negative_pattern_graphs_of_act_" + act_id + ",\n" +
					"  pattern_node_names_of_act_" + act_id + ",\n" +
					"  " + pat_edge_name_array + ",\n");

			sb.append("  { ");
			//gen a 1-dim array, containing the length of each matcher prog
			for (int i = 0; i< max_n_negative_patterns + 1; i++) {
				sb.append( n_matcher_ops[i] );
				if (i < max_n_negative_patterns) sb.append(", ");
			}
			sb.append(" },\n  ");

			sb.append("matcher_programs_of_action_" + act_id + ",\n");

			sb.append("  {\n");
			//create a 2-dim array embeded in the struct, which keept the information
			//whether the matcher is allowed to identify two given pattern nodes of
			//the curren action
			for (int i = 0; i < max_n_pattern_nodes; i++) {
				sb.append("    { ");
				for (int j = 0; j < max_n_pattern_nodes; j++) {
					sb.append( potHomNodeMatrices[act_id][i][j] );
					if (j < (max_n_pattern_nodes - 1)) sb.append(", ");
				}
				sb.append(" }");
				if (i < max_n_pattern_nodes - 1) sb.append(",");
				sb.append("\n");
			}
			sb.append("  },\n");

			//continue the creation of the actions C-struct
			sb.append(
				"  " + n_remove_nodes + ", " + remove_nodes_array + ",\n" +
					"  " + n_remove_edges + ", " + remove_edges_array + ",\n" +
					"  { ");

			//gen a 1-dim array, wich tells whether a matched host graph node
			//is to be preserved by the replacement or not (corresponding
			//pattern node number, a negative value otherwise)
			for (int i = 0; i< max_n_pattern_nodes; i++) {
				sb.append(patternNodeIsToBeKept[act_id][i]);
				if (i < max_n_pattern_nodes - 1) sb.append(", ");
			}
			sb.append(" },\n  { ");
			//gen a 1-dim array, wich tells whether replacement node is
			//a preserved pattern node (corresponding
			//pattern node number, a negative value otherwise)
			for ( int i = 0; i < max_n_replacement_nodes; i++) {
				sb.append(replacementNodeIsPreservedNode[act_id][i]);
				if (i < max_n_replacement_nodes - 1) sb.append(", ");
			}
			sb.append(" },\n  { ");
			//gen a 1-dim array which tells whether a preserved replacement node
			//changes type its type. If so, the value indexed by the repl. node
			//number is the new type, and -1 (that is gr_id_invalid) otherwise.
			//If a repl. node isn't a preserved node at all the value is
			//gr_id_invalid (i.e. -1) all the same
			for ( int i = 0; i < max_n_replacement_nodes; i++) {
				sb.append("(gr_id_t)" + replacementNodeChangesTypeTo[act_id][i]);
				if (i < max_n_replacement_nodes - 1) sb.append(", ");
			}
			sb.append(" },\n  { ");


			//gen a 1-dim array, wich tells whether a matched host graph edge
			//is to be preserved by the replacement or not (corresponding
			//pattern edge number, a negative value otherwise)
			for (int i = 0; i< max_n_pattern_edges; i++) {
				sb.append(patternEdgeIsToBeKept[act_id][i]);
				if (i < max_n_pattern_edges - 1) sb.append(", ");
			}
			sb.append(" },\n  { ");
			//gen a 1-dim array, wich tells whether replacement edge is
			//a preserved pattern edge (corresponding
			//pattern edge number, a negative value otherwise)
			for ( int i = 0; i < max_n_replacement_edges; i++) {
				sb.append(replacementEdgeIsPreservedEdge[act_id][i]);
				if (i < max_n_replacement_edges - 1) sb.append(", ");
			}
			sb.append(" },\n");

			sb.append("  {\n");
			//gen 2-dim array for mapping pattern node numbers to the corresponding negative
			//pattern node numbers in a negative pattern
			for (int i = 0; i < max_n_negative_patterns; i++) {
				sb.append("    { ");
				for (int j = 0; j < max_n_pattern_nodes; j++) {
					sb.append( patternNodeIsNegativeNode[act_id][i][j] );
					if (j < (max_n_pattern_nodes - 1)) sb.append(", ");
				}
				sb.append(" }");
				if (i < max_n_negative_patterns - 1) sb.append(",");
				sb.append("\n");
			}
			sb.append("  },\n");

			sb.append("  {\n");
			//gen 2-dim array for mapping pattern edge numbers to the corresponding negative
			//pattern edge numbers in a negative pattern
			for (int i = 0; i < max_n_negative_patterns; i++) {
				sb.append("    { ");
				for (int j = 0; j < max_n_pattern_edges; j++) {
					sb.append( patternEdgeIsNegativeEdge[act_id][i][j] );
					if (j < (max_n_pattern_edges - 1)) sb.append(", ");
				}
				sb.append(" }");
				if (i < max_n_negative_patterns - 1) sb.append(",");
				sb.append("\n");
			}
			sb.append("  }");

			if(emit_subgraph_info) {
				/* emit subgraph info (#subgraphs, #nodes/edges of subgraph) */
				sb.append(",\n  " + n_subgraphs[act_id] + ",\n  ");

				sb.append(first_subgraph[act_id] + ",\n  { ");

				for ( int i = 0; i < n_subgraphs[act_id]; i++) {
					sb.append( (nodesOfSubgraph[act_id].get(i)).size() );
					if (i < n_subgraphs[act_id]- 1) sb.append(", ");
				}
				sb.append(" },\n  { ");

				for ( int i = 0; i < n_subgraphs[act_id]; i++) {
					sb.append( (edgesOfSubgraph[act_id].get(i)).size() );
					if (i < n_subgraphs[act_id]- 1) sb.append(", ");
				}
				sb.append(" }");

			}
			sb.append("\n};\n\n");
			//end of action struct!!!

		}
		//gen the array of ptrs to all action structs
		sb.append(
			"/* the array of all action structs */\n" +
				"static fb_action_t *fb_action[fb_N_ACTIONS] = {\n");
		for (int i = 0; i < n_graph_actions; i++) {
			sb.append("  &action_" + i);
			if (i < n_graph_actions - 1) sb.append(",");
			sb.append("\n");
		}
		sb.append("};\n\n");
	}

	/**
	 * performs a deep first traversal of the pattern graph of the given
	 * action while emiting matcher ops for the graph matching VM implemented
	 * by the matcher generated by this frame based GrGen backend. The
	 * matcher ops are represented by C structs of type fb_matcher_op_t
	 *
	 * @param    startNode         the start node
	 * @param    action            the action
	 * @param    sb                the String Buffer the matcher ops are
	 *                             written to
	 * @return  the number of matcher ops genreated for the given action
	 */
	private int op_counter;

	private int genOpSequence(Node startNode, MatchingAction action,
							  Collection<Expression> alreadyCheckedConditions, Collection<Collection<InheritanceType>> alreadyCheckedTypeConditions, StringBuffer sb) {
		Collection<IR> nodeVisited = new HashSet<IR>();
		Collection<IR> nodeNotVisited = new HashSet<IR>();
		Collection<IR> edgeVisited = new HashSet<IR>();
		Collection<Entity> currentSubgraph;
		// TODO use or remove it
		// Collection<Node> currentSubgraphNodes;
		Collection<Collection<Node>> subgraphs = new LinkedList<Collection<Node>>();

		int act_id = actionMap.get(action).intValue();
		op_counter = 0;

		subgraphs.addAll(nodesOfSubgraph[act_id]);

		if(first_subgraph[act_id] != 0) {
			Collection<Node> subgraph_nodes = nodesOfSubgraph[act_id].get(first_subgraph[act_id]);
			subgraphs.remove(subgraph_nodes);

			nodeNotVisited.addAll(subgraph_nodes);

			genConditionOps(null, null, action, 0, action.getPattern(), nodeVisited, edgeVisited,
							null, alreadyCheckedConditions, alreadyCheckedTypeConditions, sb);

			while( !nodeNotVisited.isEmpty() ) {
				//pick out the node with the highest priority as start node
				int max_prio = 0;
				//get any node as initial node
				Node max_prio_node = (Node) nodeNotVisited.iterator().next();
				for (Iterator<IR> node_it = nodeNotVisited.iterator(); node_it.hasNext(); ) {
					Node node = (Node) node_it.next();

					//get the nodes priority
					int prio = 0;
					Annotations a = node.getAnnotations();
					if (a != null)
						if (a.containsKey("prio") && a.isInteger("prio"))
							prio = ((Integer) a.get("prio")).intValue();

					//if the current priority is greater, update the maximum priority node
					if (prio > max_prio) {
						max_prio = prio;
						max_prio_node = node;
					}
				}

				currentSubgraph = new HashSet<Entity>();
				currentSubgraph.add(max_prio_node);

				nodeVisited.add(max_prio_node);
				nodeNotVisited.remove(max_prio_node);

				//gen op for the start node
				genOp(max_prio_node, null, action, 0,
					  action.getPattern(), nodeVisited, edgeVisited, currentSubgraph,
					  alreadyCheckedConditions,alreadyCheckedTypeConditions, op_counter, sb);
				++op_counter;

				genConditionOps(max_prio_node, null, action, 0, action.getPattern(), nodeVisited, edgeVisited,
								currentSubgraph, alreadyCheckedConditions, alreadyCheckedTypeConditions, sb);

				__deep_first_matcher_op_gen(
					nodeVisited, edgeVisited, currentSubgraph, alreadyCheckedConditions,
					alreadyCheckedTypeConditions, max_prio_node, action, 0, action.getPattern(), sb);

				nodeNotVisited.removeAll(nodeVisited);
			}
		}


		for(Iterator<Collection<Node>> subgraph_it = subgraphs.iterator(); subgraph_it.hasNext(); ) {
			Collection<Node> subgraph_nodes = subgraph_it.next();

			nodeNotVisited.addAll(subgraph_nodes);

			genConditionOps(null, null, action, 0, action.getPattern(), nodeVisited, edgeVisited,
							null, alreadyCheckedConditions, alreadyCheckedTypeConditions, sb);

			while( !nodeNotVisited.isEmpty() ) {
				//pick out the node with the highest priority as start node
				int max_prio = 0;
				//get any node as initial node
				Node max_prio_node = (Node) nodeNotVisited.iterator().next();
				for (Iterator<IR> node_it = nodeNotVisited.iterator(); node_it.hasNext(); ) {
					Node node = (Node) node_it.next();

					//get the nodes priority
					int prio = 0;
					Annotations a = node.getAnnotations();
					if (a != null)
						if (a.containsKey("prio") && a.isInteger("prio"))
							prio = ((Integer) a.get("prio")).intValue();

					//if the current priority is greater, update the maximum priority node
					if (prio > max_prio) {
						max_prio = prio;
						max_prio_node = node;
					}
				}

				currentSubgraph = new HashSet<Entity>();
				currentSubgraph.add(max_prio_node);

				nodeVisited.add(max_prio_node);
				nodeNotVisited.remove(max_prio_node);


				//gen op for the start node
				genOp(max_prio_node, null, action, 0,
					  action.getPattern(), nodeVisited, edgeVisited, currentSubgraph,
					  alreadyCheckedConditions,alreadyCheckedTypeConditions, op_counter, sb);
				++op_counter;

				genConditionOps(max_prio_node, null, action, 0, action.getPattern(), nodeVisited, edgeVisited,
								currentSubgraph, alreadyCheckedConditions, alreadyCheckedTypeConditions, sb);

				__deep_first_matcher_op_gen(
					nodeVisited, edgeVisited, currentSubgraph, alreadyCheckedConditions,
					alreadyCheckedTypeConditions, max_prio_node, action, 0, action.getPattern(), sb);

				nodeNotVisited.removeAll(nodeVisited);
			}
		}

		for(Iterator<PatternGraph> neg_it = negMap[act_id].keySet().iterator(); neg_it.hasNext(); ) {
			PatternGraph neg_pattern = neg_it.next();

			int neg_num = ((Integer)negMap[act_id].get(neg_pattern)).intValue();

			genCheckNegativeOp( action, neg_num, op_counter++, neg_pattern, sb );
		}
		return op_counter;
	}

	/**
	 * performs a deep first traversal of a negative pattern graph of the given
	 * action while emiting matcher ops for the graph matching VM implemented
	 * by the matcher generated by this frame based GrGen backend. The
	 * matcher ops are represented by C structs of type fb_matcher_op_t
	 *
	 * @param    startNode         the start node
	 * @param    action            the action
	 * @param    sb                the String Buffer the matcher ops are
	 *                             written to
	 * @return  the number of matcher ops genreated for the given action
	 */
	private int genNegOpSequence(MatchingAction action, PatternGraph neg_pattern,
								 Collection<Expression> alreadyCheckedConditions, Collection<Collection<InheritanceType>> alreadyCheckedTypeConditions, StringBuffer sb) {
		Collection<IR> nodeVisited = new HashSet<IR>();
		Collection<IR> nodeNotVisited = new HashSet<IR>();
		Collection<IR> edgeVisited = new HashSet<IR>();
		Collection<IR> startNodes = new HashSet<IR>();

		int act_id = actionMap.get(action).intValue();
		int neg_pattern_num = (negMap[act_id].get(neg_pattern)).intValue();

		/* find out which nodes/edges have been already matched by analyzing the already checked conditions */
		/*Collection nodesFromConditions = new HashSet();
		Collection edgesFromConditions = new HashSet();

		 for ( Iterator cond_it = conditions.iterator(); cond_it.hasNext(); ) {
		 Expression cond = (Expression) cond_it.next();

		 nodesFromConditions.addAll((Collection) conditionsInvolvedNodes.get(cond));
		 edgesFromConditions.addAll((Collection) conditionsInvolvedEdges.get(cond));
		 }

		 for ( Iterator type_cond_it = typeConditions.iterator(); type_cond_it.hasNext(); ) {
		 Collection type_cond = (Collection) type_cond_it.next();

		 nodesFromConditions.addAll((Collection) typeConditionsInvolvedNodes.get(type_cond));
		 edgesFromConditions.addAll((Collection) typeConditionsInvolvedEdges.get(type_cond));
		 }*/

		/* contains intersect( N, L) and L */
		nodeVisited.addAll( neg_pattern.getNodes() );
		nodeVisited.retainAll( action.getPattern().getNodes() );
		nodeVisited.addAll( action.getPattern().getNodes() );

		//nodeVisited.addAll( nodesFromConditions );

		/* contains N \ L */
		nodeNotVisited.addAll( neg_pattern.getNodes() );
		nodeNotVisited.removeAll( nodeVisited );

		/* contains intersect( L, N ) */
		startNodes.addAll( action.getPattern().getNodes() );
		//startNodes.removeAll( neg_pattern.getNodes() );
		startNodes.retainAll( neg_pattern.getNodes() );

		/* contains intersect( e(N), e(L)) and e(L) */
		edgeVisited.addAll( neg_pattern.getEdges() );
		edgeVisited.retainAll( action.getPattern().getEdges() );
		edgeVisited.addAll( action.getPattern().getEdges() );

		//edgeVisited.addAll( edgesFromConditions );

		/* the conditions checked in the (positive) pattern should not checked again,
		 * for the pattern nodes/edges are already marked as visited
		 * so nothing to do here to prevent checking them twice */

		// TODO identify same nodes in pattern/negative ?

		op_counter = 0;

		genConditionOps(null, null, action, neg_pattern_num+1, neg_pattern, nodeVisited, edgeVisited,
						null, alreadyCheckedConditions, alreadyCheckedTypeConditions, sb);


		/* first take all nodes, that are already matched as pattern nodes as
		 * start nodes and try to find adjacent negative-pattern-only nodes
		 * for the matcher prog */
		for( Iterator<IR> start_it = startNodes.iterator(); start_it.hasNext(); ) {

			Node start_node = (Node)start_it.next();

			//but do not gen op for the start node (it is already matched as pattern node)
			/*genOp(max_prio_node, null, action,
			 nodeVisited, edgeVisited, alreadyCheckedConditions,
			 alreadyCheckedTypeConditions, op_counter, sb);

			 ++op_counter;*/
			__deep_first_matcher_op_gen(
				nodeVisited, edgeVisited, null, alreadyCheckedConditions,
				alreadyCheckedTypeConditions, start_node, action, neg_pattern_num+1, neg_pattern, sb);

			nodeNotVisited.removeAll(nodeVisited);
		}

		/* for all nodes that are not reachable from a (positive) pattern node in the negative pattern */
		while( !nodeNotVisited.isEmpty() ) {
			//pick out the node with the highest priority as start node
			int max_prio = 0;
			//get any node as initial node
			Node max_prio_node = (Node) nodeNotVisited.iterator().next();
			for (Iterator<IR> node_it = nodeNotVisited.iterator(); node_it.hasNext(); ) {
				Node node = (Node) node_it.next();

				//get the nodes priority
				int prio = 0;
				Annotations a = node.getAnnotations();
				if (a != null)
					if (a.containsKey("prio") && a.isInteger("prio"))
						prio = ((Integer) a.get("prio")).intValue();

				//if the current priority is greater, update the maximum priority node
				if (prio > max_prio) {
					max_prio = prio;
					max_prio_node = node;
				}
			}

			nodeVisited.add(max_prio_node);
			nodeNotVisited.remove(max_prio_node);

			//gen op for the start node
			genOp(max_prio_node, null, action, neg_pattern_num+1,
				  neg_pattern, nodeVisited, edgeVisited, null, alreadyCheckedConditions,
				  alreadyCheckedTypeConditions, op_counter, sb);

			genConditionOps(max_prio_node, null, action, neg_pattern_num+1, neg_pattern, nodeVisited, edgeVisited,
							null, alreadyCheckedConditions, alreadyCheckedTypeConditions, sb);

			++op_counter;
			__deep_first_matcher_op_gen(
				nodeVisited, edgeVisited, null, alreadyCheckedConditions,
				alreadyCheckedTypeConditions, max_prio_node, action, neg_pattern_num+1, neg_pattern, sb);

			nodeNotVisited.removeAll(nodeVisited);
		}
		return op_counter;
	}


	/**
	 * performs the actual deep first traversal and matcher op generation
	 *
	 * @param    nodeVisited         a Collection of Nodes, membership indicates
	 *                               whether a node has already been visited
	 * @param    edgeVisited         a Collection of Edges, membership indicates
	 *                               whether an edge has already been visited
	 * @param    node                the current Node
	 * @param    action              the action
	 * @param    pattern_num	 pattern 0 is the main pattern, the other ones are negative patterns
	 * @param    pattern             the pattern graph
	 * @param    sb                  the StringBuffer the generated
	 */
	private void __deep_first_matcher_op_gen(
		Collection<IR> nodeVisited, Collection<IR> edgeVisited,
		Collection<Entity> currentSubgraph,
		Collection<Expression> alreadyCheckedConds,
		Collection<Collection<InheritanceType>> alreadyCheckedTypeConds,
		final Node node, MatchingAction action,
		int pattern_num,				/* pattern 0 is the main pattern, the other ones are negative patterns */
		final PatternGraph pattern,
		StringBuffer sb) {
		//final PatternGraph pattern = action.getPattern();

		//a collection of all edges incident to the current node. The collection
		//is ordered by the priority of the nodes at the far end of each edge.
		//nodes without priority get the priority 0.
		Collection<Edge> incidentEdges = new TreeSet<Edge>(new Comparator<Edge>() {
					public int compare(Edge e1, Edge e2) {
						//get the far end node of both edges
						Node farNode1 = getFarEndNode(e1, node, pattern);
						Node farNode2 = getFarEndNode(e2, node, pattern);
						//get those nodes prirorities...
						int prio1 = getNodePriority(farNode1);
						int prio2 = getNodePriority(farNode2);
						//...and compare them
						if (prio1 == prio2)
							if (e1 == e2) return 0;
							else return -1;
						//twisted return values (to force a descending order)
						if (prio1 > prio2) return -1;
						if (prio1 < prio2) return 1;

						//unreachable but java likes it
						return 0;
					}
				});

		//put all edges incident to the current node in that collection
		pattern.getOutgoing(node, incidentEdges);
		pattern.getIncoming(node, incidentEdges);

		//iterate over all those incident edges...
		Iterator<Edge> incident_edge_it = incidentEdges.iterator();
		for ( ; incident_edge_it.hasNext(); ) {
			Edge edge = incident_edge_it.next();

			//...and check whether the current edge has already been visited
			if ( ! edgeVisited.contains(edge) ) {

				//if the edge has not been visited yet mark it as visited
				if(currentSubgraph != null) currentSubgraph.add(edge);

				genOp(getFarEndNode(edge, node, pattern), edge, action, pattern_num,
					  pattern, nodeVisited, edgeVisited, currentSubgraph,
					  alreadyCheckedConds, alreadyCheckedTypeConds, op_counter, sb);
				op_counter++;

				genConditionOps(getFarEndNode(edge, node, pattern), edge, action, pattern_num, pattern, nodeVisited, edgeVisited,
								currentSubgraph, alreadyCheckedConds, alreadyCheckedTypeConds, sb);

				//mark the current edge as visited
				edgeVisited.add(edge);

				//if the far node is not yet visited follow the current edge to
				//continue the deep first traversal
				if ( ! nodeVisited.contains(getFarEndNode(edge, node, pattern)) ) {

					//mark the edge and the far end node as visited
					if(currentSubgraph != null) currentSubgraph.add(getFarEndNode(edge, node, pattern));

					nodeVisited.add(getFarEndNode(edge, node, pattern));
					//continue recursicly the deep fisrt traversal of the pattern graph
					__deep_first_matcher_op_gen(
						nodeVisited, edgeVisited, currentSubgraph,
						alreadyCheckedConds, alreadyCheckedTypeConds,
						getFarEndNode(edge, node, pattern),
						action, pattern_num, pattern, sb);
				}
			}
		}
	}


	/**
	 * generates the Cstruct for a single matcher op
	 *
	 * @param    node                the node the dfs comes from
	 * @param    edge                the current edge, if null a start
	 * 								 node op will be emited
	 * @param    action              the action to gen the matcher program for
	 * @param    pattern_num         the number of the pattern for this matcher prog (0 ist main pattern the other ones are negative patterns)
	 * @param    nodeVisited         all nodes already visited
	 * @param    edgeVisited         all edges already visited
	 * @param    op_counter          number of the current op as a member of an
	 *                               sequence of ops forming a matcher program
	 * @param    sb                  the StringBuffer the C code is to be
	 *                               stored in
	 */
	private void genOp(Node node, Edge edge, MatchingAction action,
					   int pattern_num,
					   final PatternGraph pattern,
					   Collection<IR> nodeVisited, Collection<IR> edgeVisited,
					   Collection<Entity> currentSubgraph,
					   Collection<Expression> alreadyCheckedConds,
					   Collection<Collection<InheritanceType>> alreadyCheckedTypeConds,
					   int op_counter, StringBuffer sb) {
		int act_id = actionMap.get(action).intValue();

		//get the potentialy homomorphic nodes of the far end node
		Collection<Node> homomorphicNodes = new HashSet<Node>();
		homomorphicNodes = pattern.getHomomorphic(node);

		//compute this ops kind
		String kind = "";
		if (edge == null)
			kind = "fb_matcher_op_start_node";
		else if (nodeVisited.contains(node))
			kind = "fb_matcher_op_check";
		else {
			/* op is an 'extend' or an 'check_or_extend'. That depends on whether
			 there's a node in the set of nodes already visited which is
			 potentialy homomorphic to the node at the far end of the current edge */
			//that for compute following intersection
			homomorphicNodes.retainAll(nodeVisited);
			//if that intersection is empty...
			if (homomorphicNodes.isEmpty())
				//...there's no such pot hom node, i.e. the op kind is 'extend'
				kind = "fb_matcher_op_extend";
			else
				kind = "fb_matcher_op_check_or_extend";
		}

		// TODO use or remove it
		//get name indentifier used in the grg-file for the current edge
		/* String edgeName = "NULL";
		if (edge != null)
			edgeName = edge.getIdent().toString();
		*/

		//get the direction of the op
		String op_direction = null;
		if (kind.equals("fb_matcher_op_check"))
			//in this case the direction depends on the V-structure situation of
			//the concrete graph, which is only known at run-time, so any direction
			//is chosen
			op_direction = "fb_dir_out";
		else if (! kind.equals("fb_matcher_op_start_node")) {
			//case 'extend' od 'check_or_extend'
			if (pattern.getTarget(edge) == node)
				op_direction = "fb_dir_out";
			else
				op_direction = "fb_dir_in";
		}

		//some comment
		sb.append("/* matcher op " + op_counter + " of pattern " + pattern_num + " of action " + act_id + " */\n");

		//get the current edges pattern edge number
		Integer edge_num = new Integer(-1);
		if (edge != null) {
			if(pattern_num == 0) { /* are we in the main pattern or is this a negative one */
				edge_num = (Integer) pattern_edge_num[act_id].get(edge);
			}
			else {
				edge_num = (Integer) negative_edge_num[act_id][pattern_num-1].get(edge);
			}
		}

		//gen the C-struct representing the current matcher op
		if (edge != null) {
			String edge_ptr;
			if(pattern_num == 0) {
				edge_ptr = "&pattern_edge_" + edge_num + "_of_action_" + act_id;
			}
			else {
				edge_ptr = "&negative_pattern_" + (pattern_num-1) + "_edge_" + edge_num + "_of_action_" + act_id;
			}

			sb.append(
				"fb_matcher_op_t mop_" + op_counter + "_of_pattern_" + pattern_num + "_of_action_" + act_id + " = {\n" +
					"  .kind = " + kind + ",\n" +
					"  .operand.edge = " + edge_ptr + ",\n" +
					"  .attrib.dir = " + op_direction + "\n" +
					"};\n\n");
		}
		else {
			//edge == null indicates, that a start no op has to be emitted
			// TODO use or remove it
			// String node_name = node.getIdent().toString();

			Integer node_num;
			String node_ptr;

			if(pattern_num == 0) {
				node_num = (Integer) pattern_node_num[act_id].get(node);
				node_ptr = "&pattern_node_" + node_num + "_of_action_" + act_id;
			}
			else {
				node_num = (Integer) negative_node_num[act_id][pattern_num-1].get(node);
				node_ptr = "&negative_pattern_" + (pattern_num-1) + "_node_" + node_num + "_of_action_" + act_id;
			}


			sb.append(
				"fb_matcher_op_t mop_" + op_counter + "_of_pattern_" + pattern_num + "_of_action_" + act_id + " = {\n" +
					"  .kind = " + kind + ",\n" +
					"  .operand.start_node = " + node_ptr + "\n" +
					"};\n\n");
		}

	}

	/**
	 * Method genConditions
	 *
	 * @param    node                a  Node
	 * @param    edge                an Edge
	 * @param    action              a  MatchingAction
	 * @param    pattern_num         an int
	 * @param    pattern             a  PatternGraph
	 * @param    nodeVisited         a  Collection<IR>
	 * @param    edgeVisited         a  Collection<IR>
	 * @param    currentSubgraph     a  Collection<Entity>
	 * @param    alreadyCheckedConds a  Collection<Expression>
	 * @param    alreadyCheckedTypeCondsa  Collection<Collection>
	 * @param    op_counter          an int
	 * @param    sb                  a  StringBuffer
	 *
	 */
	private int genConditionOps(Node node, Edge edge, MatchingAction action, int pattern_num, PatternGraph pattern, Collection<IR> nodeVisited, Collection<IR> edgeVisited, Collection<Entity> currentSubgraph, Collection<Expression> alreadyCheckedConds, Collection<Collection<InheritanceType>> alreadyCheckedTypeConds, StringBuffer sb) {
		int act_id = actionMap.get(action).intValue();

		//compute the set of conditions evaluatable in the current op
		Collection<Expression> evaluatableConditions = new TreeSet<Expression>(conditionsComparator);
		Collection<Expression> evaluatableGlobalConditions = new TreeSet<Expression>(conditionsComparator);
		Collection<Collection<InheritanceType>> evaluatableTypeConditions = new TreeSet<Collection<InheritanceType>>(typeConditionsComparator);
		Iterator<Expression> cond_it = conditions.get(act_id).iterator();
		for ( ; cond_it.hasNext(); ) {
			Expression cond = cond_it.next();

			//the nodes/edges involved in the current condtion
			Collection<Node> involvedNodes =
				new HashSet<Node>(conditionsInvolvedNodes.get(cond));
			Collection<Edge> involvedEdges =
				new HashSet<Edge>(conditionsInvolvedEdges.get(cond));

			//check whether these nodes/edges have been visited already,
			//but the current node/edge is not yet added to the "visited"-Sets
			// TODO use or remove it
			// boolean bothempty = involvedNodes.isEmpty() && involvedEdges.isEmpty();

			involvedNodes.remove(node);
			if  (edge != null)
				involvedEdges.remove(edge);
			if ( nodeVisited.containsAll(involvedNodes) && edgeVisited.containsAll(involvedEdges)) {
				if( currentSubgraph == null || ( currentSubgraph.containsAll(involvedNodes) && currentSubgraph.containsAll(involvedEdges) ) ) {
					/* then this is a "local" condition (only applies to current subgraph) */
					evaluatableConditions.add(cond);
				}
				else {
					/* if external (not belonging to current op) nodes/edges are involved in this condition */
					evaluatableGlobalConditions.add(cond);
				}
			}
		}
		Iterator<Collection<InheritanceType>> type_cond_it = typeConditions[act_id].iterator();
		for ( ; type_cond_it.hasNext(); ) {
			Collection<InheritanceType> type_cond = type_cond_it.next();

			//the nodes/edges involved in the current condtion
			Collection<Node> involvedNodes =
				new HashSet<Node>(typeConditionsInvolvedNodes.get(type_cond));
			Collection<Edge> involvedEdges =
				new HashSet<Edge>(typeConditionsInvolvedEdges.get(type_cond));

			//check whether these nodes/edges have been visited already,
			//but the current node/edge is not yet added to the "visited"-Sets
			involvedNodes.remove(node);
			if (edge != null)
				involvedEdges.remove(edge);
			if (nodeVisited.containsAll(involvedNodes)
				&& edgeVisited.containsAll(involvedEdges))
				evaluatableTypeConditions.add(type_cond);
		}
		//from that evaluatable conditions remove all conditions already checked
		//(because it is not necessary to check any condition twice)
		evaluatableConditions.removeAll(alreadyCheckedConds);
		evaluatableGlobalConditions.removeAll(alreadyCheckedConds);
		evaluatableTypeConditions.removeAll(alreadyCheckedTypeConds);



		//if there are conditions evaluiatable in the current op...
		if (evaluatableConditions.size() + evaluatableTypeConditions.size() + evaluatableGlobalConditions.size() > 0) {
			Iterator<Collection<InheritanceType>> eval_type_cond_it = evaluatableTypeConditions.iterator();
			for ( ; eval_type_cond_it.hasNext(); ) {
				Collection<InheritanceType> type_cond = eval_type_cond_it.next();
				int cond_num = typeConditionNumbers.get(type_cond);

				sb.append(
					"fb_matcher_op_t mop_" + op_counter + "_of_pattern_" + pattern_num + "_of_action_" + act_id + " = {\n" +
						"  .kind = fb_matcher_op_check_condition,\n" +
						"  .operand.cond = " + "type_condition_" + cond_num + "_of_action_" + act_id + ",\n" +
						"  .attrib.cond = fb_condition_local\n" +
						"};\n\n");

				++op_counter;
			}
			Iterator<Expression> eval_cond_it = evaluatableConditions.iterator();
			for ( ; eval_cond_it.hasNext(); ) {
				Expression cond = eval_cond_it.next();
				int cond_num = conditionNumbers.get(cond);

				sb.append(
					"fb_matcher_op_t mop_" + op_counter + "_of_pattern_" + pattern_num + "_of_action_" + act_id + " = {\n" +
						"  .kind = fb_matcher_op_check_condition,\n" +
						"  .operand.cond = " + "condition_" + cond_num + "_of_action_" + act_id + ",\n" +
						"  .attrib.cond = fb_condition_local\n" +
						"};\n\n");

				++op_counter;
			}
			if (evaluatableConditions.size() > 0 &&
				evaluatableTypeConditions.size() > 0)
				sb.append(", ");
			eval_cond_it = evaluatableGlobalConditions.iterator();
			for ( ; eval_cond_it.hasNext(); ) {
				Expression cond = eval_cond_it.next();
				int cond_num = conditionNumbers.get(cond);

				sb.append(
					"fb_matcher_op_t mop_" + op_counter + "_of_pattern_" + pattern_num + "_of_action_" + act_id + " = {\n" +
						"  .kind = fb_matcher_op_check_condition,\n" +
						"  .operand.cond = " + "condition_" + cond_num + "_of_action_" + act_id + ",\n" +
						"  .attrib.cond = fb_condition_global\n" +
						"};\n\n");

				++op_counter;
			}
		}

		//update the conditions already checked
		alreadyCheckedConds.addAll(evaluatableConditions);
		alreadyCheckedConds.addAll(evaluatableGlobalConditions);
		alreadyCheckedTypeConds.addAll(evaluatableTypeConditions);

		return op_counter;
	}

	private void genCheckNegativeOp( MatchingAction action, int neg_num, int op_counter, PatternGraph negative_pattern, StringBuffer sb ) {

		int act_id = actionMap.get(action).intValue();
		//int neg_pattern_num = ((Integer)negMap[act_id].get(negative_pattern)).intValue();

		sb.append(
			"fb_matcher_op_t mop_" + op_counter++ + "_of_pattern_0_of_action_" + act_id + " = {\n" +
				"  .kind = fb_matcher_op_check_negative,\n" +
				"  .operand.neg_pattern_num = " + neg_num + "\n" +
				"};\n\n");
	}

	private int getNodePriority(Node node) {
		int ret = 0;
		Annotations a = ((Annotated) node).getAnnotations();
		if (a != null)
			if (a.containsKey("prio") && a.isInteger("prio"))
				ret = ((Integer) a.get("prio")).intValue();
		return ret;
	}
	private Node getFarEndNode(Edge e, Node fromNode, Graph graph) {
		Node farEndNode = null;
		if (graph.getTarget(e) == fromNode)
			farEndNode = graph.getSource(e);
		if (graph.getSource(e) == fromNode)
			farEndNode = graph.getTarget(e);

		return farEndNode;
	}

	/**
	 * Method genEvalsCode
	 *
	 * @param    sb                  a  StringBuffer
	 *
	 */
	private void genEvalsCode(StringBuffer sb) {
		sb.append(
			"/*\n" +
				" * File 'evals_code.inc', created automatically by\n" +
				" * the FrameBased-Backend of GrGen.\n" +
				" *\n" +
				" * The C code in this file represents the evaluations specified in the\n" +
				" * evals sections of the GrGen input file '" + unit.getFilename() + "'.\n" +
				" */\n" +
				"\n\n");

		for(Iterator<Collection<Assignment>> it = evalListMap.keySet().iterator(); it.hasNext(); ) {
			//get the current eval list
			Collection<Assignment> eval_list = it.next();

			Integer act_id = evalListMap.get( eval_list );
			MatchingAction current_action = (MatchingAction)evalActions.get( eval_list );

			/* generate an expression that consists of both parts of the Assignment to use the already implemented methods for gathering InvolvedNodes/Edges etc. */
			Collection<Node> involved_nodes =
				evalInvolvedNodes.get( eval_list );
			Collection<Edge> involved_edges =
				evalInvolvedEdges.get( eval_list );

			/*gen the code for the current eval */
			sb.append(
				"/* evaluations for action " + act_id + " */\n" +
					"case " + act_id + ":\n"+
					"{\n" +
					"  /* local variables representing the 'ptr to' and the 'actual type of' the\n" +
					"   * host graph images of pattern nodes/edges with the respective number */\n");

			//for all involved nodes gen two local variables, one representing
			//the ptr to the host graph image of the node and the other representing
			//that host graph nodes actual type (note that this type may be a SUB-type
			//of the nodes type
			for (Iterator<Node> node_it = involved_nodes.iterator(); node_it.hasNext(); ) {
				Node current_node = node_it.next();
				Integer node_num;

				node_num = (Integer)replacement_node_num[ act_id.intValue() ].get(current_node);

				if( node_num == null ) {
					if(current_node.isRetyped()) {
						Node old_node = ((RetypedNode)current_node).getOldNode();
						node_num = (Integer)replacement_node_num[ act_id.intValue() ].get(old_node);

						sb.append(
							"  fb_node_t *old_replacement_node_" + node_num + " = get_replacement_host_node(" + node_num + ");\n" +
								"  int type_old_replacement_node_" + node_num + " = (int) old_replacement_node_" + node_num + "->type;\n");
					}
					else {
						node_num = (Integer)pattern_node_num[ act_id.intValue() ].get(current_node);

						sb.append(
							"  fb_node_t *pattern_node_" + node_num + " = get_host_node(" + node_num + ");\n" +
								"  int type_pattern_node_" + node_num + " = (int) pattern_node_" + node_num + "->type;\n");
					}
				}
				else {
					sb.append(
						"  fb_node_t *replacement_node_" + node_num + " = get_replacement_host_node(" + node_num + ");\n" +
							"  int type_replacement_node_" + node_num + " = (int) replacement_node_" + node_num + "->type;\n");
				}
			}
			for (Iterator<Edge> edge_it = involved_edges.iterator(); edge_it.hasNext(); ) {
				Edge current_edge = edge_it.next();

				Integer edge_num;

				edge_num = (Integer)replacement_edge_num[ act_id.intValue() ].get(current_edge);

				if( edge_num == null ) {
					edge_num = (Integer)pattern_edge_num[ act_id.intValue() ].get(current_edge);

					sb.append(
						"  fb_edge_t *pattern_edge_" + edge_num + " = get_pattern_host_edge(" + edge_num + ");\n" +
							"  int type_pattern_edge_" + edge_num + " = (int) pattern_edge_" + edge_num + "->type;\n");
				}
				else {
					sb.append(
						"  fb_edge_t *replacement_edge_" + edge_num + " = get_replacement_host_edge(" + edge_num + ");\n" +
							"  int type_replacement_edge_" + edge_num + " = (int) replacement_edge_" + edge_num + "->type;\n");
				}
			}
			//for attrs of the involved pattern nodes and edges gen a C variable
			//representing the host node/edge attr index of that attr
			sb.append(
				"\n" +
					"  /* local variables representing the attr indices of the involved node and edge attrs,\n" +
					"   * for each pair of pattern-node/edge-num and attr-id occuring as a qualification\n" +
					"   * expression in the evaluation, there's a variable representing that pair. */\n");
			//for all involved pattern nodes
			for (Iterator<Node> node_it = involved_nodes.iterator(); node_it.hasNext(); ) {
				Node current_node = node_it.next();
				String pattern_or_repl = "replacement";

				Integer node_num = (Integer)replacement_node_num[ act_id.intValue() ].get(current_node);
				if( node_num == null ) {
					if(current_node.isRetyped()) {
						Node old_node = ((RetypedNode)current_node).getOldNode();
						node_num = (Integer)replacement_node_num[ act_id.intValue() ].get(old_node);
						pattern_or_repl = "old_replacement";
					}
					else {
						node_num = (Integer)pattern_node_num[ act_id.intValue() ].get(current_node);
						pattern_or_repl = "pattern";
					}
				}

				Iterator<Integer> attr_id_it =
					involvedEvalNodeAttrIds[ act_id.intValue() ].get( current_node ).iterator();

				for (; attr_id_it.hasNext(); ) {

					Integer attr_id = attr_id_it.next();
					// TODO use or remove it
					// String kindStr =
					//	AttrTypeDescriptor.kindToStr(node_attr_info[attr_id.intValue()]);
					sb.append(
						"  int index_a" + attr_id + "_" + pattern_or_repl +  "_node_" + node_num + " = " +
							"fb_node_attr_index[type_" + pattern_or_repl + "_node_"  + node_num + "][" + attr_id + "];\n" );
				}
			}
			//for all involved pattern edges
			for (Iterator<Edge> edge_it = involved_edges.iterator(); edge_it.hasNext(); ) {
				Edge current_edge = edge_it.next();
				String pattern_or_repl = "replacement";

				Integer edge_num = (Integer) replacement_edge_num[ act_id.intValue() ].get(current_edge);
				if( edge_num == null ) {
					edge_num = (Integer)pattern_edge_num[ act_id.intValue() ].get(current_edge);
					pattern_or_repl = "pattern";
				}


				Iterator<Integer> attr_id_it =
					involvedEvalEdgeAttrIds[ act_id.intValue() ].get( current_edge ).iterator();
				for (; attr_id_it.hasNext(); ) {
					Integer attr_id = attr_id_it.next();
					// TODO use or remove it
					// String kindStr =
					//	AttrTypeDescriptor.kindToStr(edge_attr_info[attr_id.intValue()]);
					sb.append(
						"  int index_a" + attr_id + "_" + pattern_or_repl +  "_edge_" + edge_num + " = " +
							"fb_edge_attr_index[type_" + pattern_or_repl + "_edge_"  + edge_num + "][" + attr_id + "];\n");
				}
			}
			//gen the code for actual evalutions in the eval_list
			for ( Iterator<Assignment> evals_it = eval_list.iterator(); evals_it.hasNext(); ) {
				Assignment eval = evals_it.next();

				Qualification target = eval.getTarget();
				Expression expr = eval.getExpression();

				sb.append(
					"\n" +
						"  /* set the left side attribute to initialized */\n" );

				_initialize_qual(sb, current_action, target);

				sb.append(
					"\n" +
						"  /* calculate right side expression and assign to left side */\n" +
						"  " );
				genExprTree_recursive( sb, current_action, target, -1, false );
				sb.append(
					" = \n" +
						"    ( " );
				genExprTree_recursive( sb, current_action, expr, -1, false );
				sb.append(
					" );\n\n" );
			}

			sb.append(
				"\n" +
					"  /* now check whether the types in the calculations were right */\n" );

			/* check the types afterwards... should have been done before */
			for (Iterator<Node> node_it = involved_nodes.iterator(); node_it.hasNext(); ) {
				Node current_node = node_it.next();
				String pattern_or_repl = "replacement";

				Integer node_num = (Integer) replacement_node_num[ act_id.intValue() ].get(current_node);
				if( node_num == null ) {
					if(current_node.isRetyped()) {
						Node old_node = ((RetypedNode)current_node).getOldNode();
						node_num = (Integer)replacement_node_num[ act_id.intValue() ].get(old_node);
						pattern_or_repl = "old_replacement";
					}
					else {
						node_num = (Integer)pattern_node_num[ act_id.intValue() ].get(current_node);
						pattern_or_repl = "pattern";
					}
				}


				Iterator<Integer> attr_id_it =
					involvedEvalNodeAttrIds[ act_id.intValue() ].get( current_node ).iterator();
				for (; attr_id_it.hasNext(); ) {
					Integer attr_id = attr_id_it.next();
					String kindStr =
						AttrTypeDescriptor.kindToStr(node_attr_info[attr_id.intValue()]);
					sb.append(
						"  /*assert ( " + pattern_or_repl + "_node_" + node_num +"->" +
							"attr_values[index_a" + attr_id + "_" + pattern_or_repl + "_node_" + node_num + "]" +
							".kind == " + kindStr + " &&\n" +
							"    \"an attr kind tag found in a host graph node does not conform\" &&\n" +
							"    \"with the kind computed by the generator\");*/\n");
				}
			}
			for (Iterator<Edge> edge_it = involved_edges.iterator(); edge_it.hasNext(); ) {
				Edge current_edge = edge_it.next();
				String pattern_or_repl = "replacement";

				Integer edge_num = (Integer) replacement_edge_num[ act_id.intValue() ].get(current_edge);
				if( edge_num == null ) {
					edge_num = (Integer)pattern_edge_num[ act_id.intValue() ].get(current_edge);
					pattern_or_repl = "pattern";
				}


				Iterator<Integer> attr_id_it =
					involvedEvalEdgeAttrIds[ act_id.intValue() ].get( current_edge ).iterator();
				for (; attr_id_it.hasNext(); ) {
					Integer attr_id = attr_id_it.next();
					String kindStr =
						AttrTypeDescriptor.kindToStr(edge_attr_info[attr_id.intValue()]);
					sb.append(
						"  assert ( " + pattern_or_repl + "_edge_" + edge_num +"->" +
							"attr_values[index_a" + attr_id + "_" + pattern_or_repl + "_edge_" + edge_num + "]" +
							".kind == " + kindStr + " &&\n" +
							"    \"an attr kind tag found in a host graph edge does not conform\" &&\n" +
							"    \"with the kind computed by the generator\");\n");
				}
			}


			sb.append(
				"}\n" +
					"break; /* end of processing evaluation for action " + act_id + " */\n\n\n");
		}
		sb.append(
			"/* the default statement should never be reached */\n" +
				"default:\n"+
				"  assert( NULL && \"tried to call eval for unknown action_id\" );\n"+
				"  break;\n"
		);
	}

	/**
	 * Method genConditionsCode
	 *
	 * @param    sb                  a  StringBuffer
	 *
	 */
	private void genConditionsCode(StringBuffer sb) {
		sb.append(
			"/*\n" +
				" * File 'conditions_code.inc', created automatically by\n" +
				" * the FrameBased-Backend of GrGen.\n" +
				" *\n" +
				" * The C code in this file represents the conditions specified in the\n" +
				" * conditions sections of the GrGen input file '" + unit.getFilename() + "'.\n" +
				" */\n" +
				"\n\n");

		//iterate over all actions
		for(Iterator<Action> act_it = actionMap.keySet().iterator(); act_it.hasNext(); ) {
			//get the current action
			MatchingAction act = (MatchingAction)act_it.next();
			int act_id = actionMap.get(act).intValue();

			for (Expression current_cond : (Collection<Expression>)conditions.get(act_id)) {

				int cond_num = conditionNumbers.get(current_cond).intValue();
				int pattern_num = conditionsPatternNum.get(current_cond) == null ? 0 : conditionsPatternNum.get(current_cond).intValue();

				Collection<Node> involved_nodes =
					conditionsInvolvedNodes.get(current_cond);
				Collection<Edge> involved_edges =
					conditionsInvolvedEdges.get(current_cond);

				/*gen the code for the current cond */
				sb.append(
					"/* condition " + cond_num + " (belongs to action " + act_id + ") */\n" +
						"static int condition_" + cond_num + "_of_action_" + act_id + "()\n"+
						"{\n" +
						"  int condition_holds;\n" +
						"  /* local variables representing the 'ptr to' and the 'actual type of' the\n" +
						"   * host graph images of pattern nodes/edges with the respective number */\n");

				//for all involved pattern nodes gen two local variables, one representing
				//the ptr to the host graph image of the node and the other representing
				//that host graph nodes actual type (note that this type may be a SUB-type
				//of the pattern nodes type
				for (Iterator<Node> node_it = involved_nodes.iterator(); node_it.hasNext(); ) {
					Node current_pattern_node = node_it.next();
					Integer node_num = (Integer) pattern_node_num[act_id].get(current_pattern_node);


					if( node_num == null ) {
						node_num = (Integer)negative_node_num[ act_id ][ pattern_num-1 ].get(current_pattern_node);

						sb.append(
							"  fb_node_t *negative_pattern_node_" + node_num + " = get_negative_host_node(" + node_num + ");\n" +
								"  int type_negative_pattern_node_" + node_num + " = (int) negative_pattern_node_" + node_num + "->type;\n");
					}
					else {
						sb.append(
							"  fb_node_t *pattern_node_" + node_num + " = get_host_node(" + node_num + ");\n" +
								"  int type_pattern_node_" + node_num + " = (int) pattern_node_" + node_num + "->type;\n");
					}

				}
				for (Iterator<Edge> edge_it = involved_edges.iterator(); edge_it.hasNext(); ) {
					Edge current_pattern_edge = edge_it.next();
					Integer edge_num =
						(Integer) pattern_edge_num[act_id].get(current_pattern_edge);

					if( edge_num == null ) {
						edge_num = (Integer)negative_edge_num[ act_id ][ pattern_num-1 ].get(current_pattern_edge);

						sb.append(
							"  fb_edge_t *negative_pattern_edge_" + edge_num + " = get_negative_host_edge(" + edge_num + ");\n" +
								"  int type_negative_pattern_edge_" + edge_num + " = (int) negative_pattern_edge_" + edge_num + "->type;\n");
					}
					else {
						sb.append(
							"  fb_edge_t *pattern_edge_" + edge_num + " = get_host_edge(" + edge_num + ");\n" +
								"  int type_pattern_edge_" + edge_num + " = (int) pattern_edge_" + edge_num + "->type;\n");
					}

				}
				//for attrs of the involved pattern nodes and edges gen a C variable
				//representing the host node/edge attr index of that attr
				sb.append(
					"\n" +
						"  /* local variables representing the attr indices of the involved node and edge attrs,\n" +
						"   * for each pair of pattern-node/edge-num and attr-id occuring as a qualification\n" +
						"   * expressionin the condition, there's a variable representing that pair. */\n");
				//for all involved pattern nodes
				for (Iterator<Node> node_it = involved_nodes.iterator(); node_it.hasNext(); ) {
					Node current_pattern_node = node_it.next();
					String pattern_or_neg = "pattern";

					Integer node_num = (Integer)pattern_node_num[ act_id ].get(current_pattern_node);
					if( node_num == null ) {
						node_num = (Integer)negative_node_num[ act_id ][ pattern_num-1 ].get(current_pattern_node);
						pattern_or_neg = "negative_pattern";
					}

					Iterator<Integer> attr_id_it =
						involvedPatternNodeAttrIds.get(current_cond).get( current_pattern_node ).iterator();

					for (; attr_id_it.hasNext(); ) {

						Integer attr_id = attr_id_it.next();
						String kindStr =
							AttrTypeDescriptor.kindToStr(node_attr_info[attr_id.intValue()]);
						sb.append(
							"  int index_a" + attr_id + "_" + pattern_or_neg +  "_node_" + node_num + " = " +
								"fb_node_attr_index[type_" + pattern_or_neg + "_node_"  + node_num + "][" + attr_id + "];\n" +
								"  /*assert (" + pattern_or_neg + "_node_" + node_num +"->" +
								"attr_values[index_a" + attr_id + "_" + pattern_or_neg +  "_node_" + node_num + "]" +
								".kind == " + kindStr + " &&\n" +
								"    \"an attr kind tag found in a host graph node does not conform\" &&\n" +
								"    \"with the kind computed by the generator\");*/\n");
					}
				}
				//for all involved pattern edges
				for (Iterator<Edge> edge_it = involved_edges.iterator(); edge_it.hasNext(); ) {
					Edge current_pattern_edge = edge_it.next();
					String pattern_or_neg = "pattern";

					Integer edge_num = (Integer)pattern_edge_num[ act_id ].get(current_pattern_edge);
					if( edge_num == null ) {
						edge_num = (Integer)negative_edge_num[ act_id ][ pattern_num-1 ].get(current_pattern_edge);
						pattern_or_neg = "negative_pattern";
					}

					Iterator<Integer> attr_id_it =
						involvedPatternEdgeAttrIds.get(current_cond).get(current_pattern_edge).iterator();
					for (; attr_id_it.hasNext(); ) {
						Integer attr_id = attr_id_it.next();
						String kindStr =
							AttrTypeDescriptor.kindToStr(edge_attr_info[attr_id.intValue()]);
						sb.append(
							"  int index_a" + attr_id + "_" + pattern_or_neg +  "_edge_" + edge_num + " = " +
								"fb_edge_attr_index[type_" + pattern_or_neg + "_edge_" + edge_num + "][" + attr_id + "];\n" +
								"  /*assert (" + pattern_or_neg + "_edge_" + edge_num +"->" +
								"attr_values[index_a" + attr_id + "_" + pattern_or_neg +  "_edge_" + edge_num + "]" +
								".kind == " + kindStr + " &&\n" +
								"   \"an attr kind tag found in a host graph edge does not conform\" &&" +
								"   \"with the kind computed by the generator\");*/\n");
					}
				}
				//gen the code for actual evalution of the cond
				sb.append(
					"\n" +
						"  /* check the condition */\n" +
						"  condition_holds = (\n" +
						"    ");
				genExprTree_recursive(sb, act, current_cond, pattern_num, true);
				sb.append(
					"\n  );\n\n" +
						"  /* ALL conditions of an action have to be true! So return '0' even\n" +
						"   * when only ONE condition fails and '1' IFF all conditions hold */\n" +
						"  if ( ! condition_holds ) return 0; /* condition failed */\n" +
						"  else return 1;\n" +
						"}\n" +
						"/* end of processing condition " + cond_num + " */\n\n\n");
			}





			//for all type conditions gen C-code
			for (Iterator<Collection<InheritanceType>> it = typeConditions[act_id].iterator(); it.hasNext(); ) {
				//get the current type condition
				Collection<InheritanceType> current_type_cond = it.next();

				int cond_num = typeConditionNumbers.get(current_type_cond).intValue();
				int pattern_num = typeConditionsPatternNum.get(current_type_cond) == null ? 0 : typeConditionsPatternNum.get(current_type_cond).intValue();

				Collection<Node> involved_nodes =
					typeConditionsInvolvedNodes.get(current_type_cond);
				Collection<Edge> involved_edges =
					typeConditionsInvolvedEdges.get(current_type_cond);

				/*gen the code for the current cond */
				if (!involved_nodes.isEmpty() || !involved_edges.isEmpty())
					sb.append(
						"/* condition " + cond_num + " (is a type condition, " +
							"belongs to action " + act_id + ") */\n" +
							"static int type_condition_" + cond_num + "_of_action_" + act_id + "()\n" +
							"{\n" +
							"  int condition_holds;\n" +
							"  /* local variables representing the 'ptr to' and the 'actual type of' the\n" +
							"   * host graph image of the pattern node/edge with the respective number */\n");

				//for the involved pattern node/edge gen two local variables, one representing
				//the ptr to the host graph image of the node/edge and the other representing
				//that host graph nodes actual type (note that this type may be a SUB-type
				//of the pattern nodes type

				if (!involved_nodes.isEmpty()) {
					//that means that the graph component the current type
					//condition relates to is a node
					Node current_pattern_node = involved_nodes.iterator().next();
					String pattern_or_neg = "pattern";

					Integer node_num = (Integer)pattern_node_num[ act_id ].get(current_pattern_node);
					if( node_num == null ) {
						node_num = (Integer)negative_node_num[ act_id ][ pattern_num+1 ].get(current_pattern_node);
						pattern_or_neg = "negative_pattern";

						sb.append("  fb_node_t *negative_pattern_node_" + node_num + " = get_negative_node(" + node_num + ");\n");
					}
					else {
						sb.append("  fb_node_t *pattern_node_" + node_num + " = get_host_node(" + node_num + ");\n");
					}

					sb.append ("  int type_" + pattern_or_neg + "_node_" + node_num + " = (int) " + pattern_or_neg + "_node_" + node_num + "->type;\n" +
								   "\n" +
								   "  /* check the type condition */\n" +
								   "  condition_holds = (\n" +
								   "    ");


					Iterator<InheritanceType> type_it = current_type_cond.iterator();
					for (int counter = 0; type_it.hasNext(); ) {
						int type_id = nodeTypeMap.get(type_it.next()).intValue();
						if (counter++ > 0)
							sb.append(" && ");

						sb.append("(type_" + pattern_or_neg + "_node_" + node_num + " != " + type_id + ")");
					}
				}
				else if (!involved_edges.isEmpty()) {
					//that means that the graph component the current type
					//condition relates to is an edge
					Edge current_pattern_edge = involved_edges.iterator().next();
					Integer edge_num = (Integer)pattern_edge_num[ act_id ].get(current_pattern_edge);
					String pattern_or_neg = "pattern";

					if( edge_num == null ) {
						edge_num = (Integer)negative_edge_num[ act_id ][ pattern_num+1 ].get(current_pattern_edge);
						pattern_or_neg = "negative_pattern";

						sb.append("  fb_edge_t *negative_pattern_edge_" + edge_num + " = get_negative_edge(" + edge_num + ");\n");
					}
					else {
						sb.append("  fb_edge_t *pattern_edge_" + edge_num + " = get_host_edge(" + edge_num + ");\n");
					}

					sb.append( "  int type_" + pattern_or_neg + "_edge_" + edge_num + " = (int) " + pattern_or_neg + "_edge_" + edge_num + "->type;\n" +
								  "\n" +
								  "  /* check the type condition */\n" +
								  "  condition_holds = (\n" +
								  "    ");

					Iterator<InheritanceType> type_it = current_type_cond.iterator();
					for (int counter = 0; type_it.hasNext(); ) {
						int type_id = edgeTypeMap.get(type_it.next()).intValue();
						if (counter++ > 0)
							sb.append(" && ");

						sb.append("(type_" + pattern_or_neg + "_edge_" + edge_num + " != " + type_id + ")");
					}
				}



				if (!involved_nodes.isEmpty() || !involved_edges.isEmpty())
					sb.append(
						"\n  );\n\n" +
							"  /* ALL conditions of an action have to be true! So return '0' even\n" +
							"   * when only ONE condition fails and '1' IFF all conditions hold */\n" +
							"  if ( ! condition_holds ) return 0; /* condition failed */\n" +
							"  else return 1;\n" +
							"}\n" +
							"/* end of processing condition " + cond_num + " */\n\n\n");
			}
		}
	}

	private void genCondCode(StringBuffer sb, MatchingAction act, int pattern_num, Expression if_expr) {
		if (sb == null || if_expr == null) return;

		/* gen C-code for qualification expressions */
		if (if_expr instanceof Qualification) {
			Qualification qual = (Qualification) if_expr;
			Entity owner = qual.getOwner();
			Entity attr = qual.getMember();

			assert (owner instanceof Node) || (owner instanceof Edge):
				"an entity which is neither a node nor an edge owns a graph attr";

			if (owner instanceof Node) {
				int act_id = actionMap.get(act).intValue();

				String pattern_or_neg = "pattern";
				Integer node_num = (Integer)pattern_node_num[ act_id ].get(owner);
				if( node_num == null ) {
					node_num = (Integer)negative_node_num[ act_id ][ pattern_num-1 ].get(owner);
					pattern_or_neg = "negative_pattern";
				}

				Integer attr_id = nodeAttrMap.get(attr);

				sb.append(
					pattern_or_neg + "_node_" + node_num + "->attr_values[index_a" + attr_id +
						"_" + pattern_or_neg + "_node_" + node_num + "].value.");

				int attr_kind = node_attr_info[attr_id.intValue()].kind;
				switch (attr_kind) {
					case AttrTypeDescriptor.INTEGER:
						sb.append("integer");
						break;

					case AttrTypeDescriptor.BOOLEAN:
						sb.append("boolean");
						break;

					case AttrTypeDescriptor.STRING:
						sb.append("str");
						break;

					case AttrTypeDescriptor.ENUM:
						sb.append("integer");
						break;
				}
			}
			if (owner instanceof Edge) {
				int act_id = actionMap.get(act).intValue();
				String pattern_or_neg = "pattern";
				Integer edge_num = (Integer)pattern_edge_num[ act_id ].get(owner);
				if( edge_num == null ) {
					edge_num = (Integer)negative_edge_num[ act_id ][ pattern_num-1 ].get(owner);
					pattern_or_neg = "negative_pattern";
				}

				Integer attr_id = edgeAttrMap.get(attr);

				sb.append(
					pattern_or_neg + "_edge_" + edge_num + "->attr_values[index_a" + attr_id +
						"_" + pattern_or_neg + "_edge_" + edge_num + "].value.");

				int attr_kind = edge_attr_info[attr_id.intValue()].kind;
				switch (attr_kind) {
					case AttrTypeDescriptor.INTEGER:
						sb.append("integer");
						break;

					case AttrTypeDescriptor.BOOLEAN:
						sb.append("boolean");
						break;

					case AttrTypeDescriptor.STRING:
						sb.append("str");
						break;

					case AttrTypeDescriptor.ENUM:
						sb.append("integer");
						break;
				}
			}
		}

	}

	/* just like __recursive_expr_code_gen but prefer replacement nodes/edges */
	private void genEvalCode(StringBuffer sb, MatchingAction act, Expression eval_expr) {
		if (sb == null || eval_expr == null) return;

		/* gen C-code for qualification expressions */
		if (eval_expr instanceof Qualification) {
			Qualification qual = (Qualification) eval_expr;
			Entity owner = qual.getOwner();
			Entity attr = qual.getMember();

			assert (owner instanceof Node) || (owner instanceof Edge):
				"an entity which is neither a node nor an edge owns a graph attr";

			if (owner instanceof Node) {
				int act_id = actionMap.get(act).intValue();
				Node node = (Node)owner;
				String pattern_or_repl = "replacement";

				//Integer node_num = (Integer) pattern_node_num[act_id].get(owner);
				Integer attr_id = nodeAttrMap.get(attr);

				Integer node_num;
				if(node.isRetyped()) {
					Node old_node = ((RetypedNode)node).getOldNode();
					node_num = (Integer)replacement_node_num[ act_id ].get( old_node );

					sb.append(
						"acts_p->old_attributes[ " + node_num + " ][ index_a" + attr_id + "_old_replacement_node_" +
							node_num + " ].value.");
				}
				else {
					node_num = (Integer) replacement_node_num[ act_id ].get( owner );
					if( node_num == null ) {
						node_num = (Integer)pattern_node_num[ act_id ].get( owner );
						pattern_or_repl = "pattern";
					}

					sb.append(
						pattern_or_repl + "_node_" + node_num +
							"->attr_values[ index_a" + attr_id + "_" + pattern_or_repl + "_node_" + node_num + " ].value.");
				}
				int attr_kind = node_attr_info[attr_id.intValue()].kind;
				switch (attr_kind) {
					case AttrTypeDescriptor.INTEGER:
						sb.append("integer");
						break;

					case AttrTypeDescriptor.BOOLEAN:
						sb.append("boolean");
						break;

					case AttrTypeDescriptor.STRING:
						sb.append("str");
						break;

					case AttrTypeDescriptor.ENUM:
						sb.append("integer");
						break;
				}
			}
			if (owner instanceof Edge) {
				int act_id = actionMap.get(act).intValue();
				String pattern_or_repl = "replacement";

				//Integer edge_num = (Integer) pattern_edge_num[act_id].get(owner);

				Integer edge_num = (Integer) replacement_edge_num[ act_id ].get( owner );
				if( edge_num == null ) {
					edge_num = (Integer)pattern_edge_num[ act_id ].get( owner );
					pattern_or_repl = "pattern";
				}

				Integer attr_id = edgeAttrMap.get(attr);

				sb.append(
					pattern_or_repl + "_edge_" + edge_num +
						"->attr_values[ index_a" + attr_id + "_" + pattern_or_repl + "_edge_" + edge_num + " ].value.");

				int attr_kind = edge_attr_info[attr_id.intValue()].kind;
				switch (attr_kind) {
					case AttrTypeDescriptor.INTEGER:
						sb.append("integer");
						break;

					case AttrTypeDescriptor.BOOLEAN:
						sb.append("boolean");
						break;

					case AttrTypeDescriptor.STRING:
						sb.append("str");
						break;

					case AttrTypeDescriptor.ENUM:
						sb.append("integer");
						break;
				}
			}
		}

	}

	private void genExprTree_recursive(StringBuffer sb, MatchingAction act, Expression expr, int pattern_num, boolean recursiveCond) {
		if (sb == null || expr == null) return;

		/* gen C-code for Operator-expressions */
		if (expr instanceof Operator) {
			Operator op = (Operator) expr;
			int opCode = op.getOpCode();

			// if the operator is a binary one...
			if (op.arity() == 2) {

				//in binary expression both operands got to have the same type
				assert  op.getOperand(0).getType().equals(op.getOperand(1).getType()) : "different operand types found in binary expression";

				//if both operands are Strings, comparisions have to be performed
				//via C function strcmp()
				if ( op.getOperand(0).getType().classify() == Type.IS_STRING ) {
					switch (opCode) {
						case Operator.EQ:
							sb.append("( !strcmp(");
							genExprTree_recursive(sb, act, op.getOperand(0), pattern_num, recursiveCond);
							sb.append(", ");
							genExprTree_recursive(sb, act, op.getOperand(1), pattern_num, recursiveCond);
							sb.append(") )");
							break;

						case Operator.NE:
							sb.append("strcmp(");
							genExprTree_recursive(sb, act, op.getOperand(0), pattern_num, recursiveCond);
							sb.append(", ");
							genExprTree_recursive(sb, act, op.getOperand(1), pattern_num, recursiveCond);
							sb.append(")");
							break;

						case Operator.ADD:
							sb.append("__fb_acts__strconcat(");
							genExprTree_recursive(sb, act, op.getOperand(0), pattern_num, recursiveCond);
							sb.append(", ");
							genExprTree_recursive(sb, act, op.getOperand(1), pattern_num, recursiveCond);
							sb.append(")");
							break;

						default:
							assert false : "Operation "+op+" not permitted on string Operands";
							break;
					}
				}
					// we do not have string operands: gen a infix expression
				else {
					String opSymbol = opSymbols[opCode];
					sb.append("(");
					genExprTree_recursive(sb, act, op.getOperand(0), pattern_num, recursiveCond);
					sb.append(" " + opSymbol + " ");
					genExprTree_recursive(sb, act, op.getOperand(1), pattern_num, recursiveCond);
					sb.append(")");
				}
			}
				//if not...
			else {
				switch (opCode) {
					case Operator.COND:
						sb.append("(");
						genExprTree_recursive(sb, act, op.getOperand(0), pattern_num, recursiveCond);
						sb.append(" ? ");
						genExprTree_recursive(sb, act, op.getOperand(1), pattern_num, recursiveCond);
						sb.append(" : ");
						genExprTree_recursive(sb, act, op.getOperand(2), pattern_num, recursiveCond);
						sb.append(")");
						break;

					case Operator.LOG_NOT:
						sb.append("(!");
						genExprTree_recursive(sb, act, op.getOperand(0), pattern_num, recursiveCond);
						sb.append(")");
						break;

					case Operator.BIT_NOT:
						sb.append("(~");
						genExprTree_recursive(sb, act, op.getOperand(0), pattern_num, recursiveCond);
						sb.append(")");
						break;

					case Operator.NEG:
						sb.append("(-");
						genExprTree_recursive(sb, act, op.getOperand(0), pattern_num, recursiveCond);
						sb.append(")");
						break;

					case Operator.CAST:
						//TODO: Type casts are not implemented yet!!!!!
						assert false : "cast op not implemented yet!!!";
						break;
					default:
						assert false : "unsupported op: " + op;
				}
			}
		}
			/* gen C-code for constant expressions */
		else if (expr instanceof Constant) {
			Constant constant = (Constant) expr;
			Type type = constant.getType();

			switch (type.classify()) {
				//emit C-code for string constants
				case Type.IS_STRING:
					sb.append("\"" + constant.getValue() + "\"");
					break;

					//emit C-code for boolean constans
				case Type.IS_BOOLEAN:
					Boolean bool_const = (Boolean) constant.getValue();
					if ( bool_const.booleanValue() )
						sb.append("1"); /* true-value */
					else
						sb.append("0"); /* false-value */
					break;

					//emit C-code for integer constants
				case Type.IS_INTEGER:
					sb.append(constant.getValue().toString()); /* this also applys to enum constants */
					break;
				default:
					assert false : "unsupported type: " + type;
			}
		}

		/* expr is a qual: call or either condition code generation or eval code generation */
		if(recursiveCond)
			genCondCode(sb, act, pattern_num, expr);
		else
			genEvalCode(sb, act, expr);

	}

	private void _initialize_qual(StringBuffer sb, MatchingAction act, Qualification qual) {
		Entity owner = qual.getOwner();
		Entity attr = qual.getMember();

		assert (owner instanceof Node) || (owner instanceof Edge):
			"an entity which is neither a node nor an edge owns a graph attr";

		if (owner instanceof Node) {
			int act_id = actionMap.get(act).intValue();
			Node node = (Node)owner;
			String pattern_or_repl = "replacement";

			//Integer node_num = (Integer) pattern_node_num[act_id].get(owner);
			Integer attr_id = nodeAttrMap.get(attr);

			Integer node_num;
			if(node.isRetyped()) {
				Node old_node = ((RetypedNode)node).getOldNode();
				node_num = (Integer)replacement_node_num[ act_id ].get( old_node );

				sb.append(
					"  if ( acts_p->old_attributes[ " + node_num + " ]" +
						"[index_a" + attr_id + "_old_replacement_node_" + node_num + "]" +
						".kind >= FB_ATTR_KIND_DIST )\n    " +
						"acts_p->old_attributes[ " + node_num + " ]" +
						"[index_a" + attr_id + "_old_replacement_node_" + node_num + "]" +
						".kind -= FB_ATTR_KIND_DIST;\n" );
			}
			else {
				node_num = (Integer) replacement_node_num[ act_id ].get( owner );
				if( node_num == null ) {
					node_num = (Integer)pattern_node_num[ act_id ].get( owner );
					pattern_or_repl = "pattern";
				}

				sb.append(
					"  if (" + pattern_or_repl + "_node_" + node_num +"->" +
						"attr_values[index_a" + attr_id + "_" + pattern_or_repl + "_node_" + node_num + "]" +
						".kind >= FB_ATTR_KIND_DIST )\n    " +
						pattern_or_repl + "_node_" + node_num +"->" +
						"attr_values[index_a" + attr_id + "_" + pattern_or_repl + "_node_" + node_num + "]" +
						".kind -= FB_ATTR_KIND_DIST;\n" );
			}
		}
		if (owner instanceof Edge) {
			int act_id = actionMap.get(act).intValue();
			String pattern_or_repl = "replacement";

			//Integer edge_num = (Integer) pattern_edge_num[act_id].get(owner);

			Integer edge_num = (Integer) replacement_edge_num[ act_id ].get( owner );
			if( edge_num == null ) {
				edge_num = (Integer)pattern_edge_num[ act_id ].get( owner );
				pattern_or_repl = "pattern";
			}

			Integer attr_id = edgeAttrMap.get(attr);

			sb.append(
				"  if (" + pattern_or_repl + "_edge_" + edge_num +"->" +
					"attr_values[index_a" + attr_id + "_" + pattern_or_repl + "_edge_" + edge_num + "]" +
					".kind >= FB_ATTR_KIND_DIST )\n    " +
					pattern_or_repl + "_edge_" + edge_num +"->" +
					"attr_values[index_a" + attr_id + "_" + pattern_or_repl + "_edge_" + edge_num + "]" +
					".kind -= FB_ATTR_KIND_DIST;\n" );
		}
	}



	/**
	 * Method genActionsDescr
	 *
	 * @param    sb                  a  StringBuffer
	 *
	 */
	private void genActionsDescr(StringBuffer sb) {
		/* gen the file preamble */
		sb.append(
			"/*\n" +
				" * File 'actions_descr.inc', created automatically by\n" +
				" * the FrameBased-Backend of GrGen.\n" +
				" *\n" +
				" * The data structures initialized in this file represent the type information\n" +
				" * as specified by the GrGen input file '" + unit.getFilename() + "'.\n" +
				" */\n\n\n" +
				"\n\n/*----------------------- Some stuff the conditions of " +
				"all actions -----------------------*/\n\n\n");


		/* gen all the C-stuff desribing pattern, replacement, conditions,
		 actions, ... */

		//iterate over all actions
		for(Iterator<Action> it = actionMap.keySet().iterator(); it.hasNext(); ) {
			//get the current action
			Action act = it.next();
			int act_id = actionMap.get(act).intValue();

			//for all conditions gen the C-structs describing the conditions
			Collection<Object> allConditions = new HashSet<Object>();
			allConditions.addAll(conditions.get(act_id));
			allConditions.addAll(typeConditions[act_id]);

			for (Iterator<Object> cond_it = allConditions.iterator(); cond_it.hasNext(); ) {
				int cond_num;
				Object condition = cond_it.next();
				Collection<Node> involved_nodes;
				Collection<Edge> involved_edges;
				int pattern_num;

				if (condition instanceof Expression) {
					cond_num = conditionNumbers.get(condition).intValue();
					involved_nodes =
						conditionsInvolvedNodes.get(condition);
					involved_edges =
						conditionsInvolvedEdges.get(condition);
					pattern_num = conditionsPatternNum.get(condition) == null ? 0 : conditionsPatternNum.get(condition).intValue();
				}
				else {
					cond_num = typeConditionNumbers.get(condition).intValue();
					involved_nodes =
						typeConditionsInvolvedNodes.get(condition);
					involved_edges =
						typeConditionsInvolvedEdges.get(condition);
					pattern_num = typeConditionsPatternNum.get(condition) == null ? 0 : typeConditionsPatternNum.get(condition).intValue();
				}



				//gen two arrays containing the pattern node/edge numbers involved
				//in the current condition (in ascending order)
				sb.append(
					"/* data describing condition " + cond_num +
						", which belongs to " + "action " + act_id + " */\n");
				String involved_nodes_array = "NULL";
				String involved_edges_array = "NULL";
				if (involved_nodes.size() > 0) {
					sb.append(
						"int involved_nodes_of_cond_" + cond_num +
							"[" + involved_nodes.size() + "] = { ");

					Iterator<Node> node_it = involved_nodes.iterator();
					for ( ; node_it.hasNext() ; ) {
						Node node = node_it.next();

						Integer node_num = (Integer) pattern_node_num[act_id].get(node);
						if( node_num == null ) {
							node_num = (Integer)negative_node_num[ act_id ][ pattern_num-1 ].get(node);
						}

						sb.append(node_num);
						if (node_it.hasNext()) sb.append(", ");
					}
					sb.append(" };\n");
					involved_nodes_array = "involved_nodes_of_cond_" + cond_num;
				}
				if (involved_edges.size() > 0) {
					sb.append(
						"int involved_edges_of_cond_" + cond_num +
							"[" + involved_edges.size() + "] = { ");
					Iterator<Edge> edge_it = involved_edges.iterator();
					for ( ; edge_it.hasNext() ; ) {
						Edge edge = edge_it.next();

						Integer edge_num = (Integer) pattern_edge_num[act_id].get(edge);
						if( edge_num == null ) {
							edge_num = (Integer)negative_edge_num[ act_id ][ pattern_num-1 ].get(edge);
						}

						sb.append(edge_num);
						if (edge_it.hasNext()) sb.append(", ");
					}
					sb.append(" };\n");
					involved_edges_array = "involved_edges_of_cond_" + cond_num;
				}
				//gen the actual condition descriptor
				sb.append(
					"fb_condition_descr_t condition_" + cond_num + " = {\n" +
						"  " + cond_num + ", (gr_id_t)" + act_id + ",\n" +
						"  " + involved_nodes.size() + ", " + involved_nodes_array + ",\n" +
						"  " + involved_edges.size() + ", " + involved_edges_array + "\n" +
						"};\n\n");
			}
		}

		//gen pattern, replacement and action-struct for all actions
		for(Iterator<Action> it = actionMap.keySet().iterator(); it.hasNext(); ) {

			//get the current action
			Action act = it.next();
			//get the current actions id
			int act_id = actionMap.get(act).intValue();
			assert act_id < n_graph_actions:
				"action id found which was greater than the number of graph actions";

			//gen pattern graph of the current action
			if (act instanceof MatchingAction) {
				//get the current actions pattern graph
				PatternGraph pattern = ((MatchingAction)act).getPattern();

				// TODO Process parameters
				System.out.println("\n  " + act + " : PARAMS = " + ((MatchingAction)act).getParameters());
				System.out.println(  "  " + act + " : RETURN = " + ((MatchingAction)act).getReturns() + "\n");

				//create a C-identifier for the currents action pattern graph
				String graphName = "pattern_graph_of_action_" + act_id;
				//setup the maps with the precomputes node and edge numbers
				Map<Node, Integer> node_numbers = pattern_node_num[act_id];
				Map<Edge, Integer> edge_numbers = pattern_edge_num[act_id];
				//gen C-data-structures describing its pattern and replacemant graph
				sb.append(
					"\n\n\n\n\n/*------------------ Some stuff describing the " +
						" pattern and (if exists) the replacement of action " +
						act_id + " ------------------*/\n\n\n");
				genGraph(
					sb, pattern, graphName, "pattern_", "_of_action_" + act_id,
					node_numbers, edge_numbers, n_subgraphs[act_id], subgraphOfNode, subgraphOfEdge);

				for(Iterator<PatternGraph> neg_it = negMap[act_id].keySet().iterator(); neg_it.hasNext(); ) {

					//get the current negative pattern graph
					PatternGraph neg_pattern = neg_it.next();
					int neg_num = ((Integer)negMap[act_id].get(neg_pattern)).intValue();

					//create a C-identifier for the currents action pattern graph
					String neg_graphName = "negative_pattern_graph_" + neg_num + "_of_action_" + act_id;

					//setup the maps with the precomputes node and edge numbers
					Map<Node, Integer> neg_node_numbers = negative_node_num[act_id][neg_num];
					Map<Edge, Integer> neg_edge_numbers = negative_edge_num[act_id][neg_num];

					genGraph(
						sb, neg_pattern, neg_graphName, "negative_pattern_" + neg_num + "_", "_of_action_" + act_id,
						neg_node_numbers, neg_edge_numbers, 0, null, null);
				}
			}

			//gen replacemant graph of the current action if there exists one
			if (act instanceof Rule) {
				//get the current actions pattern graph
				Graph replacement = ((Rule)act).getRight();
				//create a C-identifier for the currents action pattern graph
				String graphName = "replacement_graph_of_action_" + act_id;
				//setup the maps with the precomputes node and edge numbers
				Map<Node, Integer> node_numbers = replacement_node_num[act_id];
				Map<Edge, Integer> edge_numbers = replacement_edge_num[act_id];
				//gen C-data-structures describing its pattern and replacemant graph
				genGraph(
					sb, replacement, graphName, "replacement_",
					"_of_action_" + act_id, node_numbers, edge_numbers, 0, null, null);
			}

		}
		genActualActions(sb);
	}

	private void genActionsInfo(StringBuffer sb) {
		/* gen the file preamble */
		sb.append(
			"/*\n" +
				" * File 'actions_info.inc', created automatically by\n" +
				" * the FrameBased-Backend of GrGen.\n" +
				" *\n" +
				" * The defines in this file replresent some information extracted\n" +
				" * from the GrGen input file '" + unit.getFilename() + "'.\n" +
				" */\n\n\n");

		sb.append(
			"/* the overall number of graph actions */\n" +
				"#define fb_N_ACTIONS " + n_graph_actions + "\n\n" +
				"/* the overall number of pattern graph conditions */\n" +
				"#define fb_N_CONDITIONS " + n_conditions + "\n\n");

		sb.append(
			"/* the overall maximum number of nodes and edges of all\n" +
				" * pattern and replacement graphs respectively */\n" +
				"#define fb_MAX_N_PATTERN_NODES " + max_n_pattern_nodes + "\n" +
				"#define fb_MAX_N_PATTERN_EDGES " + max_n_pattern_edges + "\n" +
				"#define fb_MAX_N_REPLACEMENT_NODES " + max_n_replacement_nodes + "\n" +
				"#define fb_MAX_N_REPLACEMENT_EDGES " + max_n_replacement_edges + "\n" +
				"#define fb_MAX_N_NEGATIVE_PATTERNS " + max_n_negative_patterns + "\n" +
				"#define fb_MAX_N_NEGATIVE_NODES " + max_n_negative_nodes + "\n" +
				"#define fb_MAX_N_NEGATIVE_EDGES " + max_n_negative_edges + "\n" +
				"#define fb_MAX_N_SUBGRAPHS " + max_n_subgraphs + "\n" +
				"\n\n");
	}


	/**
	 * Method genGraph
	 *
	 * @param    sb                  where the generated C code is stored in
	 * @param    graph               the Graph (pattern or replacement)
	 * 								 to gen C code for
	 * @param    graphName           The C identifier for the generated C struct
	 * @param    prefix              a prefix for C identifiers of nodes and edges
	 * @param    postfix             a postfix for C identifiers of nodes and edges
	 * @param    node_numbers        a Map relating node objects to
	 * 								 actions-impl-internal node numbers
	 * @param    edge_numbers        a Map relating edge objects to
	 * 								 actions-impl-internal edge numbers
	 *
	 */
	private void genGraph(
		StringBuffer sb, Graph graph, String graphName,
		String prefix, String postfix,
		Map<Node, Integer> node_numbers, Map<Edge, Integer> edge_numbers,
		int n_subgraphs,
		Map<Node, Integer> subgraphOfNode, Map<Edge, Integer> subgraphOfEdge ) {
		if(n_subgraphs <= 0) n_subgraphs = 1;

		int[] node_index_in_subgraph = new int[n_subgraphs];
		int[] edge_index_in_subgraph = new int[n_subgraphs];

		for(int i=0; i<n_subgraphs; i++) {
			node_index_in_subgraph[i] = 0;
			edge_index_in_subgraph[i] = 0;
		}

		/* gen C-prototypes for all pattern graph nodes */
		if (graph.getNodes().size() > 0) {
			sb. append(
				"/* node prototypes of graph " + graphName + " */\n");
			//get an iterator over the graph nodes
			Iterator<Node> node_it = graph.getNodes().iterator();
			//for nodes...
			for ( ; node_it.hasNext(); ) {
				//...create a C-prototype of type fb_acts_node_t
				Node node = (Node) node_it.next();
				int node_num = node_numbers.get(node).intValue();
				sb.append(
					"static fb_acts_node_t " + prefix + "node_" + node_num +
						postfix + ";\n");
			}
			sb.append("\n");
		}

		/* gen a sequence of structs representing all the edges of the graph */
		if (graph.getEdges().size() > 0) {
			sb.append(
				"/* all the edges of graph " + graphName + " */\n");
			Iterator<Edge> edge_it = graph.getEdges().iterator();
			for ( ; edge_it.hasNext(); ) {
				Edge edge = edge_it.next();
				int edge_num = edge_numbers.get(edge).intValue();
				int edge_type = getId((EdgeType)edge.getType());
				int src_node_num =
					node_numbers.get(graph.getSource(edge)).intValue();
				int tgt_node_num =
					node_numbers.get(graph.getTarget(edge)).intValue();

				int subgraph = 0;
				if(subgraphOfEdge != null) {
					subgraph = subgraphOfEdge.get(edge).intValue();
				}

				int index = edge_index_in_subgraph[subgraph]++;

				//gen a struct which describes an fb_acts_edge_t
				sb.append(
					"static fb_acts_edge_t " + prefix + "edge_" + edge_num + postfix +
						" = {\n" +
						"  " + edge_num + ", \"" + edge.getIdent() + "\"" +
						", (gr_id_t)" + edge_type +
						", &" + prefix + "node_" + src_node_num + postfix +
						", &" + prefix + "node_" + tgt_node_num + postfix + ",\n" );

				if(emit_subgraph_info)
					sb.append( "  " + subgraph + ", " + index );

				sb.append( " };\n" );
			}
			sb.append("\n");
		}

		/* gen a sequence of structs representing all the nodes graph */
		if (graph.getNodes().size() > 0) {
			sb.append(
				"/* all the nodes of graph " + graphName + " and their arrays\n" +
					" * of incomming and outgoing edges */\n");
			Iterator<Node> node_it = graph.getNodes().iterator();
			//for all nodes...
			for ( ; node_it.hasNext(); ) {
				Node node = (Node) node_it.next();
				int node_num = node_numbers.get(node).intValue();
				int n_out_edges = graph.getOutDegree(node);
				int n_in_edges = graph.getInDegree(node);
				int node_type = getId((NodeType)node.getType());

				//gen this nodes array of outgoing edges
				String out_edges_array = "NULL";
				if ( n_out_edges > 0 ) {
					sb.append(
						"static fb_acts_edge_t *out_edges_of_node_"  + node_num + "_of_" +
							graphName + "[" + graph.getOutDegree(node) + "] = {\n  ");
					//iterate over all outgoing edges of the current node...
					Iterator<Edge> edge_it = graph.getOutgoing(node).iterator();
					//...and gen an array of ptrs of type *fb_acts_edge_t
					for ( ; edge_it.hasNext(); ) {
						Edge out_edge = edge_it.next();
						int edge_num = edge_numbers.get(out_edge).intValue();
						sb.append("&" + prefix + "edge_" + edge_num + postfix);
						if (edge_it.hasNext()) sb.append(", ");
					}
					sb.append("\n};\n");
					out_edges_array = "out_edges_of_node_"  + node_num + "_of_" + graphName;
				}
				//gen this nodes array of incomming edges
				String in_edges_array = "NULL";
				if ( n_in_edges > 0 ) {
					sb.append(
						"static fb_acts_edge_t *in_edges_of_node_" + node_num + "_of_" +
							graphName + "[" + graph.getInDegree(node) + "] = {\n  ");
					//iterate over all incomming edges of the current node...
					Iterator<? extends Edge> edge_it = graph.getIncoming(node).iterator();
					//...and gen an array of ptrs of type *fb_acts_edge_t
					for ( ; edge_it.hasNext(); ) {
						Edge in_edge = edge_it.next();
						int edge_num = edge_numbers.get(in_edge).intValue();
						sb.append("&" + prefix + "edge_" + edge_num + postfix);
						if (edge_it.hasNext()) sb.append(", ");
					}
					sb.append("\n};\n");
					in_edges_array = "in_edges_of_node_" + node_num + "_of_" + graphName;
				}

				int subgraph = 0;
				if(subgraphOfNode != null) {
					subgraph = subgraphOfNode.get(node).intValue();
				}

				int index = node_index_in_subgraph[subgraph]++;


				//gen node struct
				sb.append(
					"static fb_acts_node_t " + prefix + "node_" + node_num + postfix + " = {\n" +
						"  " + node_num + ", \"" + node.getIdent() + "\", " +
						"(gr_id_t)" + node_type + ",\n" +
						"  /* outgoing edges */\n" +
						"  " + n_out_edges + ", " + out_edges_array + ",\n" +
						"  /* incomming edges */\n" +
						"  " + n_in_edges + ", " + in_edges_array + ",\n" );

				if(emit_subgraph_info)
					sb.append( "  " + subgraph + ", " + index );

				sb.append( " };\n" );
			}
			sb.append("\n");
		}

		//gen the array of nodes of the current graph
		String graph_nodes_array = "NULL";
		if (graph.getNodes().size() > 0) {
			sb.append(
				"static fb_acts_node_t *all_nodes_of_" + graphName + "[" +
					graph.getNodes().size() + "] = {\n");
			//gen the node ptr array
			Iterator<Node> node_it = graph.getNodes().iterator();
			for ( ; node_it.hasNext(); ) {
				Node node = (Node) node_it.next();
				int node_num = node_numbers.get(node).intValue();
				sb.append(
					"    &" + prefix + "node_" + node_num + postfix);
				if (node_it.hasNext()) sb.append(",");
				sb.append("\n");
			}
			sb.append("  };\n\n");
			graph_nodes_array = "all_nodes_of_" + graphName;
		}

		//gen the array of edges of the current graph
		String graph_edges_array = "NULL";
		if (graph.getEdges().size() > 0) {
			sb.append(
				"static fb_acts_edge_t *all_edges_of_" + graphName + "[" +
					graph.getEdges().size() + "] = {\n");
			//gen the edge ptr array
			Iterator<Edge> edge_it = graph.getEdges().iterator();
			for ( ; edge_it.hasNext(); ) {
				Edge edge = edge_it.next();
				int edge_num = edge_numbers.get(edge).intValue();
				sb.append(
					"    &" + prefix + "edge_" + edge_num + postfix);
				if (edge_it.hasNext()) sb.append(",");
				sb.append("\n");
			}
			sb.append("  };\n\n");
			graph_edges_array = "all_edges_of_" + graphName;
		}

		/* gen the struct representing the hole pattern graph */
		sb.append(
			"/* the struct representing the hole graph */\n"  +
				"static fb_acts_graph_t " + graphName + " = {\n" +
				"  " + graph.getNodes().size() + ", " + graph.getEdges().size() +
				", " + graph_nodes_array + ", " + graph_edges_array + "\n");
		sb.append("};\n\n"); // end of graph struct
	}

	/**
	 * Finishes FrameBasedBackend
	 * @see de.unika.ipd.grgen.be.Backend#done()
	 */
	public void done() {
		/* nothing to do yet */
	}




	/**
	 * Generates some graph type information specified by the grg-file,
	 * that is info the number of types, emuns,...
	 */
	private void genGraphTypeInfo(StringBuffer sb) {
		//gen the file preamble
		sb.append(
			"/*\n" +
				" * File 'graph_type_info.inc', created automatically by\n" +
				" * the FrameBased-Backend of GrGen.\n" +
				" */\n\n");

		sb.append(
			"#ifndef __GRAPH_TYPE_INFO_INC__\n" +
				"#define __GRAPH_TYPE_INFO_INC__\n\n");


		//gen defines: the number of node- and edge-types
		sb.append(
			"/* the name of the GrGen unit this file is created from */\n" +
				"#define fb_UNIT_NAME \"" + formatId(unit.getUnitName()) + "\"\n\n" +
				"/* the overall number of the edge-, node-, enum-types and of the\n" +
				" * declared node- and edge attributes */\n" +
				"#define fb_n_node_types " + n_node_types + "\n" +
				"#define fb_n_edge_types " + n_edge_types + "\n" +
				"#define fb_n_enum_types " + n_enum_types + "\n" +
				"#define fb_n_node_attr_decls " + n_node_attrs + "\n" +
				"#define fb_n_edge_attr_decls " + n_edge_attrs + "\n\n");

		//gen defines: a string indicating the reqired backend together with
		// a hash value computed from the used graph model
		sb.append(
			"/* the reqired backend together with a tag indicating the impl\n" +
				" * variant used (i.e. flat, hash or flash) */\n" +
				"#define fb_REQUIRED_BE \"FrameBased__FLAT\"\n" +
				"\n");

		sb.append(
			"/* an MD5 hash value characterising the underlying graph type model */\n" +
				"#define fb_GR_MODEL \"" +
				"GM_is_" + unit.getTypeDigest() + "\"\n\n");

		sb.append("#endif /* __GRAPH_TYPE_INFO_INC__ */\n\n");



	}


	/* generates the graph type information specified by the grg-file,
	 * that is info about edge and node classes and their attributes
	 * and their inheritance relation
	 */
	private void genGraphTypeDescr(StringBuffer sb) {
		//gen the file preamble
		sb.append(
			"/*\n" +
				" * File 'graph_type_descr.inc', created automatically by\n" +
				" * the FrameBased-Backend of GrGen.\n" +
				" *\n" +
				" * The data structures initialized in this file represent the type information\n" +
				" * as specified by the GrGen input file '" + unit.getFilename() + "'.\n" +
				" */\n\n");


		//gen a define: the name of the unit
//		sb.append(
//			"/* Information about the number of attributes and the number of\n edge/node/enum-types */\n" +
//			"#include \"graph_type_info.inc\"\n\n");
//

		/* gen the array representing the node-subtype relation... */
		if (n_node_types > 0) {
			sb.append(
				"/* Two arrays representing the node/edge-subtype relation:\n" +
					" * Example:  t1 'is_a' t2   IFF   array[t1][t1] == k != 0\n" +
					" * k shows the distance of t1 and t2  in the type hierarchie,\n" +
					" * i.e. k == 1 means, that t2 is a DIRECT supertype.\n" +
					" * ATTENTION: k == 0 means, that t1 is NOT a subtype of t2 !!!\n" +
					" */\n" +
					"const int fb_node_sub_type[fb_n_node_types][fb_n_node_types] = {");
			//gen the node-sub-type array content: go over the rows
			for (int row=0; row < n_node_types; row++) {
				//go over the columns: result col will be e.g. { 0,0,1,0,4,0 }
				//if there are n entries in a row, then there are only n-1 ',' chars:
				if (row != 0)
					sb.append(",");
				sb.append("\n  {");
				for (int col=0; col < n_node_types; col++) {
					if (col != 0) sb.append(", ");
					sb.append(node_is_a_matrix[row][col]);
				}
				sb.append(" }");
			}
			sb.append("\n};\n");
		}
		else {
			sb.append(
				"/* Two arrays representing the node/edge-subtype relation:\n" +
					" * Example:  t1 'is_a' t2   IFF   array[t1][t2] == k != 0\n" +
					" * k shows the distance of t1 and t2  in the type hierarchie,\n" +
					" * i.e. k == 1 means, that t2 is a DIRECT supertype.\n" +
					" * ATTENTION: k == 0 means, that t1 is NOT a subtype of t2 !!!\n" +
					" */\n" +
					"const int fb_node_sub_type[0][0] = {};\n\n");
		}
		if (n_edge_types > 0) {
			/* ...and gen the array representing the edge-subtype relation */
			sb.append(
				"const int fb_edge_sub_type[fb_n_edge_types][fb_n_edge_types] = {");
			//gen the edge-sub-type array content: go over the rows
			for (int row=0; row < n_edge_types; row++) {
				//go over the columns: result col will be e.g. { 0,0,1,0,4,0 }
				//if there are n entries in a row, then there are only n-1 ',' chars:
				if (row != 0)
					sb.append(",");
				sb.append("\n  {");
				for (int col=0; col < n_edge_types; col++) {
					if (col != 0) sb.append(", ");
					sb.append(edge_is_a_matrix[row][col]);
				}
				sb.append(" }");
			}
			sb.append("\n};\n\n");
		}
		else {
			sb.append(
				"const int fb_edge_sub_type[0][0] = {};\n\n");
		}



		/* gen an array, which maps node-type-ids on node-type names */
		//while writing the node type name array look for a type named "node"
		//this type is the root of all node types
		int root_node_type = 0;
		if (n_node_types > 0) {
			sb.append(
				"/* An array mapping a node type id to the name of that node type */\n" +
					"const char *fb_name_of_node_type[fb_n_node_types] = {\n" +
					"  \"" + getTypeName(true, 0) + "\"");
			if (getTypeName(true, 0).equals("Node")) root_node_type = 0;
			for (int nt=1; nt < n_node_types; nt++) {
				sb.append(",\n  \"" + getTypeName(true, nt) + "\"");
				if (getTypeName(true, nt).equals("Node")) root_node_type = nt;
			}
			sb.append("\n};\n\n");
		}
		else {
			sb.append(
				"/* An array mapping a node type id to the name of that node type */\n" +
					"const char *fb_name_of_node_type[0] = {};\n\n");
		}
		sb.append(
			"/* The root of the node type hierarchie */\n" +
				"#define GR_DEF_NODE_TYPE_Node " + root_node_type + "\n\n");

		/* gen an array, which maps edge-type-ids on edge-type names */
		//while writing the node type name array look for a type named "node"
		//this type is the root of all node types
		int root_edge_type = 0;
		if (n_edge_types > 0) {
			sb.append(
				"/* An array mapping a edge type id to the name of that edge type */\n" +
					"const char *fb_name_of_edge_type[fb_n_edge_types] = {\n" +
					"  \"" + getTypeName(false, 0) + "\"");
			if (getTypeName(false, 0).equals("Edge")) root_edge_type = 0;
			for (int et=1; et < n_edge_types; et++) {
				sb.append(",\n  \"" + getTypeName(false, et) + "\"");
				if (getTypeName(false, et).equals("Edge")) root_edge_type = et;
			}
			sb.append("\n};\n\n");
		}
		else {
			sb.append(
				"/* An array mapping a edge type id to the name of that edge type */\n" +
					"const char *fb_name_of_edge_type[0] = {};\n\n");

		}
		sb.append(
			"/* The root of the edge type hierarchie */\n" +
				"#define GR_DEF_EDGE_TYPE_Edge " + root_edge_type + "\n\n");




		/* gen an array, which maps a node-type-id to the number of attr the type has */
		if (n_node_types > 0) {
			sb.append(
				"/* An array mapping a node type id to the number of attributes that type has */\n" +
					"const int fb_n_attr_of_node_type[fb_n_node_types] = {\n");
			sb.append("  " + n_attr_of_node_type[0]);
			for (int nt=1; nt < n_node_types; nt++)
				sb.append("," + n_attr_of_node_type[nt]);
			sb.append("\n};\n\n");
		}
		else {
			sb.append(
				"/* An array mapping a node type id to the number of attributes that type has */\n" +
					"const int fb_n_attr_of_node_type[0] = {};\n\n");
		}

		/* gen an array, which maps a edge-type-id to the number of attr the type has */
		if (n_edge_types > 0) {
			sb.append(
				"/* An array mapping an edge type id to the number of attributes that type has */\n" +
					"const int fb_n_attr_of_edge_type[fb_n_edge_types] = {\n");
			sb.append("  " + n_attr_of_edge_type[0]);
			for (int et=1; et < n_edge_types; et++)
				sb.append("," + n_attr_of_edge_type[et]);
			sb.append("\n};\n\n");
		}
		else {
			sb.append(
				"/* An array mapping a node type id to the number of attributes that type has */\n" +
					"const int fb_n_attr_of_edge_type[0] = {};\n\n");
		}



		/* gen an array which maps node attribute ids to attribute descriptors */
		if (n_node_attrs > 0) {
			sb.append(
				"/* An array mapping node attribute ids to attribute descriptors */\n" +
					"const fb_attr_descr_t fb_node_attr_info[fb_n_node_attr_decls] = {\n");

			AttrTypeDescriptor at = node_attr_info[0];
			sb.append(
				"  { " + genAttrKindFromInt(at.kind) + ",(gr_id_t)" + at.attr_id + "," +
					"\"" + at.name + "\",(gr_id_t)" + at.decl_owner_type_id + "," +
					"(gr_id_t)" + at.enum_id +" }");
			for (int attr_id=1; attr_id < n_node_attrs; attr_id++) {
				at = node_attr_info[attr_id];
				sb.append(
					",\n  { " + genAttrKindFromInt(at.kind) + ",(gr_id_t)" + at.attr_id + "," +
						"\"" + at.name + "\",(gr_id_t)" + at.decl_owner_type_id + "," +
						"(gr_id_t)" + at.enum_id +" }");
			}
			sb.append("\n};\n\n");
		}
		else {
			sb.append(
				"/* An array mapping node attribute ids to attribute descriptors */\n" +
					"const fb_attr_descr_t fb_node_attr_info[0] = {};\n\n");
		}



		/* gen an array which maps edge attribute ids to attribute descriptors */
		if (n_edge_attrs > 0) {
			sb.append(
				"/* An array mapping edge attribute ids to attribute descriptors */\n" +
					"const fb_attr_descr_t fb_edge_attr_info[fb_n_edge_attr_decls] = {\n");

			AttrTypeDescriptor at = edge_attr_info[0];
			sb.append(
				"  { " + genAttrKindFromInt(at.kind) + ",(gr_id_t)" + at.attr_id + "," +
					"\"" + at.name + "\",(gr_id_t)" + at.decl_owner_type_id + "," +
					"(gr_id_t)" + at.enum_id +" }");
			for (int attr_id=1; attr_id < n_edge_attrs; attr_id++) {
				at =edge_attr_info[attr_id];
				sb.append(
					",\n  { " + genAttrKindFromInt(at.kind) + ",(gr_id_t)" + at.attr_id + "," +
						"\"" + at.name + "\",(gr_id_t)" + at.decl_owner_type_id + "," +
						"(gr_id_t)" + at.enum_id +" }");
			}
			sb.append("\n};\n\n");
		}
		else {
			sb.append(
				"/* An array mapping edge attribute ids to attribute descriptors */\n" +
					"const fb_attr_descr_t fb_edge_attr_info[0] = {};\n\n");
		}



		/* gen an array which implements the map
		 * node_type_id  x  attr_id  -->  attr_index
		 * where attr index is the position the attr has in the attr layout of the node type */
		if (n_node_attrs > 0) {
			sb.append(
				"/* An array mapping pairs (node_type_id, node_attr_id) to the index position\n" +
					" * the attribute has in the layout of the node type. A negative value indicates\n" +
					" * that the attr is NOT a member of a node type. */\n" +
					"const int fb_node_attr_index[fb_n_node_types][fb_n_node_attr_decls] = {\n");
			for (int nt=0; nt < n_node_types; nt++) {
				if (nt == 0) sb.append("  { ");
				else sb.append(",\n  { ");
				for (int attr = 0; attr < n_node_attrs; attr++) {
					if (attr == 0) sb.append(node_attr_index[nt][attr]);
					else sb.append("," + node_attr_index[nt][attr]);
				}
				sb.append(" }");
			}
			sb.append("\n};\n\n");
		}
		else
			sb.append(
				"/* An array mapping pairs (node_type_id, node_attr_id) to the index position\n" +
					" * the attribute has in the layout of the node type. A negative value indicates\n" +
					" * that the attr is NOT a member of a node type. */\n" +
					"const int fb_node_attr_index[0][0] = {};\n\n");



		/* gen an array which implements the map
		 * edge_type_id  x  attr_id  -->  attr_index
		 * where attr index is the position the attr has in the attr layout of the edge type */
		if (n_edge_attrs > 0) {
			sb.append(
				"/* An array mapping pairs (edge_type_id, edge_attr_id) to the index position\n" +
					" * the attribute has in the layout of the edge type. A negative value indicates\n" +
					" * that the attr is NOT a member of an edge type. */\n" +
					"const int fb_edge_attr_index[fb_n_edge_types][fb_n_edge_attr_decls] = {\n");
			for (int et=0; et < n_edge_types; et++) {
				if (et == 0) sb.append("  { ");
				else sb.append(",\n  { ");
				for (int attr = 0; attr < n_edge_attrs; attr++) {
					if (attr == 0) sb.append(edge_attr_index[et][attr]);
					else sb.append("," + edge_attr_index[et][attr]);
				}
				sb.append(" }");
			}
			sb.append("\n};\n\n");
		}
		else
			sb.append(
				"/* An array mapping pairs (edge_type_id, edge_attr_id) to the index position\n" +
					" * the attribute has in the layout of the edge type. A negative value indicates\n" +
					" * that the attr is NOT a member of an edge type. */\n" +
					"const int fb_edge_attr_index[0][0] = {};\n\n");



		/* Gen an array which maos enum type ids to enum descriptors.
		 Note that evert element of the array contains a pointer, each to another
		 array, so these arrays have to be generated first */
		if (n_enum_types > 0) {
			//gen of sequence of arrays of item descriptors
			sb.append(
				"/* Several arrays (one array for each enum type) listing\n" +
					"   the items of the associated enum type */\n");

			for (int enum_type_id = 0; enum_type_id < n_enum_types; enum_type_id++) {
				EnumDescriptor current_enum = enum_type_descriptors[enum_type_id];
				sb.append(
					"const fb_enum_item_descr_t item_descr_array_" + enum_type_id +
						"[" + current_enum.n_items + "] = {");
				boolean first = true;
				for (Iterator<EnumItem> item_it = current_enum.items.iterator(); item_it.hasNext(); ) {
					if (!first) sb.append(", ");
					first = false;
					EnumItem enum_item = item_it.next();
					sb.append(
						"\n  { (gr_int_t)" + ((Integer)enum_item.getValue().getValue()).intValue() +
							", \"" + enum_item.getIdent() + "\" }");
				}
				sb.append("\n};\n\n");

			}
			//actual gen of the array implementing the map
			//enum_type_id -->  enum_type_descriptor
			sb.append(
				"/* An array mapping enum type ids to enum type descriptors */\n" +
					"const fb_enum_descr_t fb_enum_type_info[fb_n_enum_types] = {\n");
			boolean first1 = true;
			for (int enum_type_id = 0; enum_type_id < n_enum_types; enum_type_id++) {
				if (!first1) sb.append(",\n");
				first1 = false;
				EnumDescriptor current_enum =
					enum_type_descriptors[enum_type_id];
				sb.append("  { (gr_id_t)" + current_enum.type_id + ", \"" +
							  current_enum.name + "\", " + current_enum.n_items +
							  ", item_descr_array_" + enum_type_id + " }");
			}
			sb.append("\n};\n\n");
		}
		else
			sb.append(
				"/* An array mapping enum type ids to enum type descriptors */\n" +
					"const fb_enum_descr_t fb_enum_type_info[0] = {};\n\n\n");
	}

	/*
	 *  gives a kind tag for a fb backend attr descriptor
	 */
	protected String genAttrKindFromInt(int kind) {
		switch (kind) {
			case AttrTypeDescriptor.INTEGER:
				return "fb_kind_prim_int";
			case AttrTypeDescriptor.BOOLEAN:
				return "fb_kind_prim_boolean";
			case AttrTypeDescriptor.STRING:
				return "fb_kind_prim_string";
			case AttrTypeDescriptor.ENUM:
				return "fb_kind_enum";
		}
		return "ERROR_invalid_kind";
	}

}
//	/*
//	 *  writes a character sequence to a new file
//	 */
//	protected void writeFile(String filename, CharSequence cs)
//	{
//		Util.writeFile(new File(path, filename), cs, error);
//	}



