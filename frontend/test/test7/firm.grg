/*
 * Project:     GRS
 * File name:   firm.grg
 * Purpose:     A specification of firm,
 *		as well as some optimizing graph replacements.
 * Author:      Rubino Geiss
 * Mowified by:
 * Created:     10.9.2003
 * Copyright:   (c) 2003 Universitaet Karlsruhe
 * Licence:     GPL
 */

unit Firm;

node class FIRM_node extends Node {
	generation: int;
}

edge class FIRM_edge extends Edge {
	generation: int;
}


/**********************************************
 * Modes                                      *
 **********************************************/

enum ENUM_sort {
	auxiliary, control_flow, memory, internal_boolean,
	int_number, float_number, reference, character
}
enum ENUM_arithmetic_kind {
	uninitialized, none, twos_complement, ones_complement,
	int_BCD, ieee754, float_BCD, max, unknown
}
enum ENUM_modecode {
	irm_BB, irm_X,   irm_F,   irm_D,  irm_E,  irm_Bs,
	irm_Bu, irm_Hs,  irm_Hu,  irm_Is, irm_Iu, irm_Ls,
	irm_Lu, irm_C,   irm_P,   irm_b,  irm_M,  irm_T,
	irm_U,  irm_ANY, irm_BAD, irm_max
}

node class Mode extends FIRM_node {
	name            : string;
	size		: int;
	align		: int;
	sort		: ENUM_sort;
	code		: ENUM_modecode;
	sign		: boolean;
	arithmetic	: ENUM_arithmetic_kind;
	shift		: int;
}


/**********************************************
 * Types                                      *
 **********************************************/

enum ENUM_state       { layout_undefined, layout_fixed }

/************* Type Nodes         *************/

node class Type extends FIRM_node {
	id    : int;
	name  : string;
	state : ENUM_state;
	size  : int;
}

node class Class extends Type { }
node class Method extends Type {
	n_params : int;		// number of calling paramters
	n_ress   : int;		// number of results
	variadic : boolean;	// if true, additional variadic parameters allowed
}
node class Struct extends Type { }
node class Union extends Type { }
node class Array extends Type {
	n_dimensions : int;
}
node class Enum extends Type { }
node class Pointer extends Type { }
node class Primitive extends Type { }

/************* Type Edges         *************/

edge class is_subtype_of extends FIRM_edge { }	// Class (Sub) -> Class (Super)
edge class member extends FIRM_edge { }		// Class, Struct, Union -> Entity
edge class parameter extends FIRM_edge {		// Method -> Type
	position : int;
}
edge class result extends FIRM_edge {		// Method -> Type
	position : int;
}
edge class element_type extends FIRM_edge { }	// Array -> Type
edge class element_ent extends FIRM_edge { }	// Array -> Entity
edge class lower extends FIRM_edge { }		// Array -> IR_node
edge class upper extends FIRM_edge { }		// Array -> IR_node
edge class named_Value extends FIRM_edge {	// Enum -> Tarval
	name : string;
}
edge class has_type extends FIRM_edge { }	// Call,FuncCall,SymConst,Pointer -> Type


/**********************************************
 * Tarval                                     *
 **********************************************/

node class Tarval extends FIRM_node {
	value : string;		//  is this aprobate
}

edge class has_mode extends FIRM_edge { } 	// Tarval, Pointer, Primitive -> Mode
edge class has_entity extends FIRM_edge { }	// Tarval -> Entity


/**********************************************
 * Entities                                   *
 **********************************************/

enum ENUM_allocation   { automatic, parameter, dynamic, static }
enum ENUM_visibility   { local, global, extern }
enum ENUM_variability  { uninitialized, initialized, partly_constant, constant }
enum ENUM_peculiarity  { description, inherited, existent }

/************* Entity Nodes       *************/

node class Entity extends FIRM_node {
	name        : string;		// the (source) name of the entity
	ld_name     : string;		// the linker name of the entity
	offset      : int;
	allocation  : ENUM_allocation;
	visibility  : ENUM_visibility;
	variability : ENUM_variability;
	peculiarity : ENUM_peculiarity;
	volatility  : boolean;
}

/************* Entity Edges       *************/

edge class overwrites extends FIRM_edge { }	// Entity -> Entity
edge class init_node extends FIRM_edge { }	// Entity -> Node (of Init)
edge class init_entity extends FIRM_edge { }	// Entity -> Entity (of Init)
edge class graph extends FIRM_edge { }		// Entity -> Method_IRG
edge class type extends FIRM_edge { }		// Entity -> Type


/**********************************************
 * Method IRG                                 *
 **********************************************/

/*
 * Firm IRG the IR graph of a method.
 * Pointing to Start and End nodes as well as its Entity
 */
node class Method_IRG {
	main_method : boolean;	// set, if this method is the main entry point
}
edge class meth_start extends FIRM_edge { }	// Method_IRG -> Start
edge class meth_end extends FIRM_edge   { }	// Method_IRG -> End
edge class frame_type extends FIRM_edge { }	// Method_IRG -> Type
edge class belong_to extends FIRM_edge  { }	// BB -> Method_IRG

node class IR_node extends FIRM_node {
	arity : int;
}

node class Arithmetic { }
node class Controlflow { }
node class Memory { }
node class Special { }

node class Unary { }
node class Binary { }
node class Nary { }


/**********************************************
 * IR Nodes                                   *
 **********************************************/

node class Block extends IR_node, Special { }
node class Start extends IR_node, Special { }
node class End extends IR_node, Special { }

node class Jmp extends IR_node, Controlflow { }
node class Cond extends IR_node { }
node class Return extends IR_node, Controlflow { }
node class Raise extends IR_node, Controlflow { }

node class Const extends IR_node {
	value : string;			// tarval coded as string
}

node class SymConst extends IR_node {
	kind    : int;
	ptrinfo : string;
}

node class Sel extends IR_node {}
node class InstOf extends IR_node {}
node class Call extends IR_node {}
node class FuncCall extends IR_node {}

node class Add extends IR_node, Arithmetic, Binary { }
node class Sub extends IR_node, Arithmetic, Binary { }
node class Minus extends IR_node, Arithmetic, Unary { }
node class Mul extends IR_node, Arithmetic, Binary { }
node class Quot extends IR_node, Arithmetic, Binary { }
node class DivMod extends IR_node {}
node class Div extends IR_node, Arithmetic, Binary { }
node class Mod extends IR_node, Arithmetic, Binary { }
node class Abs extends IR_node, Arithmetic, Binary { }
node class And extends IR_node, Arithmetic, Binary { }
node class Or extends IR_node, Arithmetic, Binary { }
node class Eor extends IR_node, Arithmetic, Binary { }
node class Not extends IR_node, Arithmetic, Unary { }
node class Cmp extends IR_node {}
node class Shl extends IR_node, Arithmetic, Binary { }
node class Shr extends IR_node, Arithmetic, Binary { }
node class Shrs extends IR_node, Arithmetic, Binary { }
node class Rot extends IR_node, Arithmetic, Binary { }
node class Conv extends IR_node {}
node class Cast extends IR_node {}
node class Phi extends IR_node {}

node class Load extends IR_node, Memory { }
node class Store extends IR_node, Memory { }

enum ENUM_alloc_where { stack_alloc, heap_alloc }

node class Alloc extends IR_node, Memory {
	where : ENUM_alloc_where;
}
node class Free extends IR_node, Memory { }
node class Sync extends IR_node, Memory { }

node class Proj extends IR_node {
	proj : int;
}

node class Tuple extends IR_node {}
node class Id extends IR_node {}
node class Bad extends IR_node {}
node class Confirm extends IR_node {}
node class Unknown extends IR_node {}
node class Filter extends IR_node {}
node class Break extends IR_node, Controlflow { }
node class CallBegin extends IR_node {}
node class EndReg extends IR_node {}
node class EndExcept extends IR_node, Controlflow { }

/**********************************************
 * IR Intrinsic Nodes                         *
 **********************************************/
node class Intrinsic extends IR_node {}

node class IntrinsicGP  extends Intrinsic {}	// a intrinsic with gp registers
node class IntrinsicFP  extends Intrinsic {}	// a intrinsic with fp registers
node class IntrinsicMMX extends Intrinsic {}	// a intrinsic with mmx registers
node class IntrinsicSSE extends Intrinsic {}	// a intrinsic with sse registers

node class max extends IntrinsicGP {}	// a max instruction
node class min extends IntrinsicGP {}	// a min instruction

node class CMOV extends IntrinsicGP {}	// a conditional move instruction


/************* IR Edges         *************/

edge class flow extends FIRM_edge { // IR_node -> IR_node
	position : int;
}

edge class df extends flow { } 	  // IR_node -> IR_node, data flow
edge class mem extends df { } 	  // IR_node -> IR_node, memory
edge class cf extends flow { }    // IR_node -> Block, control flow
	
/**********************************************
 * Extensions                                 *
 **********************************************/

node class Vector extends IR_node {}

node class V2 extends Vector {}
node class V4 extends Vector {}

node class pi {}

node class V2pi_1 extends V2, pi{}
node class V2pi_2 extends V2, pi{}

node class V4pi_1 extends V4, pi{}
node class V4pi_2 extends V4, pi{}
node class V4pi_3 extends V4, pi{}
node class V4pi_4 extends V4, pi{}

node class V2Load extends V2 {}
node class V2Store extends V2 {}

node class V2Sub extends V2 {}

/**********************************************
 * G2s extensions                             *
 **********************************************/
node class G2s {}
node class G2s_param extends G2s {}
node class G2s_r128_int_4 extends G2s {}

//G2s_complex will become the complex command
node class G2s_complex extends G2s {}

node class G2s_in extends G2s {}
node class G2s_in_v0 extends G2s_in {}
node class G2s_in_v1 extends G2s_in {}
node class G2s_in_v2 extends G2s_in {}
node class G2s_in_v3 extends G2s_in {}

edge class g2s {}
edge class g2s_param_type extends g2s {}


node class G2s_marker extends G2s {}

node class Meth_entity extends Entity {}

node class Visual_helper {}

node class G2s_forbidden extends Start, End, Return, Type, Entity, Method_IRG {}
node class G2s_allowed extends FIRM_node {}
edge class g2s_forbidden {}
edge class g2s_allowed extends FIRM_edge {}

node class G2s_parameter extends G2s {}
node class G2s_parameter0 extends G2s_parameter {}
node class G2s_parameter1 extends G2s_parameter {}
node class G2s_parameter2 extends G2s_parameter {}

/**********************************************
 **********************************************
 * Graph Rewriting Rules                      *
 **********************************************
 **********************************************/


rule params_init_param1 {
	pattern {
		node entity 			: Entity;
		node meth				: Method;
		node meth_param_type	: Type;
		node meth_irg 			: Method_IRG;
		node start_block 		: Block;
		node start				: Start;
		node args_proj			: Proj;
		node param_proj 		: Proj;
		node args_proj_mode 	: Mode;

		entity		-:type-> meth;
		meth		-param:parameter-> meth_param_type;
				
		entity		-:graph-> meth_irg;
		start_block	-:belong_to-> meth_irg;
		start		-:cf-> start_block;
		args_proj	-:df-> start;
		param_proj	-:df-> args_proj;
		args_proj	-:has_mode-> args_proj_mode;
	}
	cond {
		param_proj.proj == 1;
		param.position == 1;
		args_proj_mode.name == "T";
	}

	replace {
		//copy
		entity		-:type-> meth;
		meth		-param-> meth_param_type;
				
		entity		-:graph-> meth_irg;
		start_block	-:belong_to-> meth_irg;
		start		-:cf-> start_block;
		args_proj	-:df-> start;
		param_proj	-:df-> args_proj;
		args_proj	-:has_mode-> args_proj_mode;

		meth_param_type	-:g2s_param_type-> param_proj;
	}
}
