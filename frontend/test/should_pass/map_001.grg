using map_model_001;

rule addToMap {
	a:A;
	
	modify {
		eval {
			a.niceMap = a.niceMap.put(5, "yeah");
		}
	}
}

test containedInMap {
	a:A;
	
	if { 5 in a.niceMap; }
}

rule copyMap {
	a:A;
	
	modify {
		b:A;
		eval {
			b.niceMap = b.niceMap.put(0, a.niceMap[0]);
		}
	}
}

rule mapIndexedMap {
	a:A;
	if { a.shiceMap[a.spiceMap["blubb"]] != null; }
	
	modify {
		b:A;
		eval {
			a.spiceMap = a.spiceMap.put(b.niceMap[0], 3.141f);
		}
	}
}

rule removeFromMap {
	a:A;
	
	modify {
		eval {
			a.niceMap = a.niceMap.remove(0);
		}
	}
}

rule emitFromMap {
	a:A;
	if { 5 in a.niceMap; }
	
	modify {
		emit("entry for \"5\" = " + a.niceMap[5] + ", mapsize = " + a.niceMap.size());
	}
}

rule mapVarContains(var m:map<string, int>) {
	if { "yeah" in m; }
	
	modify {
		emit("entry for \"yeah\" = " + m["yeah"] + ", mapsize = " + m.size());
	}
}

// This clones the maps
rule assignMapToMap {
	a:A -e:E-> a; 
		
	modify {
		eval {
			a.niceMap = e.niceMap;
			e.spiceMap = a.spiceMap;
			e.niceMap = a.niceMap;
		}
	}
}
