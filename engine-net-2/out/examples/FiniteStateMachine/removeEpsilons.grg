using StateMachine;

rule checkStartState {
    pattern {
        x:StartState;
        negative {
            x;
            y:StartState;
        }
    }
    modify {}
}

rule checkDoublettes {
    pattern {
        x:State -e:Transition-> y:State;
        hom(x,y);
        x -doublette:Transition-> y;
        if {typeof(doublette) == typeof(e);}
        if { ((typeof(e) == EpsilonTransition) || (e.Trigger == doublette.Trigger)); }
    }
    modify {}
}

rule forwardTransition {
    pattern {
        x:State -:EpsilonTransition-> y:State -e:Transition-> z:State;
        hom(x,y,z);
        negative {
            x -exists:Transition-> z;
            if {typeof(exists) == typeof(e);}
            if { ((typeof(e) == EpsilonTransition) || (e.Trigger == exists.Trigger)); }
        }
    }
    modify {
        x -forward:typeof(e)-> z;
        eval {forward.Trigger = e.Trigger;}
    }    
}

rule addStartFinalState {
    pattern {
        x:StartState -:EpsilonTransition-> :FinalState;
    }
    modify {
        y:StartFinalState<x>;        
    }
}

rule addFinalState {
    pattern {
        x:State -:EpsilonTransition-> :FinalState;
        if {typeof(x) < SpecialState;}
    }
    modify {
        y:FinalState<x>;
    }
}

rule removeEpsilonTransition {
    pattern {
        -:EpsilonTransition->;
    }
    replace {}   
}
