using JavaProgramGraphsMetamodel;

#include "JavaProgramGraphsGxlDumper.gri"

/////////////////////////////////////////////////////////////////////////////////////////////////////
// encapsulateField
/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////
// test preconditions

test variableInClass(c:Class, v:Variabel) : (boolean)
{
	c <-:belongsTo- v;
	v -:ttype-> :Class; // ensure v is typed with a class, needed for setter method insertion
	return(v.isStatic);
}

test methodExists(c:Class, var name:string) : (Operation)
{
	c <-:belongsTo- mb:MethodBody;
	mb <-:binding- op:Operation;
	if { op.name==name; }
	return(op);
}

test sameStaticness(v:Variabel, op:Operation)
{
	if { v.isStatic==op.isStatic; }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// insert accessor operations and change visibility of variable

rule insertMethodGetter(c:Class, v:Variabel, var name:string, var isStatic:boolean) : (Operation)
{
	// getter: return von access variable
	modify {
		c <-:belongsTo- mb:MethodBody;
		mb <-:binding- op:Operation;
		eval { op.name = name; 
			op.visibility = "public"; 
			op.isAbstract = false; 
			op.isStatic = isStatic; 
			op.isFinal = false; }
			
		mb <-:belongsTo- :Block -:expression-> :Return -:expression-> :Access -:link-> v;
		return(op);
	}
}

rule insertMethodSetter(c:Class, v:Variabel, var name:string, var isStatic:boolean) : (Operation)
{
	v -:ttype-> type:Class;
	
	// setter: update von variable mit parameter
	modify {
		c <-:belongsTo- mb:MethodBody;
		mb <-:binding- op:Operation;
		eval { op.name = name; 
			op.visibility = "public"; 
			op.isAbstract = false; 
			op.isStatic = isStatic; 
			op.isFinal = false; }
			
		op -:parameter-> p:Parameter -:ttype-> type;
		mb <-:belongsTo- :Block -:expression-> u:Update;
		u -:link-> v;
		u -:expression-> :Access -:link-> p;
		return(op);
	}
}

rule changeVisibility(v:Variabel)
{
	modify {
		eval { v.visibility = "private"; }
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// updateReferences only if not in same class

rule adaptAccess(c:Class, v:Variabel, getter:Operation)
{	
	a:Access -l:link-> v;
	
	negative {
		:InClass(a, c);
	}

	modify {
		call:Call<a> -:link-> getter;
		delete(l);
	}		
}

rule adaptUpdate(c:Class, v:Variabel, setter:Operation)
{	
	u:Update -l:link-> v;
	u -e:expression-> exp:Expression;

	negative {
		:InClass(u, c);
	}
	
	modify {
		call:Call<u> -:link-> setter;
		call -:actualParameter-> exp;
		delete(l);
		delete(e);
	}
}

pattern InClass(e:Expression, c:Class)
{
	alternative {
		Previous {
			prev:Expression\Block -:expression-> e;
			:InClass(prev, c);	
		}
		End {
			prev:Block -:expression-> e;
			mb:MethodBody <-:belongsTo- b:Block;
			c <-:belongsTo- mb;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// updateReferences use accessors always

rule adaptAccessUseAccessorsAlways(c:Class, v:Variabel, getter:Operation)
{	
	a:Access -l:link-> v;
	
	modify {
		call:Call<a> -:link-> getter;
		delete(l);
	}		
}

rule adaptUpdateUseAccessorsAlways(c:Class, v:Variabel, setter:Operation)
{	
	u:Update -l:link-> v;
	u -e:expression-> exp:Expression;

	modify {
		call:Call<u> -:link-> setter;
		call -:actualParameter-> exp;
		delete(l);
		delete(e);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// spanning tree of java program graphs (not part of contest, just for fun)
/////////////////////////////////////////////////////////////////////////////////////////////////////

rule deleteSpanningTree
{
	mrp:MultipleRootPackages();
	
	replace {
	}
}

pattern MultipleRootPackages
{
	alternative
	{
		OneAndAgain {
			p:Package;
			negative {
				<-:belongsTo- p; 
			}
			:MultipleRootPackages();
			:MultipleContainedPackagesOrClasses(p);
		}
		NoRootPackageLeft {
			negative {
				p:Package;
				negative {
					<-:belongsTo- p; 
				}
			}
		}
	}
}

pattern MultipleContainedPackagesOrClasses(p:Package)
{
	alternative
	{
		OneAndAgain {
			:ContainedPackageOrClass(p);
			:MultipleContainedPackagesOrClasses(p);
		}
		NoPackageOrClassLeft {
			negative {
				p <-:belongsTo-;
			}
		}
	}
}

pattern ContainedPackageOrClass(p:Package)
{
	alternative 
	{
		Package {
			p <-:belongsTo- sub:Package;
			:MultipleContainedPackagesOrClasses(sub);	
		}
		Class {
			p <-:belongsTo- c:Class;
			:MultipleMethodBodies(c);
			:MultipleVariables(c);
		}
	}
}

pattern MultipleVariables(c:Class)
{
	alternative 
	{
		OneAndAgain {
			c <-:belongsTo- :Variabel;
			:MultipleVariables(c);	
		}
		NoVariableLeft {
			negative {
				c <-:belongsTo- :Variabel;
			}
		}
	}
}

pattern MultipleMethodBodies(c:Class)
{
	alternative 
	{
		OneAndAgain {
			:MethodBodyAndImplementation(c);
			:MultipleMethodBodies(c);	
		}
		NoMethodBodyLeft {
			negative {
				c <-:belongsTo- mb:MethodBody;
			}
		}
	}
}

pattern MethodBodyAndImplementation(c:Class)
{
	c <-:belongsTo- mb:MethodBody;
	
	alternative {
		BoundOperation {
			mb <-:binding- op:Operation;
			:MultipleParameters(op);
		}
		Empty {
			// operation can get matched only once, and it might happen that it was already matched
		}
	}
	
	alternative {
		Implemented {
			mb <-:belongsTo- b:Block;
			:MultipleExpressions(b);
		}
		Unimplemented {
			negative {
				mb <-:belongsTo- b:Block;
			}
		}
	}
}

pattern MultipleParameters(op:Operation)
{
	alternative 
	{
		OneAndAgain {
			op -:parameter-> :Parameter;
			:MultipleParameters(op);	
		}
		NoParameterLeft {
			negative {
				op -:parameter->;
			}
		}
	}
}

pattern MultipleExpressions(b:Block)
{
	alternative {
		NoExpressionLeft {
			negative {
				b -:expression-> :Expression;
			}
		}
		OneAndAgain {
			:ExpressionChain(b);	
			:MultipleExpressions(b);	
		}
	}
}

pattern ExpressionChain(e:Expression)
{
	alternative {
		ExprAndAgain {
			e -:expression-> next:Expression\Call;
			:ExpressionChain(next);	
		}
		CallAndAgain {
			e -:expression-> call:Call;
			:ExpressionChain(call);
			:MultipleActualParameters(call);
		}
		End {
			negative {
				e -:expression->;
			}
		}
	}
}

pattern MultipleActualParameters(c:Call)
{
	alternative {
		ExprAndAgain {
			c -:actualParameter-> next:Expression\Call;
			:ExpressionChain(next);	
			:MultipleActualParameters(c);
		}
		CallAndAgain {
			c -:actualParameter-> call:Call;
			:ExpressionChain(call);
			:MultipleActualParameters(call);
			:MultipleActualParameters(c);
		}
		NoParameterLeft {
			negative {
				c -:actualParameter->;
			}
		}
	}
}

pattern MultipleExtendingClasses(c:Class)
{
	alternative
	{
		OneAndAgain {
			:ExtendingClass(c);
			:MultipleExtendingClasses(c);
		}
		NoClassLeft {
			negative {
				c <-:extendss-;
			}
		}
	}
}

pattern ExtendingClass(c:Class)
{
	c <-:extendss- sub:Class;
	:MultipleExtendingClasses(sub);
}
