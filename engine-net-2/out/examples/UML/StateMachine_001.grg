using L3;

rule init {
  pattern { }
  replace {
    // the machine and its region
    sm:StateMachine -:region-> reg:Region -:stateMachine-> sm;

    qs:Pseudostate;
    qf:FinalState;
    q1:State;
    q2:State;

    // embed states to region
    reg -:subvertex-> qs -:container-> reg;
    reg -:subvertex-> qf -:container-> reg;
    reg -:subvertex-> q1 -:container-> reg;
    reg -:subvertex-> q2 -:container-> reg;

    // make initial state
    qs -:kind-> qs_kind:PseudostateKind_Value;
    eval { 
      qs_kind.value = PseudostateKind::entryPoint;
    }

    // create the transitions in region
    t1:Transition -:container-> reg -:transition-> t1;
    t2:Transition -:container-> reg -:transition-> t2;
    t3:Transition -:container-> reg -:transition-> t3;
    t4:Transition -:container-> reg -:transition-> t4;
    t5:Transition -:container-> reg -:transition-> t5;
    t6:Transition -:container-> reg -:transition-> t6;

    // the triggers
    t1 -:trigger-> :Trigger -:event-> :CallEvent;
    t2 -:trigger-> :Trigger -:event-> :CallEvent;
    t3 -:trigger-> :Trigger -:event-> :CallEvent;

    // the connections
    qs -:source-> t1 -:target-> q1 
       -:source-> t2 -:target-> q2
       -:source-> t3 -:target-> qf;

    qs -:source-> t4 -:target-> q2;
    q1 -:source-> t5 -:target-> qf;
    qs -:source-> t6 -:target-> qf;
  }
}
