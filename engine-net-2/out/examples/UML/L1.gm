abstract edge class association;
abstract edge class attribute;

//An integer is a primitive type representing integer values.
node class Integer {
	
	value : int;

}

//A Boolean type is used for logical expression, consisting of the predefined values true and false.
node class Boolean {
	
	value : boolean;

}

//A string is a sequence of characters in some suitable character set used to display information about the model. Character sets may include non-Roman alphabets and characters.
node class String {
	
	value : string;

}

//An unlimited natural is a primitive type representing unlimited natural values.
node class UnlimitedNatural {
	
	value : int;

}

//AggregationKind is an enumeration type that specifies the literals for defining the kind of aggregation of a property.
enum AggregationKind {
	
	//Indicates that the property has no aggregation.
	none, 
	//Indicates that the property has a shared aggregation.
	shared, 
	//Indicates that the property is aggregated compositely, i.e., the composite object has responsibility for the existence and storage of the composed objects (parts).
	composite
	
}

node class AggregationKind_Value {
	
	value : AggregationKind;
	
}

//Parameter direction kind is an enumeration type that defines literals used to specify direction of parameters.
enum ParameterDirectionKind {
	
	//Indicates that parameter values are passed into the behavioral element by the caller.
	in, 
	//Indicates that parameter values are passed into a behavioral element by the caller and then back out to the caller from the behavioral element.
	inout, 
	//Indicates that parameter values are passed from a behavioral element out to the caller.
	out, 
	//Indicates that parameter values are passed as return values from a behavioral element back to the caller.
	return_
	
}

node class ParameterDirectionKind_Value {
	
	value : ParameterDirectionKind;
	
}

//VisibilityKind is an enumeration type that defines literals to determine the visibility of elements in a model.
enum VisibilityKind {
	
	//A public element is visible to all elements that can access the contents of the namespace that owns it.
	public, 
	//A private element is only visible inside the namespace that owns it.
	private, 
	//A protected element is visible to elements that have a generalization relationship to the namespace that owns it.
	protected, 
	//A package element is owned by a namespace that is not a package, and is visible to elements that are in the same package as its owning namespace. Only named elements that are not owned by packages can be marked as having package visibility. Any element marked as having package visibility is visible to all elements within the nearest enclosing package (given that other owning elements have proper visibility). Outside the nearest enclosing package, an element marked as having package visibility is not visible.
	package
	
}

node class VisibilityKind_Value {
	
	value : VisibilityKind;
	
}

//This is an enumerated type that identifies the type of message.
enum MessageKind {
	
	//sendEvent and receiveEvent are present
	complete, 
	//sendEvent present and receiveEvent absent
	lost, 
	//sendEvent absent and receiveEvent present
	found, 
	//sendEvent and receiveEvent absent (should not appear)
	unknown
	
}

node class MessageKind_Value {
	
	value : MessageKind;
	
}

//This is an enumerated type that identifies the type of communication action that was used to generate the message.
enum MessageSort {
	
	//The message was generated by a synchronous call to an operation.
	synchCall, 
	//The message was generated by an asynchronous call to an operation; i.e., a CallAction with isSynchronous = false.
	asynchCall, 
	//The message was generated by an asynchronous send action.
	asynchSignal, 
	//The message designating the creation of another lifeline object.
	createMessage, 
	//The message designating the termination of another lifeline.
	deleteMessage, 
	//The message is a reply message to an operation call.
	reply
	
}

node class MessageSort_Value {
	
	value : MessageSort;
	
}

//CallConcurrencyKind is an enumeration type.
enum CallConcurrencyKind {
	
	//No concurrency management mechanism is associated with the operation and, therefore, concurrency conflicts may occur. Instances that invoke a behavioral feature need to coordinate so that only one invocation to a target on any behavioral feature occurs at once.
	sequential, 
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance, but only one is allowed to commence. The others are blocked until the performance of the first behavioral feature is complete. It is the responsibility of the system designer to ensure that deadlocks do not occur due to simultaneous blocks.
	guarded, 
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance and all of them may proceed concurrently.
	concurrent
	
}

node class CallConcurrencyKind_Value {
	
	value : CallConcurrencyKind;
	
}

//An element is a constituent of a model. As such, it has the capability of owning other elements.
abstract node class Element;
edge class Element_ownedElement extends association
	 connect Element[*] -> Element[0:*];
edge class Element_owner extends association
	 connect Element[*] -> Element[0:1];
edge class Element_ownedComment extends association
	 connect Element[*] -> Comment[0:*];

//A comment is a textual annotation that can be attached to a set of elements.
node class Comment extends Element;
edge class Comment_body extends attribute
	 connect Comment[*] -> String[0:1];
edge class Comment_annotatedElement extends association
	 connect Comment[*] -> Element[0:*];

//A directed relationship represents a relationship between a collection of source model elements and a collection of target model elements.
abstract node class DirectedRelationship extends Relationship;
edge class DirectedRelationship_source extends association
	 connect DirectedRelationship[*] -> Element[1:*];
edge class DirectedRelationship_target extends association
	 connect DirectedRelationship[*] -> Element[1:*];

//A literal specification identifies a literal constant being modeled.
abstract node class LiteralSpecification extends ValueSpecification;

//A literal integer is a specification of an integer value.
node class LiteralInteger extends LiteralSpecification {
	
	value : int = 0;
	
}

//A literal string is a specification of a string value.
node class LiteralString extends LiteralSpecification;
edge class LiteralString_value extends attribute
	 connect LiteralString[*] -> String[0:1];

//A literal Boolean is a specification of a Boolean value.
node class LiteralBoolean extends LiteralSpecification {
	
	value : boolean = false;
	
}

//A literal null specifies the lack of a value.
node class LiteralNull extends LiteralSpecification;

//A constraint is a condition or restriction expressed in natural language text or in a machine readable language for the purpose of declaring some of the semantics of an element.
node class Constraint extends PackageableElement;
edge class Constraint_constrainedElement extends association
	 connect Constraint[*] -> Element[0:*];
edge class Constraint_specification extends association
	 connect Constraint[*] -> ValueSpecification[1:1];
edge class Constraint_context extends association
	 connect Constraint[*] -> Namespace[0:1];

//An element import identifies an element in another package, and allows the element to be referenced using its name without a qualifier.
node class ElementImport extends DirectedRelationship;
edge class ElementImport_alias extends attribute
	 connect ElementImport[*] -> String[0:1];
edge class ElementImport_importedElement extends association
	 connect ElementImport[*] -> PackageableElement[1:1];
edge class ElementImport_importingNamespace extends association
	 connect ElementImport[*] -> Namespace[1:1];

//A typed element is a kind of named element that represents an element with a type.
abstract node class TypedElement extends NamedElement;
edge class TypedElement_type extends association
	 connect TypedElement[*] -> Type[0:1];

//A feature declares a behavioral or structural characteristic of instances of classifiers.
abstract node class Feature extends RedefinableElement {
	
	isStatic : boolean = false;
	
}
edge class Feature_featuringClassifier extends association
	 connect Feature[*] -> Classifier[0:*];

//A redefinable element is an element that, when defined in the context of a classifier, can be redefined more specifically or differently in the context of another classifier that specializes (directly or indirectly) the context classifier.
abstract node class RedefinableElement extends NamedElement {
	
	isLeaf : boolean = false;
	
}
edge class RedefinableElement_redefinedElement extends association
	 connect RedefinableElement[*] -> RedefinableElement[0:*];
edge class RedefinableElement_redefinitionContext extends association
	 connect RedefinableElement[*] -> Classifier[0:*];

//A generalization is a taxonomic relationship between a more general classifier and a more specific classifier. Each instance of the specific classifier is also an indirect instance of the general classifier. Thus, the specific classifier inherits the features of the more general classifier.
node class Generalization extends DirectedRelationship;
edge class Generalization_isSubstitutable extends attribute
	 connect Generalization[*] -> Boolean[0:1];
edge class Generalization_specific extends association
	 connect Generalization[*] -> Classifier[1:1];
edge class Generalization_general extends association
	 connect Generalization[*] -> Classifier[1:1];

//A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral feature.
node class Parameter extends TypedElement, MultiplicityElement;
edge class Parameter_default extends attribute
	 connect Parameter[*] -> String[0:1];
edge class Parameter_defaultValue extends association
	 connect Parameter[*] -> ValueSpecification[0:1];
edge class Parameter_operation extends association
	 connect Parameter[*] -> Operation[0:1];

//A structural feature is a typed feature of a classifier that specifies the structure of instances of the classifier.
abstract node class StructuralFeature extends Feature, TypedElement, MultiplicityElement {
	
	isReadOnly : boolean = false;
	
}

//An instance specification is a model element that represents an instance in a modeled system.
node class InstanceSpecification extends PackageableElement;
edge class InstanceSpecification_classifier extends association
	 connect InstanceSpecification[*] -> Classifier[0:*];
edge class InstanceSpecification_slot extends association
	 connect InstanceSpecification[*] -> Slot[0:*];
edge class InstanceSpecification_specification extends association
	 connect InstanceSpecification[*] -> ValueSpecification[0:1];

//A slot specifies that an entity modeled by an instance specification has a value or values for a specific structural feature.
node class Slot extends Element;
edge class Slot_owningInstance extends association
	 connect Slot[*] -> InstanceSpecification[1:1];
edge class Slot_definingFeature extends association
	 connect Slot[*] -> StructuralFeature[1:1];
edge class Slot_value extends association
	 connect Slot[*] -> ValueSpecification[0:*];

//A package is used to group elements, and provides a namespace for the grouped elements.
node class Package extends PackageableElement, Namespace;
edge class Package_packageMerge extends association
	 connect Package[*] -> PackageMerge[0:*];
edge class Package_packagedElement extends association
	 connect Package[*] -> PackageableElement[0:*];
edge class Package_ownedType extends association
	 connect Package[*] -> Type[0:*];
edge class Package_nestedPackage extends association
	 connect Package[*] -> Package[0:*];
edge class Package_nestingPackage extends association
	 connect Package[*] -> Package[0:1];

//A package import is a relationship that allows the use of unqualified names to refer to package members from other namespaces.
node class PackageImport extends DirectedRelationship;
edge class PackageImport_importingNamespace extends association
	 connect PackageImport[*] -> Namespace[1:1];
edge class PackageImport_importedPackage extends association
	 connect PackageImport[*] -> Package[1:1];

//A data type is a type whose instances are identified only by their value. A data type may contain attributes to support the modeling of structured data types.
node class DataType extends Classifier;
edge class DataType_ownedAttribute extends association
	 connect DataType[*] -> Property[0:*];
edge class DataType_ownedOperation extends association
	 connect DataType[*] -> Operation[0:*];

//An enumeration is a data type whose values are enumerated in the model as enumeration literals.
node class Enumeration extends DataType;
edge class Enumeration_ownedLiteral extends association
	 connect Enumeration[*] -> EnumerationLiteral[0:*];

//An enumeration literal is a user-defined data value for an enumeration.
node class EnumerationLiteral extends InstanceSpecification;
edge class EnumerationLiteral_enumeration extends association
	 connect EnumerationLiteral[*] -> Enumeration[0:1];

//A primitive type defines a predefined data type, without any relevant substructure (i.e., it has no parts in the context of UML). A primitive datatype may have an algebra and operations defined outside of UML, for example, mathematically.
node class PrimitiveType extends DataType;

//An association describes a set of tuples whose values refer to typed instances. An instance of an association is called a link.
node class Association extends Relationship, Classifier {
	
	isDerived : boolean = false;
	
}
edge class Association_ownedEnd extends association
	 connect Association[*] -> Property[0:*];
edge class Association_endType extends association
	 connect Association[*] -> Type[1:*];
edge class Association_memberEnd extends association
	 connect Association[*] -> Property[2:*];
edge class Association_navigableOwnedEnd extends association
	 connect Association[*] -> Property[0:*];

//A value specification is the specification of a (possibly empty) set of instances, including both objects and data values.
abstract node class ValueSpecification extends TypedElement, PackageableElement;

//Relationship is an abstract concept that specifies some kind of relationship between elements.
abstract node class Relationship extends Element;
edge class Relationship_relatedElement extends association
	 connect Relationship[*] -> Element[1:*];

//A package merge defines how the contents of one package are extended by the contents of another package.
node class PackageMerge extends DirectedRelationship;
edge class PackageMerge_receivingPackage extends association
	 connect PackageMerge[*] -> Package[1:1];
edge class PackageMerge_mergedPackage extends association
	 connect PackageMerge[*] -> Package[1:1];

//An instance value is a value specification that identifies an instance.
node class InstanceValue extends ValueSpecification;
edge class InstanceValue_instance extends association
	 connect InstanceValue[*] -> InstanceSpecification[1:1];

//A literal unlimited natural is a specification of an unlimited natural number.
node class LiteralUnlimitedNatural extends LiteralSpecification {
	
	value : int = 0;
	
}

//A type is a named element that is used as the type for a typed element. A type can be contained in a package.
abstract node class Type extends PackageableElement;
edge class Type_package extends association
	 connect Type[*] -> Package[0:1];

//An expression is a structured tree of symbols that denotes a (possibly empty) set of values when evaluated in a context.
node class Expression extends ValueSpecification;
edge class Expression_symbol extends attribute
	 connect Expression[*] -> String[0:1];
edge class Expression_operand extends association
	 connect Expression[*] -> ValueSpecification[0:*];

//Behavior is a specification of how its context classifier changes state over time. This specification may be either a definition of possible behavior execution or emergent behavior, or a selective illustration of an interesting subset of possible executions. The latter form is typically used for capturing examples, such as a trace of a particular execution.
abstract node class Behavior extends Class {
	
	isReentrant : boolean = false;
	
}
edge class Behavior_redefinedBehavior extends association
	 connect Behavior[*] -> Behavior[0:*];
edge class Behavior_specification extends association
	 connect Behavior[*] -> BehavioralFeature[0:1];
edge class Behavior_ownedParameter extends association
	 connect Behavior[*] -> Parameter[0:*];
edge class Behavior_context extends association
	 connect Behavior[*] -> BehavioredClassifier[0:1];
edge class Behavior_precondition extends association
	 connect Behavior[*] -> Constraint[0:*];
edge class Behavior_postcondition extends association
	 connect Behavior[*] -> Constraint[0:*];

//An opaque expression is an uninterpreted textual statement that denotes a (possibly empty) set of values when evaluated in a context.
node class OpaqueExpression extends ValueSpecification;
edge class OpaqueExpression_body extends attribute
	 connect OpaqueExpression[*] -> String[0:*];
edge class OpaqueExpression_language extends attribute
	 connect OpaqueExpression[*] -> String[0:*];
edge class OpaqueExpression_result extends association
	 connect OpaqueExpression[*] -> Parameter[0:1];
edge class OpaqueExpression_behavior extends association
	 connect OpaqueExpression[*] -> Behavior[0:1];

//An behavior with implementation-specific semantics.
node class OpaqueBehavior extends Behavior;
edge class OpaqueBehavior_body extends attribute
	 connect OpaqueBehavior[*] -> String[0:*];
edge class OpaqueBehavior_language extends attribute
	 connect OpaqueBehavior[*] -> String[0:*];

//A function behavior is an opaque behavior that does not access or modify any objects or other external data.
node class FunctionBehavior extends OpaqueBehavior;

//An action with implementation-specific semantics.
node class OpaqueAction extends Action;
edge class OpaqueAction_body extends attribute
	 connect OpaqueAction[*] -> String[0:*];
edge class OpaqueAction_language extends attribute
	 connect OpaqueAction[*] -> String[0:*];
edge class OpaqueAction_inputValue extends association
	 connect OpaqueAction[*] -> InputPin[0:*];
edge class OpaqueAction_outputValue extends association
	 connect OpaqueAction[*] -> OutputPin[0:*];

//An output pin is a pin that holds output values produced by an action.
node class OutputPin extends Pin;

//An input pin is a pin that holds input values to be consumed by an action.
node class InputPin extends Pin;

//InvocationAction is an abstract class for the various actions that invoke behavior.
abstract node class InvocationAction extends Action;
edge class InvocationAction_argument extends association
	 connect InvocationAction[*] -> InputPin[0:*];

//CallAction is an abstract class for actions that invoke behavior and receive return values.
abstract node class CallAction extends InvocationAction {
	
	isSynchronous : boolean = true;
	
}
edge class CallAction_result extends association
	 connect CallAction[*] -> OutputPin[0:*];

//A send signal action is an action that creates a signal instance from its inputs, and transmits it to the target object, where it may cause the firing of a state machine transition or the execution of an activity. The argument values are available to the execution of associated behaviors. The requestor continues execution immediately. Any reply message is ignored and is not transmitted to the requestor. If the input is already a signal instance, use a send object action.
node class SendSignalAction extends InvocationAction;
edge class SendSignalAction_target extends association
	 connect SendSignalAction[*] -> InputPin[1:1];
edge class SendSignalAction_signal extends association
	 connect SendSignalAction[*] -> Signal[1:1];

//A call operation action is an action that transmits an operation call request to the target object, where it may cause the invocation of associated behavior. The argument values of the action are available to the execution of the invoked behavior. If the action is marked synchronous, the execution of the call operation action waits until the execution of the invoked behavior completes and a reply transmission is returned to the caller; otherwise execution of the action is complete when the invocation of the operation is established and the execution of the invoked operation proceeds concurrently with the execution of the calling behavior. Any values returned as part of the reply transmission are put on the result output pins of the call operation action. Upon receipt of the reply transmission, execution of the call operation action is complete.
node class CallOperationAction extends CallAction;
edge class CallOperationAction_operation extends association
	 connect CallOperationAction[*] -> Operation[1:1];
edge class CallOperationAction_target extends association
	 connect CallOperationAction[*] -> InputPin[1:1];

//A call behavior action is a call action that invokes a behavior directly rather than invoking a behavioral feature that, in turn, results in the invocation of that behavior. The argument values of the action are available to the execution of the invoked behavior. For synchronous calls the execution of the call behavior action waits until the execution of the invoked behavior completes and a result is returned on its output pin. The action completes immediately without a result, if the call is asynchronous. In particular, the invoked behavior may be an activity.
node class CallBehaviorAction extends CallAction;
edge class CallBehaviorAction_behavior extends association
	 connect CallBehaviorAction[*] -> Behavior[1:1];

//A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending with a (possibly infinite) upper bound. A multiplicity element embeds this information to specify the allowable cardinalities for an instantiation of this element.
abstract node class MultiplicityElement extends Element;
edge class MultiplicityElement_upper extends attribute
	 connect MultiplicityElement[*] -> UnlimitedNatural[0:1];
edge class MultiplicityElement_lower extends attribute
	 connect MultiplicityElement[*] -> Integer[0:1];
edge class MultiplicityElement_upperValue extends association
	 connect MultiplicityElement[*] -> ValueSpecification[0:1];
edge class MultiplicityElement_lowerValue extends association
	 connect MultiplicityElement[*] -> ValueSpecification[0:1];

//An action is a named element that is the fundamental unit of executable functionality. The execution of an action represents some transformation or processing in the modeled system, be it a computer system or otherwise.
abstract node class Action extends ActivityNode;
edge class Action_output extends association
	 connect Action[*] -> OutputPin[0:*];
edge class Action_input extends association
	 connect Action[*] -> InputPin[0:*];
edge class Action_context extends association
	 connect Action[*] -> Classifier[0:1];

//An object node is an abstract activity node that is part of defining object flow in an activity.
abstract node class ObjectNode extends ActivityNode, TypedElement;

//A control node is an abstract activity node that coordinates flows in an activity.
abstract node class ControlNode extends ActivityNode;

//An activity edge is an abstract class for directed connections between two activity nodes.
abstract node class ActivityEdge extends RedefinableElement;
edge class ActivityEdge_activity extends association
	 connect ActivityEdge[*] -> Activity[0:1];
edge class ActivityEdge_source extends association
	 connect ActivityEdge[*] -> ActivityNode[1:1];
edge class ActivityEdge_target extends association
	 connect ActivityEdge[*] -> ActivityNode[1:1];
edge class ActivityEdge_inGroup extends association
	 connect ActivityEdge[*] -> ActivityGroup[0:*];
edge class ActivityEdge_redefinedEdge extends association
	 connect ActivityEdge[*] -> ActivityEdge[0:*];

//A control flow is an edge that starts an activity node after the previous one is finished.
node class ControlFlow extends ActivityEdge;

//An object flow is an activity edge that can have objects or data passing along it.
node class ObjectFlow extends ActivityEdge;

//An initial node is a control node at which flow starts when the activity is invoked.
node class InitialNode extends ControlNode;

//An activity final node is a final node that stops all flows in an activity.
node class ActivityFinalNode extends ControlNode;

//ActivityGroup is an abstract class for defining sets of nodes and edges in an activity.
abstract node class ActivityGroup extends Element;
edge class ActivityGroup_containedNode extends association
	 connect ActivityGroup[*] -> ActivityNode[0:*];
edge class ActivityGroup_inActivity extends association
	 connect ActivityGroup[*] -> Activity[0:1];
edge class ActivityGroup_subgroup extends association
	 connect ActivityGroup[*] -> ActivityGroup[0:*];
edge class ActivityGroup_superGroup extends association
	 connect ActivityGroup[*] -> ActivityGroup[0:1];
edge class ActivityGroup_containedEdge extends association
	 connect ActivityGroup[*] -> ActivityEdge[0:*];

//An activity parameter node is an object node for inputs and outputs to activities.
node class ActivityParameterNode extends ObjectNode;
edge class ActivityParameterNode_parameter extends association
	 connect ActivityParameterNode[*] -> Parameter[1:1];

//ActivityNode is an abstract class for points in the flow of an activity connected by edges.
abstract node class ActivityNode extends RedefinableElement;
edge class ActivityNode_activity extends association
	 connect ActivityNode[*] -> Activity[0:1];
edge class ActivityNode_inGroup extends association
	 connect ActivityNode[*] -> ActivityGroup[0:*];
edge class ActivityNode_outgoing extends association
	 connect ActivityNode[*] -> ActivityEdge[0:*];
edge class ActivityNode_incoming extends association
	 connect ActivityNode[*] -> ActivityEdge[0:*];
edge class ActivityNode_redefinedNode extends association
	 connect ActivityNode[*] -> ActivityNode[0:*];

//A pin is a typed element and multiplicity element that provides values to actions and accept result values from them.
node class Pin extends MultiplicityElement, ObjectNode;

//An activity is the specification of parameterized behavior as the coordinated sequencing of subordinate units whose individual elements are actions.
node class Activity extends Behavior {
	
	isReadOnly : boolean = false;
	
}
edge class Activity_node extends association
	 connect Activity[*] -> ActivityNode[0:*];
edge class Activity_group extends association
	 connect Activity[*] -> ActivityGroup[0:*];
edge class Activity_edge extends association
	 connect Activity[*] -> ActivityEdge[0:*];

//A value pin is an input pin that provides a value by evaluating a value specification.
node class ValuePin extends InputPin;
edge class ValuePin_value extends association
	 connect ValuePin[*] -> ValueSpecification[1:1];

//A usage is a relationship in which one element requires another element (or set of elements) for its full implementation or operation. A usage is a dependency in which the client requires the presence of the supplier.
node class Usage extends Dependency;

//An abstraction is a relationship that relates two elements or sets of elements that represent the same concept at different levels of abstraction or from different viewpoints.
node class Abstraction extends Dependency;
edge class Abstraction_mapping extends association
	 connect Abstraction[*] -> OpaqueExpression[0:1];

//A dependency is a relationship that signifies that a single or a set of model elements requires other model elements for their specification or implementation. This means that the complete semantics of the depending elements is either semantically or structurally dependent on the definition of the supplier element(s).
node class Dependency extends DirectedRelationship, PackageableElement;
edge class Dependency_supplier extends association
	 connect Dependency[*] -> NamedElement[1:*];
edge class Dependency_client extends association
	 connect Dependency[*] -> NamedElement[1:*];

//Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client). Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
node class Realization extends Abstraction;

//A substitution is a relationship between two classifiers signifies that the substituting classifier complies with the contract specified by the contract classifier. This implies that instances of the substituting classifier are runtime substitutable where instances of the contract classifier are expected.
node class Substitution extends Realization;
edge class Substitution_contract extends association
	 connect Substitution[*] -> Classifier[1:1];
edge class Substitution_substitutingClassifier extends association
	 connect Substitution[*] -> Classifier[1:1];

//A named element is an element in a model that may have a name.
abstract node class NamedElement extends Element;
edge class NamedElement_name extends attribute
	 connect NamedElement[*] -> String[0:1];
edge class NamedElement_visibility extends attribute
	 connect NamedElement[*] -> VisibilityKind_Value[0:1];
edge class NamedElement_qualifiedName extends attribute
	 connect NamedElement[*] -> String[0:1];
edge class NamedElement_clientDependency extends association
	 connect NamedElement[*] -> Dependency[0:*];
edge class NamedElement_namespace extends association
	 connect NamedElement[*] -> Namespace[0:1];

//A packageable element indicates a named element that may be owned directly by a package.
abstract node class PackageableElement extends NamedElement;

//A namespace is an element in a model that contains a set of named elements that can be identified by name.
abstract node class Namespace extends NamedElement;
edge class Namespace_elementImport extends association
	 connect Namespace[*] -> ElementImport[0:*];
edge class Namespace_packageImport extends association
	 connect Namespace[*] -> PackageImport[0:*];
edge class Namespace_ownedRule extends association
	 connect Namespace[*] -> Constraint[0:*];
edge class Namespace_member extends association
	 connect Namespace[*] -> NamedElement[0:*];
edge class Namespace_importedMember extends association
	 connect Namespace[*] -> PackageableElement[0:*];
edge class Namespace_ownedMember extends association
	 connect Namespace[*] -> NamedElement[0:*];

//An interface realization is a specialized realization relationship between a classifier and an interface. This relationship signifies that the realizing classifier conforms to the contract specified by the interface.
node class InterfaceRealization extends Realization;
edge class InterfaceRealization_contract extends association
	 connect InterfaceRealization[*] -> Interface[1:1];
edge class InterfaceRealization_implementingClassifier extends association
	 connect InterfaceRealization[*] -> BehavioredClassifier[1:1];

//A connector end is an endpoint of a connector, which attaches the connector to a connectable element. Each connector end is part of one connector.
node class ConnectorEnd extends MultiplicityElement;
edge class ConnectorEnd_definingEnd extends association
	 connect ConnectorEnd[*] -> Property[0:1];
edge class ConnectorEnd_role extends association
	 connect ConnectorEnd[*] -> ConnectableElement[1:1];

//Specifies a link that enables communication between two or more instances. This link may be an instance of an association, or it may represent the possibility of the instances being able to communicate because their identities are known by virtue of being passed in as parameters, held in variables or slots, or because the communicating instances are the same instance. The link may be realized by something as simple as a pointer or by something as complex as a network connection. In contrast to associations, which specify links between any instance of the associated classifiers, connectors specify links between instances playing the connected parts only.
node class Connector extends Feature;
edge class Connector_type extends association
	 connect Connector[*] -> Association[0:1];
edge class Connector_redefinedConnector extends association
	 connect Connector[*] -> Connector[0:*];
edge class Connector_end extends association
	 connect Connector[*] -> ConnectorEnd[2:*];

//A property is a structural feature of a classifier that characterizes instances of the classifier. A property related by ownedAttribute to a classifier (other than an association) represents an attribute and might also represent an association end. It relates an instance of the class to a value or set of values of the type of the attribute. A property related by memberEnd or its specializations to an association represents an end of the association. The type of the property is the type of the end of the association.
node class Property extends ConnectableElement, StructuralFeature;
edge class Property_default extends attribute
	 connect Property[*] -> String[0:1];
edge class Property_class extends association
	 connect Property[*] -> Class[0:1];
edge class Property_redefinedProperty extends association
	 connect Property[*] -> Property[0:*];
edge class Property_owningAssociation extends association
	 connect Property[*] -> Association[0:1];
edge class Property_datatype extends association
	 connect Property[*] -> DataType[0:1];
edge class Property_defaultValue extends association
	 connect Property[*] -> ValueSpecification[0:1];
edge class Property_opposite extends association
	 connect Property[*] -> Property[0:1];
edge class Property_subsettedProperty extends association
	 connect Property[*] -> Property[0:*];
edge class Property_association extends association
	 connect Property[*] -> Association[0:1];

//A structured classifier is an abstract metaclass that represents any classifier whose behavior can be fully or partly described by the collaboration of owned or referenced instances.
abstract node class StructuredClassifier extends Classifier;
edge class StructuredClassifier_ownedAttribute extends association
	 connect StructuredClassifier[*] -> Property[0:*];
edge class StructuredClassifier_part extends association
	 connect StructuredClassifier[*] -> Property[0:*];
edge class StructuredClassifier_role extends association
	 connect StructuredClassifier[*] -> ConnectableElement[0:*];
edge class StructuredClassifier_ownedConnector extends association
	 connect StructuredClassifier[*] -> Connector[0:*];

//ConnectableElement is an abstract metaclass representing a set of instances that play roles of a classifier. Connectable elements may be joined by attached connectors and specify configurations of linked instances to be created within an instance of the containing classifier.
abstract node class ConnectableElement extends TypedElement;
edge class ConnectableElement_end extends association
	 connect ConnectableElement[*] -> ConnectorEnd[0:*];

//An interaction is a unit of behavior that focuses on the observable exchange of information between connectable elements.
node class Interaction extends InteractionFragment, Behavior;
edge class Interaction_lifeline extends association
	 connect Interaction[*] -> Lifeline[0:*];
edge class Interaction_message extends association
	 connect Interaction[*] -> Message[0:*];
edge class Interaction_fragment extends association
	 connect Interaction[*] -> InteractionFragment[0:*];
edge class Interaction_action extends association
	 connect Interaction[*] -> Action[0:*];

//A lifeline represents an individual participant in the interaction. While parts and structural features may have multiplicity greater than 1, lifelines represent only one interacting entity.
node class Lifeline extends NamedElement;
edge class Lifeline_coveredBy extends association
	 connect Lifeline[*] -> InteractionFragment[0:*];
edge class Lifeline_represents extends association
	 connect Lifeline[*] -> ConnectableElement[0:1];
edge class Lifeline_interaction extends association
	 connect Lifeline[*] -> Interaction[1:1];
edge class Lifeline_selector extends association
	 connect Lifeline[*] -> ValueSpecification[0:1];

//InteractionFragment is an abstract notion of the most general interaction unit. An interaction fragment is a piece of an interaction. Each interaction fragment is conceptually like an interaction by itself.
abstract node class InteractionFragment extends NamedElement;
edge class InteractionFragment_covered extends association
	 connect InteractionFragment[*] -> Lifeline[0:*];
edge class InteractionFragment_generalOrdering extends association
	 connect InteractionFragment[*] -> GeneralOrdering[0:*];
edge class InteractionFragment_enclosingInteraction extends association
	 connect InteractionFragment[*] -> Interaction[0:1];

//A message defines a particular communication between lifelines of an interaction.
node class Message extends NamedElement;
edge class Message_receiveEvent extends association
	 connect Message[*] -> MessageEnd[0:1];
edge class Message_sendEvent extends association
	 connect Message[*] -> MessageEnd[0:1];
edge class Message_connector extends association
	 connect Message[*] -> Connector[0:1];
edge class Message_interaction extends association
	 connect Message[*] -> Interaction[1:1];
edge class Message_argument extends association
	 connect Message[*] -> ValueSpecification[0:*];
edge class Message_signature extends association
	 connect Message[*] -> NamedElement[0:1];

//A general ordering represents a binary relation between two occurrence specifications, to describe that one occurrence specification must occur before the other in a valid trace. This mechanism provides the ability to define partial orders of occurrence cpecifications that may otherwise not have a specified order.
node class GeneralOrdering extends NamedElement;
edge class GeneralOrdering_before extends association
	 connect GeneralOrdering[*] -> OccurrenceSpecification[1:1];
edge class GeneralOrdering_after extends association
	 connect GeneralOrdering[*] -> OccurrenceSpecification[1:1];

//An execution specification is a specification of the execution of a unit of behavior or action within the lifeline. The duration of an execution specification is represented by two cccurrence specifications, the start occurrence specification and the finish occurrence specification.
abstract node class ExecutionSpecification extends InteractionFragment;
edge class ExecutionSpecification_start extends association
	 connect ExecutionSpecification[*] -> OccurrenceSpecification[1:1];
edge class ExecutionSpecification_finish extends association
	 connect ExecutionSpecification[*] -> OccurrenceSpecification[1:1];

//An occurrence specification is the basic semantic unit of interactions. The sequences of occurrences specified by them are the meanings of interactions.
node class OccurrenceSpecification extends InteractionFragment;
edge class OccurrenceSpecification_covered extends association
	 connect OccurrenceSpecification[*] -> Lifeline[1:1];
edge class OccurrenceSpecification_toAfter extends association
	 connect OccurrenceSpecification[*] -> GeneralOrdering[0:*];
edge class OccurrenceSpecification_toBefore extends association
	 connect OccurrenceSpecification[*] -> GeneralOrdering[0:*];
edge class OccurrenceSpecification_event extends association
	 connect OccurrenceSpecification[*] -> Event[1:1];

//MessageEnd is an abstract specialization of NamedElement that represents what can occur at the end of a message.
abstract node class MessageEnd extends NamedElement;
edge class MessageEnd_message extends association
	 connect MessageEnd[*] -> Message[0:1];

//A state invariant is a runtime constraint on the participants of the interaction. It may be used to specify a variety of different kinds of constraints, such as values of attributes or variables, internal or external states, and so on. A state invariant is an interaction fragment and it is placed on a lifeline.
node class StateInvariant extends InteractionFragment;
edge class StateInvariant_invariant extends association
	 connect StateInvariant[*] -> Constraint[1:1];
edge class StateInvariant_covered extends association
	 connect StateInvariant[*] -> Lifeline[1:1];

//An action execution specification is a kind of execution specification representing the execution of an action.
node class ActionExecutionSpecification extends ExecutionSpecification;
edge class ActionExecutionSpecification_action extends association
	 connect ActionExecutionSpecification[*] -> Action[1:1];

//A behavior execution specification is a kind of execution specification representing the execution of a behavior.
node class BehaviorExecutionSpecification extends ExecutionSpecification;
edge class BehaviorExecutionSpecification_behavior extends association
	 connect BehaviorExecutionSpecification[*] -> Behavior[0:1];

//An execution event models the start or finish of an execution occurrence.
node class ExecutionEvent extends Event;

//A creation event models the creation of an object.
node class CreationEvent extends Event;

//A destruction event models the destruction of an object.
node class DestructionEvent extends Event;

//A send operation event models the invocation of an operation call.
node class SendOperationEvent extends MessageEvent;
edge class SendOperationEvent_operation extends association
	 connect SendOperationEvent[*] -> Operation[1:1];

//A send signal event models the sending of a signal.
node class SendSignalEvent extends MessageEvent;
edge class SendSignalEvent_signal extends association
	 connect SendSignalEvent[*] -> Signal[1:1];

//A message occurrence specification pecifies the occurrence of message events, such as sending and receiving of signals or invoking or receiving of operation calls. A message occurrence specification is a kind of message end. Messages are generated either by synchronous operation calls or asynchronous signal sends. They are received by the execution of corresponding accept event actions.
node class MessageOccurrenceSpecification extends MessageEnd, OccurrenceSpecification;

//An execution occurrence specification represents moments in time at which actions or behaviors start or finish.
node class ExecutionOccurrenceSpecification extends OccurrenceSpecification;
edge class ExecutionOccurrenceSpecification_execution extends association
	 connect ExecutionOccurrenceSpecification[*] -> ExecutionSpecification[1:1];
edge class ExecutionOccurrenceSpecification_event extends association
	 connect ExecutionOccurrenceSpecification[*] -> ExecutionEvent[1:1];

//A receive operation event specifies the event of receiving an operation invocation for a particular operation by the target entity.
node class ReceiveOperationEvent extends MessageEvent;
edge class ReceiveOperationEvent_operation extends association
	 connect ReceiveOperationEvent[*] -> Operation[1:1];

//A receive signal event specifies the event of receiving a signal by the target entity.
node class ReceiveSignalEvent extends MessageEvent;
edge class ReceiveSignalEvent_signal extends association
	 connect ReceiveSignalEvent[*] -> Signal[1:1];

//An actor specifies a role played by a user or any other system that interacts with the subject.
node class Actor extends BehavioredClassifier;

//A relationship from an extending use case to an extended use case that specifies how and when the behavior defined in the extending use case can be inserted into the behavior defined in the extended use case.
node class Extend extends DirectedRelationship, NamedElement;
edge class Extend_extendedCase extends association
	 connect Extend[*] -> UseCase[1:1];
edge class Extend_extension extends association
	 connect Extend[*] -> UseCase[1:1];
edge class Extend_condition extends association
	 connect Extend[*] -> Constraint[0:1];
edge class Extend_extensionLocation extends association
	 connect Extend[*] -> ExtensionPoint[1:*];

//An include relationship defines that a use case contains the behavior defined in another use case.
node class Include extends DirectedRelationship, NamedElement;
edge class Include_includingCase extends association
	 connect Include[*] -> UseCase[1:1];
edge class Include_addition extends association
	 connect Include[*] -> UseCase[1:1];

//A use case is the specification of a set of actions performed by a system, which yields an observable result that is, typically, of value for one or more actors or other stakeholders of the system.
node class UseCase extends BehavioredClassifier;
edge class UseCase_include extends association
	 connect UseCase[*] -> Include[0:*];
edge class UseCase_extend extends association
	 connect UseCase[*] -> Extend[0:*];
edge class UseCase_extensionPoint extends association
	 connect UseCase[*] -> ExtensionPoint[0:*];
edge class UseCase_subject extends association
	 connect UseCase[*] -> Classifier[0:*];

//An extension point identifies a point in the behavior of a use case where that behavior can be extended by the behavior of some other (extending) use case, as specified by an extend relationship.
node class ExtensionPoint extends RedefinableElement;
edge class ExtensionPoint_useCase extends association
	 connect ExtensionPoint[*] -> UseCase[1:1];

//A classifier is a classification of instances - it describes a set of instances that have features in common. A classifier can specify a generalization hierarchy by referencing its general classifiers.
abstract node class Classifier extends RedefinableElement, Type, Namespace {
	
	isAbstract : boolean = false;
	
}
edge class Classifier_generalization extends association
	 connect Classifier[*] -> Generalization[0:*];
edge class Classifier_feature extends association
	 connect Classifier[*] -> Feature[0:*];
edge class Classifier_inheritedMember extends association
	 connect Classifier[*] -> NamedElement[0:*];
edge class Classifier_redefinedClassifier extends association
	 connect Classifier[*] -> Classifier[0:*];
edge class Classifier_general extends association
	 connect Classifier[*] -> Classifier[0:*];
edge class Classifier_substitution extends association
	 connect Classifier[*] -> Substitution[0:*];
edge class Classifier_attribute extends association
	 connect Classifier[*] -> Property[0:*];
edge class Classifier_ownedUseCase extends association
	 connect Classifier[*] -> UseCase[0:*];
edge class Classifier_useCase extends association
	 connect Classifier[*] -> UseCase[0:*];

//A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances.
abstract node class BehavioralFeature extends Feature, Namespace {
	
	isAbstract : boolean = false;
	concurrency : CallConcurrencyKind = CallConcurrencyKind::sequential;
	
}
edge class BehavioralFeature_ownedParameter extends association
	 connect BehavioralFeature[*] -> Parameter[0:*];
edge class BehavioralFeature_method extends association
	 connect BehavioralFeature[*] -> Behavior[0:*];
edge class BehavioralFeature_raisedException extends association
	 connect BehavioralFeature[*] -> Type[0:*];

//A call event models the receipt by an object of a message invoking a call of an operation.
node class CallEvent extends MessageEvent;
edge class CallEvent_operation extends association
	 connect CallEvent[*] -> Operation[1:1];

//A change event models a change in the system configuration that makes a condition true.
node class ChangeEvent extends Event;
edge class ChangeEvent_changeExpression extends association
	 connect ChangeEvent[*] -> ValueSpecification[1:1];

//A class describes a set of objects that share the same specifications of features, constraints, and semantics.
node class Class extends BehavioredClassifier;
edge class Class_nestedClassifier extends association
	 connect Class[*] -> Classifier[0:*];
edge class Class_ownedAttribute extends association
	 connect Class[*] -> Property[0:*];
edge class Class_ownedOperation extends association
	 connect Class[*] -> Operation[0:*];
edge class Class_superClass extends association
	 connect Class[*] -> Class[0:*];
edge class Class_ownedReception extends association
	 connect Class[*] -> Reception[0:*];

//A trigger relates an event to a behavior that may affect an instance of the classifier.
node class Trigger extends NamedElement;
edge class Trigger_event extends association
	 connect Trigger[*] -> Event[1:1];

//An interface is a kind of classifier that represents a declaration of a set of coherent public features and obligations. An interface specifies a contract; any instance of a classifier that realizes the interface must fulfill that contract. The obligations that may be associated with an interface are in the form of various kinds of constraints (such as pre- and post-conditions) or protocol specifications, which may impose ordering restrictions on interactions through the interface.
node class Interface extends Classifier;
edge class Interface_ownedAttribute extends association
	 connect Interface[*] -> Property[0:*];
edge class Interface_ownedOperation extends association
	 connect Interface[*] -> Operation[0:*];
edge class Interface_nestedClassifier extends association
	 connect Interface[*] -> Classifier[0:*];
edge class Interface_redefinedInterface extends association
	 connect Interface[*] -> Interface[0:*];
edge class Interface_ownedReception extends association
	 connect Interface[*] -> Reception[0:*];

//A reception is a declaration stating that a classifier is prepared to react to the receipt of a signal. A reception designates a signal and specifies the expected behavioral response. The details of handling a signal are specified by the behavior associated with the reception or the classifier itself.
node class Reception extends BehavioralFeature;
edge class Reception_signal extends association
	 connect Reception[*] -> Signal[0:1];

//A signal is a specification of send request instances communicated between objects. The receiving object handles the received request instances as specified by its receptions. The data carried by a send request (which was passed to it by the send invocation occurrence that caused that request) are represented as attributes of the signal. A signal is defined independently of the classifiers handling the signal occurrence.
node class Signal extends Classifier;
edge class Signal_ownedAttribute extends association
	 connect Signal[*] -> Property[0:*];

//A signal event represents the receipt of an asynchronous signal instance. A signal event may, for example, cause a state machine to trigger a transition.
node class SignalEvent extends MessageEvent;
edge class SignalEvent_signal extends association
	 connect SignalEvent[*] -> Signal[1:1];

//A time event specifies a point in time. At the specified time, the event occurs.
node class TimeEvent extends Event {
	
	isRelative : boolean = false;
	
}
edge class TimeEvent_when extends association
	 connect TimeEvent[*] -> ValueSpecification[1:1];

//A message event specifies the receipt by an object of either a call or a signal.
abstract node class MessageEvent extends Event;

//A transition trigger associated with an any receive event specifies that the transition is to be triggered by the receipt of any message that is not explicitly referenced in another transition from the same vertex.
node class AnyReceiveEvent extends MessageEvent;

//A behaviored classifier may have an interface realization.
abstract node class BehavioredClassifier extends Classifier;
edge class BehavioredClassifier_ownedBehavior extends association
	 connect BehavioredClassifier[*] -> Behavior[0:*];
edge class BehavioredClassifier_classifierBehavior extends association
	 connect BehavioredClassifier[*] -> Behavior[0:1];
edge class BehavioredClassifier_interfaceRealization extends association
	 connect BehavioredClassifier[*] -> InterfaceRealization[0:*];
edge class BehavioredClassifier_ownedTrigger extends association
	 connect BehavioredClassifier[*] -> Trigger[0:*];

//An event is the specification of some occurrence that may potentially trigger effects by an object.
abstract node class Event extends PackageableElement;

//An operation is a behavioral feature of a classifier that specifies the name, type, parameters, and constraints for invoking an associated behavior.
node class Operation extends BehavioralFeature;
edge class Operation_lower extends attribute
	 connect Operation[*] -> Integer[0:1];
edge class Operation_upper extends attribute
	 connect Operation[*] -> UnlimitedNatural[0:1];
edge class Operation_class extends association
	 connect Operation[*] -> Class[0:1];
edge class Operation_precondition extends association
	 connect Operation[*] -> Constraint[0:*];
edge class Operation_postcondition extends association
	 connect Operation[*] -> Constraint[0:*];
edge class Operation_redefinedOperation extends association
	 connect Operation[*] -> Operation[0:*];
edge class Operation_datatype extends association
	 connect Operation[*] -> DataType[0:1];
edge class Operation_bodyCondition extends association
	 connect Operation[*] -> Constraint[0:1];
edge class Operation_type extends association
	 connect Operation[*] -> Type[0:1];
edge class Operation_ownedParameter extends association
	 connect Operation[*] -> Parameter[0:*];
edge class Operation_raisedException extends association
	 connect Operation[*] -> Type[0:*];
edge class Operation_interface extends association
	 connect Operation[*] -> Interface[0:1];