abstract edge class association;
abstract edge class attribute;

//An integer is a primitive type representing integer values.
node class Integer {
	
	value : int;

}

//A Boolean type is used for logical expression, consisting of the predefined values true and false.
node class Boolean {
	
	value : boolean;

}

//A string is a sequence of characters in some suitable character set used to display information about the model. Character sets may include non-Roman alphabets and characters.
node class String {
	
	value : string;

}

//An unlimited natural is a primitive type representing unlimited natural values.
node class UnlimitedNatural {
	
	value : int;

}

//AggregationKind is an enumeration type that specifies the literals for defining the kind of aggregation of a property.
enum AggregationKind {
	
	//Indicates that the property has no aggregation.
	none, 
	//Indicates that the property has a shared aggregation.
	shared, 
	//Indicates that the property is aggregated compositely, i.e., the composite object has responsibility for the existence and storage of the composed objects (parts).
	composite
	
}

node class AggregationKind_Value {
	
	value : AggregationKind;
	
}

//Parameter direction kind is an enumeration type that defines literals used to specify direction of parameters.
enum ParameterDirectionKind {
	
	//Indicates that parameter values are passed into the behavioral element by the caller.
	in, 
	//Indicates that parameter values are passed into a behavioral element by the caller and then back out to the caller from the behavioral element.
	inout, 
	//Indicates that parameter values are passed from a behavioral element out to the caller.
	out, 
	//Indicates that parameter values are passed as return values from a behavioral element back to the caller.
	return_
	
}

node class ParameterDirectionKind_Value {
	
	value : ParameterDirectionKind;
	
}

//VisibilityKind is an enumeration type that defines literals to determine the visibility of elements in a model.
enum VisibilityKind {
	
	//A public element is visible to all elements that can access the contents of the namespace that owns it.
	public, 
	//A private element is only visible inside the namespace that owns it.
	private, 
	//A protected element is visible to elements that have a generalization relationship to the namespace that owns it.
	protected, 
	//A package element is owned by a namespace that is not a package, and is visible to elements that are in the same package as its owning namespace. Only named elements that are not owned by packages can be marked as having package visibility. Any element marked as having package visibility is visible to all elements within the nearest enclosing package (given that other owning elements have proper visibility). Outside the nearest enclosing package, an element marked as having package visibility is not visible.
	package
	
}

node class VisibilityKind_Value {
	
	value : VisibilityKind;
	
}

//This is an enumerated type that identifies the type of message.
enum MessageKind {
	
	//sendEvent and receiveEvent are present
	complete, 
	//sendEvent present and receiveEvent absent
	lost, 
	//sendEvent absent and receiveEvent present
	found, 
	//sendEvent and receiveEvent absent (should not appear)
	unknown
	
}

node class MessageKind_Value {
	
	value : MessageKind;
	
}

//This is an enumerated type that identifies the type of communication action that was used to generate the message.
enum MessageSort {
	
	//The message was generated by a synchronous call to an operation.
	synchCall, 
	//The message was generated by an asynchronous call to an operation; i.e., a CallAction with isSynchronous = false.
	asynchCall, 
	//The message was generated by an asynchronous send action.
	asynchSignal, 
	//The message designating the creation of another lifeline object.
	createMessage, 
	//The message designating the termination of another lifeline.
	deleteMessage, 
	//The message is a reply message to an operation call.
	reply
	
}

node class MessageSort_Value {
	
	value : MessageSort;
	
}

//CallConcurrencyKind is an enumeration type.
enum CallConcurrencyKind {
	
	//No concurrency management mechanism is associated with the operation and, therefore, concurrency conflicts may occur. Instances that invoke a behavioral feature need to coordinate so that only one invocation to a target on any behavioral feature occurs at once.
	sequential, 
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance, but only one is allowed to commence. The others are blocked until the performance of the first behavioral feature is complete. It is the responsibility of the system designer to ensure that deadlocks do not occur due to simultaneous blocks.
	guarded, 
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance and all of them may proceed concurrently.
	concurrent
	
}

node class CallConcurrencyKind_Value {
	
	value : CallConcurrencyKind;
	
}

//ConnectorKind is an enumeration type.
enum ConnectorKind {
	
	//Indicates that the connector is an assembly connector.
	assembly, 
	//Indicates that the connector is a delegation connector.
	delegation
	
}

node class ConnectorKind_Value {
	
	value : ConnectorKind;
	
}

//InteractionOperatorKind is an enumeration designating the different kinds of operators of combined fragments. The interaction operand defines the type of operator of a combined fragment.
enum InteractionOperatorKind {
	
	//The interactionOperator seq designates that the CombinedFragment represents a weak sequencing between the behaviors of the operands.
	seq, 
	//The interactionOperator alt designates that the CombinedFragment represents a choice of behavior. At most one of the operands will be chosen. The chosen operand must have an explicit or implicit guard expression that evaluates to true at this point in the interaction. An implicit true guard is implied if the operand has no guard.
	alt, 
	//The interactionOperator opt designates that the CombinedFragment represents a choice of behavior where either the (sole) operand happens or nothing happens. An option is semantically equivalent to an alternative CombinedFragment where there is one operand with non-empty content and the second operand is empty.
	opt, 
	//The interactionOperator break designates that the CombinedFragment represents a breaking scenario in the sense that the operand is a scenario that is performed instead of the remainder of the enclosing InteractionFragment. A break operator with a guard is chosen when the guard is true and the rest of the enclosing Interaction Fragment is ignored. When the guard of the break operand is false, the break operand is ignored and the rest of the enclosing InteractionFragment is chosen. The choice between a break operand without a guard and the rest of the enclosing InteractionFragment is done non-deterministically.
	break, 
	//The interactionOperator par designates that the CombinedFragment represents a parallel merge between the behaviors of the operands. The OccurrenceSpecifications of the different operands can be interleaved in any way as long as the ordering imposed by each operand as such is preserved.
	par, 
	//The interactionOperator strict designates that the CombinedFragment represents a strict sequencing between the behaviors of the operands. The semantics of strict sequencing defines a strict ordering of the operands on the first level within the CombinedFragment with interactionOperator strict. Therefore OccurrenceSpecifications within contained CombinedFragment will not directly be compared with other OccurrenceSpecifications of the enclosing CombinedFragment.
	strict, 
	//The interactionOperator loop designates that the CombinedFragment represents a loop. The loop operand will be repeated a number of times.
	loop, 
	//The interactionOperator critical designates that the CombinedFragment represents a critical region. A critical region means that the traces of the region cannot be interleaved by other OccurrenceSpecifications (on those Lifelines covered by the region). This means that the region is treated atomically by the enclosing fragment when determining the set of valid traces. Even though enclosing CombinedFragments may imply that some OccurrenceSpecifications may interleave into the region, such as e.g. with par-operator, this is prevented by defining a region.
	critical, 
	//The interactionOperator neg designates that the CombinedFragment represents traces that are defined to be invalid.
	neg, 
	//The interactionOperator assert designates that the CombinedFragment represents an assertion. The sequences of the operand of the assertion are the only valid continuations. All other continuations result in an invalid trace.
	assert, 
	//The interacionOperator ignore designates that there are some message types that are not shown within this combined fragment. These message types can be considered insignificant and are implicitly ignored if they appear in a corresponding execution. Alternatively, one can understand ignore to mean that the message types that are ignored can appear anywhere in the traces.
	ignore, 
	//The interactionOperator consider designates which messages should be considered within this combined fragment. This is equivalent to defining every other message to be ignored.
	consider
	
}

node class InteractionOperatorKind_Value {
	
	value : InteractionOperatorKind;
	
}

//PseudostateKind is an enumeration type.
enum PseudostateKind {
	
	//An initial pseudostate represents a default vertex that is the source for a single transition to the default state of a composite state. There can be at most one initial vertex in a region. The outgoing transition from the initial vertex may have a behavior, but not a trigger or guard.
	initial, 
	//DeepHistory represents the most recent active configuration of the composite state that directly contains this pseudostate; e.g. the state configuration that was active when the composite state was last exited. A composite state can have at most one deep history vertex. At most one transition may originate from the history connector to the default deep history state. This transition is taken in case the composite state had never been active before. Entry actions of states entered on the path to the state represented by a deep history are performed.
	deepHistory, 
	//ShallowHistory represents the most recent active substate of its containing state (but not the substates of that substate). A composite state can have at most one shallow history vertex. A transition coming into the shallow history vertex is equivalent to a transition coming into the most recent active substate of a state. At most one transition may originate from the history connector to the default shallow history state. This transition is taken in case the composite state had never been active before. Entry actions of states entered on the path to the state represented by a shallow history are performed.
	shallowHistory, 
	//Join vertices serve to merge several transitions emanating from source vertices in different orthogonal regions. The transitions entering a join vertex cannot have guards or triggers.
	join, 
	//Fork vertices serve to split an incoming transition into two or more transitions terminating on orthogonal target vertices (i.e. vertices in different regions of a composite state). The segments outgoing from a fork vertex must not have guards or triggers.
	fork, 
	//Junction vertices are semantic-free vertices that are used to chain together multiple transitions. They are used to construct compound transition paths between states. For example, a junction can be used to converge multiple incoming transitions into a single outgoing transition representing a shared transition path (this is known as an merge). Conversely, they can be used to split an incoming transition into multiple outgoing transition segments with different guard conditions. This realizes a static conditional branch. (In the latter case, outgoing transitions whose guard conditions evaluate to false are disabled. A predefined guard denoted 'else' may be defined for at most one outgoing transition. This transition is enabled if all the guards labeling the other transitions are false.) Static conditional branches are distinct from dynamic conditional branches that are realized by choice vertices (described below).
	junction, 
	//Choice vertices which, when reached, result in the dynamic evaluation of the guards of the triggers of its outgoing transitions. This realizes a dynamic conditional branch. It allows splitting of transitions into multiple outgoing paths such that the decision on which path to take may be a function of the results of prior actions performed in the same run-tocompletion step. If more than one of the guards evaluates to true, an arbitrary one is selected. If none of the guards evaluates to true, then the model is considered ill-formed. (To avoid this, it is recommended to define one outgoing transition with the predefined else guard for every choice vertex.) Choice vertices should be distinguished from static branch points that are based on junction points (described above).
	choice, 
	//An entry point pseudostate is an entry point of a state machine or composite state. In each region of the state machine or composite state it has a single transition to a vertex within the same region.
	entryPoint, 
	//An exit point pseudostate is an exit point of a state machine or composite state. Entering an exit point within any region of the composite state or state machine referenced by a submachine state implies the exit of this composite state or submachine state and the triggering of the transition that has this exit point as source in the state machine enclosing the submachine or composite state.
	exitPoint, 
	//Entering a terminate pseudostate implies that the execution of this state machine by means of its context object is terminated. The state machine does not exit any states nor does it perform any exit actions other than those associated with the transition leading to the terminate pseudostate. Entering a terminate pseudostate is equivalent to invoking a DestroyObjectAction.
	terminate
	
}

node class PseudostateKind_Value {
	
	value : PseudostateKind;
	
}

//TransitionKind is an enumeration type.
enum TransitionKind {
	
	//Implies that the transition, if triggered, occurs without exiting or entering the source state. Thus, it does not cause a state change. This means that the entry or exit condition of the source state will not be invoked. An internal transition can be taken even if the state machine is in one or more regions nested within this state.
	internal, 
	//Implies that the transition, if triggered, will not exit the composite (source) state, but it will apply to any state within the composite state, and these will be exited and entered.
	local, 
	//Implies that the transition, if triggered, will exit the composite (source) state.
	external
	
}

node class TransitionKind_Value {
	
	value : TransitionKind;
	
}

//A comment is a textual annotation that can be attached to a set of elements.
node class Comment extends Element;
edge class Comment_body extends attribute
	 connect Comment[*] -> String[0:1];
edge class Comment_annotatedElement extends association
	 connect Comment[*] -> Element[0:*];

//A directed relationship represents a relationship between a collection of source model elements and a collection of target model elements.
abstract node class DirectedRelationship extends Relationship;
edge class DirectedRelationship_source extends association
	 connect DirectedRelationship[*] -> Element[1:*];
edge class DirectedRelationship_target extends association
	 connect DirectedRelationship[*] -> Element[1:*];

//A literal specification identifies a literal constant being modeled.
abstract node class LiteralSpecification extends ValueSpecification;

//A literal integer is a specification of an integer value.
node class LiteralInteger extends LiteralSpecification {
	
	value : int = 0;
	
}

//A literal string is a specification of a string value.
node class LiteralString extends LiteralSpecification;
edge class LiteralString_value extends attribute
	 connect LiteralString[*] -> String[0:1];

//A literal Boolean is a specification of a Boolean value.
node class LiteralBoolean extends LiteralSpecification {
	
	value : boolean = false;
	
}

//A literal null specifies the lack of a value.
node class LiteralNull extends LiteralSpecification;

//A constraint is a condition or restriction expressed in natural language text or in a machine readable language for the purpose of declaring some of the semantics of an element.
node class Constraint extends PackageableElement;
edge class Constraint_constrainedElement extends association
	 connect Constraint[*] -> Element[0:*];
edge class Constraint_specification extends association
	 connect Constraint[*] -> ValueSpecification[1:1];
edge class Constraint_context extends association
	 connect Constraint[*] -> Namespace[0:1];

//An element import identifies an element in another package, and allows the element to be referenced using its name without a qualifier.
node class ElementImport extends DirectedRelationship;
edge class ElementImport_alias extends attribute
	 connect ElementImport[*] -> String[0:1];
edge class ElementImport_importedElement extends association
	 connect ElementImport[*] -> PackageableElement[1:1];
edge class ElementImport_importingNamespace extends association
	 connect ElementImport[*] -> Namespace[1:1];

//A typed element is a kind of named element that represents an element with a type.
abstract node class TypedElement extends NamedElement;
edge class TypedElement_type extends association
	 connect TypedElement[*] -> Type[0:1];

//A feature declares a behavioral or structural characteristic of instances of classifiers.
abstract node class Feature extends RedefinableElement {
	
	isStatic : boolean = false;
	
}
edge class Feature_featuringClassifier extends association
	 connect Feature[*] -> Classifier[0:*];

//A redefinable element is an element that, when defined in the context of a classifier, can be redefined more specifically or differently in the context of another classifier that specializes (directly or indirectly) the context classifier.
abstract node class RedefinableElement extends NamedElement {
	
	isLeaf : boolean = false;
	
}
edge class RedefinableElement_redefinedElement extends association
	 connect RedefinableElement[*] -> RedefinableElement[0:*];
edge class RedefinableElement_redefinitionContext extends association
	 connect RedefinableElement[*] -> Classifier[0:*];

//A generalization is a taxonomic relationship between a more general classifier and a more specific classifier. Each instance of the specific classifier is also an indirect instance of the general classifier. Thus, the specific classifier inherits the features of the more general classifier.
node class Generalization extends DirectedRelationship;
edge class Generalization_isSubstitutable extends attribute
	 connect Generalization[*] -> Boolean[0:1];
edge class Generalization_specific extends association
	 connect Generalization[*] -> Classifier[1:1];
edge class Generalization_general extends association
	 connect Generalization[*] -> Classifier[1:1];

//A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral feature.
node class Parameter extends TypedElement, MultiplicityElement;
edge class Parameter_default extends attribute
	 connect Parameter[*] -> String[0:1];
edge class Parameter_defaultValue extends association
	 connect Parameter[*] -> ValueSpecification[0:1];
edge class Parameter_operation extends association
	 connect Parameter[*] -> Operation[0:1];

//A structural feature is a typed feature of a classifier that specifies the structure of instances of the classifier.
abstract node class StructuralFeature extends Feature, TypedElement, MultiplicityElement {
	
	isReadOnly : boolean = false;
	
}

//A slot specifies that an entity modeled by an instance specification has a value or values for a specific structural feature.
node class Slot extends Element;
edge class Slot_owningInstance extends association
	 connect Slot[*] -> InstanceSpecification[1:1];
edge class Slot_definingFeature extends association
	 connect Slot[*] -> StructuralFeature[1:1];
edge class Slot_value extends association
	 connect Slot[*] -> ValueSpecification[0:*];

//A package import is a relationship that allows the use of unqualified names to refer to package members from other namespaces.
node class PackageImport extends DirectedRelationship;
edge class PackageImport_importingNamespace extends association
	 connect PackageImport[*] -> Namespace[1:1];
edge class PackageImport_importedPackage extends association
	 connect PackageImport[*] -> Package[1:1];

//A data type is a type whose instances are identified only by their value. A data type may contain attributes to support the modeling of structured data types.
node class DataType extends Classifier;
edge class DataType_ownedAttribute extends association
	 connect DataType[*] -> Property[0:*];
edge class DataType_ownedOperation extends association
	 connect DataType[*] -> Operation[0:*];

//An enumeration is a data type whose values are enumerated in the model as enumeration literals.
node class Enumeration extends DataType;
edge class Enumeration_ownedLiteral extends association
	 connect Enumeration[*] -> EnumerationLiteral[0:*];

//An enumeration literal is a user-defined data value for an enumeration.
node class EnumerationLiteral extends InstanceSpecification;
edge class EnumerationLiteral_enumeration extends association
	 connect EnumerationLiteral[*] -> Enumeration[0:1];

//A primitive type defines a predefined data type, without any relevant substructure (i.e., it has no parts in the context of UML). A primitive datatype may have an algebra and operations defined outside of UML, for example, mathematically.
node class PrimitiveType extends DataType;

//An association describes a set of tuples whose values refer to typed instances. An instance of an association is called a link.
node class Association extends Relationship, Classifier {
	
	isDerived : boolean = false;
	
}
edge class Association_ownedEnd extends association
	 connect Association[*] -> Property[0:*];
edge class Association_endType extends association
	 connect Association[*] -> Type[1:*];
edge class Association_memberEnd extends association
	 connect Association[*] -> Property[2:*];
edge class Association_navigableOwnedEnd extends association
	 connect Association[*] -> Property[0:*];

//A value specification is the specification of a (possibly empty) set of instances, including both objects and data values.
abstract node class ValueSpecification extends TypedElement, PackageableElement;

//Relationship is an abstract concept that specifies some kind of relationship between elements.
abstract node class Relationship extends Element;
edge class Relationship_relatedElement extends association
	 connect Relationship[*] -> Element[1:*];

//A package merge defines how the contents of one package are extended by the contents of another package.
node class PackageMerge extends DirectedRelationship;
edge class PackageMerge_receivingPackage extends association
	 connect PackageMerge[*] -> Package[1:1];
edge class PackageMerge_mergedPackage extends association
	 connect PackageMerge[*] -> Package[1:1];

//An instance value is a value specification that identifies an instance.
node class InstanceValue extends ValueSpecification;
edge class InstanceValue_instance extends association
	 connect InstanceValue[*] -> InstanceSpecification[1:1];

//A literal unlimited natural is a specification of an unlimited natural number.
node class LiteralUnlimitedNatural extends LiteralSpecification {
	
	value : int = 0;
	
}

//A type is a named element that is used as the type for a typed element. A type can be contained in a package.
abstract node class Type extends PackageableElement;
edge class Type_package extends association
	 connect Type[*] -> Package[0:1];

//An expression is a structured tree of symbols that denotes a (possibly empty) set of values when evaluated in a context.
node class Expression extends ValueSpecification;
edge class Expression_symbol extends attribute
	 connect Expression[*] -> String[0:1];
edge class Expression_operand extends association
	 connect Expression[*] -> ValueSpecification[0:*];

//Behavior is a specification of how its context classifier changes state over time. This specification may be either a definition of possible behavior execution or emergent behavior, or a selective illustration of an interesting subset of possible executions. The latter form is typically used for capturing examples, such as a trace of a particular execution.
abstract node class Behavior extends Class {
	
	isReentrant : boolean = false;
	
}
edge class Behavior_redefinedBehavior extends association
	 connect Behavior[*] -> Behavior[0:*];
edge class Behavior_specification extends association
	 connect Behavior[*] -> BehavioralFeature[0:1];
edge class Behavior_ownedParameter extends association
	 connect Behavior[*] -> Parameter[0:*];
edge class Behavior_context extends association
	 connect Behavior[*] -> BehavioredClassifier[0:1];
edge class Behavior_precondition extends association
	 connect Behavior[*] -> Constraint[0:*];
edge class Behavior_postcondition extends association
	 connect Behavior[*] -> Constraint[0:*];

//An opaque expression is an uninterpreted textual statement that denotes a (possibly empty) set of values when evaluated in a context.
node class OpaqueExpression extends ValueSpecification;
edge class OpaqueExpression_body extends attribute
	 connect OpaqueExpression[*] -> String[0:*];
edge class OpaqueExpression_language extends attribute
	 connect OpaqueExpression[*] -> String[0:*];
edge class OpaqueExpression_result extends association
	 connect OpaqueExpression[*] -> Parameter[0:1];
edge class OpaqueExpression_behavior extends association
	 connect OpaqueExpression[*] -> Behavior[0:1];

//An behavior with implementation-specific semantics.
node class OpaqueBehavior extends Behavior;
edge class OpaqueBehavior_body extends attribute
	 connect OpaqueBehavior[*] -> String[0:*];
edge class OpaqueBehavior_language extends attribute
	 connect OpaqueBehavior[*] -> String[0:*];

//A function behavior is an opaque behavior that does not access or modify any objects or other external data.
node class FunctionBehavior extends OpaqueBehavior;

//An action with implementation-specific semantics.
node class OpaqueAction extends Action;
edge class OpaqueAction_body extends attribute
	 connect OpaqueAction[*] -> String[0:*];
edge class OpaqueAction_language extends attribute
	 connect OpaqueAction[*] -> String[0:*];
edge class OpaqueAction_inputValue extends association
	 connect OpaqueAction[*] -> InputPin[0:*];
edge class OpaqueAction_outputValue extends association
	 connect OpaqueAction[*] -> OutputPin[0:*];

//CallAction is an abstract class for actions that invoke behavior and receive return values.
abstract node class CallAction extends InvocationAction {
	
	isSynchronous : boolean = true;
	
}
edge class CallAction_result extends association
	 connect CallAction[*] -> OutputPin[0:*];

//A send signal action is an action that creates a signal instance from its inputs, and transmits it to the target object, where it may cause the firing of a state machine transition or the execution of an activity. The argument values are available to the execution of associated behaviors. The requestor continues execution immediately. Any reply message is ignored and is not transmitted to the requestor. If the input is already a signal instance, use a send object action.
node class SendSignalAction extends InvocationAction;
edge class SendSignalAction_target extends association
	 connect SendSignalAction[*] -> InputPin[1:1];
edge class SendSignalAction_signal extends association
	 connect SendSignalAction[*] -> Signal[1:1];

//A call operation action is an action that transmits an operation call request to the target object, where it may cause the invocation of associated behavior. The argument values of the action are available to the execution of the invoked behavior. If the action is marked synchronous, the execution of the call operation action waits until the execution of the invoked behavior completes and a reply transmission is returned to the caller; otherwise execution of the action is complete when the invocation of the operation is established and the execution of the invoked operation proceeds concurrently with the execution of the calling behavior. Any values returned as part of the reply transmission are put on the result output pins of the call operation action. Upon receipt of the reply transmission, execution of the call operation action is complete.
node class CallOperationAction extends CallAction;
edge class CallOperationAction_operation extends association
	 connect CallOperationAction[*] -> Operation[1:1];
edge class CallOperationAction_target extends association
	 connect CallOperationAction[*] -> InputPin[1:1];

//A call behavior action is a call action that invokes a behavior directly rather than invoking a behavioral feature that, in turn, results in the invocation of that behavior. The argument values of the action are available to the execution of the invoked behavior. For synchronous calls the execution of the call behavior action waits until the execution of the invoked behavior completes and a result is returned on its output pin. The action completes immediately without a result, if the call is asynchronous. In particular, the invoked behavior may be an activity.
node class CallBehaviorAction extends CallAction;
edge class CallBehaviorAction_behavior extends association
	 connect CallBehaviorAction[*] -> Behavior[1:1];

//A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending with a (possibly infinite) upper bound. A multiplicity element embeds this information to specify the allowable cardinalities for an instantiation of this element.
abstract node class MultiplicityElement extends Element;
edge class MultiplicityElement_upper extends attribute
	 connect MultiplicityElement[*] -> UnlimitedNatural[0:1];
edge class MultiplicityElement_lower extends attribute
	 connect MultiplicityElement[*] -> Integer[0:1];
edge class MultiplicityElement_upperValue extends association
	 connect MultiplicityElement[*] -> ValueSpecification[0:1];
edge class MultiplicityElement_lowerValue extends association
	 connect MultiplicityElement[*] -> ValueSpecification[0:1];

//An object node is an abstract activity node that is part of defining object flow in an activity.
abstract node class ObjectNode extends ActivityNode, TypedElement;

//A control node is an abstract activity node that coordinates flows in an activity.
abstract node class ControlNode extends ActivityNode;

//A control flow is an edge that starts an activity node after the previous one is finished.
node class ControlFlow extends ActivityEdge;

//An object flow is an activity edge that can have objects or data passing along it.
node class ObjectFlow extends ActivityEdge;

//An initial node is a control node at which flow starts when the activity is invoked.
node class InitialNode extends ControlNode;

//An activity parameter node is an object node for inputs and outputs to activities.
node class ActivityParameterNode extends ObjectNode;
edge class ActivityParameterNode_parameter extends association
	 connect ActivityParameterNode[*] -> Parameter[1:1];

//A pin is a typed element and multiplicity element that provides values to actions and accept result values from them.
node class Pin extends MultiplicityElement, ObjectNode;

//A value pin is an input pin that provides a value by evaluating a value specification.
node class ValuePin extends InputPin;
edge class ValuePin_value extends association
	 connect ValuePin[*] -> ValueSpecification[1:1];

//A usage is a relationship in which one element requires another element (or set of elements) for its full implementation or operation. A usage is a dependency in which the client requires the presence of the supplier.
node class Usage extends Dependency;

//An abstraction is a relationship that relates two elements or sets of elements that represent the same concept at different levels of abstraction or from different viewpoints.
node class Abstraction extends Dependency;
edge class Abstraction_mapping extends association
	 connect Abstraction[*] -> OpaqueExpression[0:1];

//A dependency is a relationship that signifies that a single or a set of model elements requires other model elements for their specification or implementation. This means that the complete semantics of the depending elements is either semantically or structurally dependent on the definition of the supplier element(s).
node class Dependency extends DirectedRelationship, PackageableElement;
edge class Dependency_supplier extends association
	 connect Dependency[*] -> NamedElement[1:*];
edge class Dependency_client extends association
	 connect Dependency[*] -> NamedElement[1:*];

//Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client). Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
node class Realization extends Abstraction;

//A substitution is a relationship between two classifiers signifies that the substituting classifier complies with the contract specified by the contract classifier. This implies that instances of the substituting classifier are runtime substitutable where instances of the contract classifier are expected.
node class Substitution extends Realization;
edge class Substitution_contract extends association
	 connect Substitution[*] -> Classifier[1:1];
edge class Substitution_substitutingClassifier extends association
	 connect Substitution[*] -> Classifier[1:1];

//A packageable element indicates a named element that may be owned directly by a package.
abstract node class PackageableElement extends NamedElement;

//A namespace is an element in a model that contains a set of named elements that can be identified by name.
abstract node class Namespace extends NamedElement;
edge class Namespace_elementImport extends association
	 connect Namespace[*] -> ElementImport[0:*];
edge class Namespace_packageImport extends association
	 connect Namespace[*] -> PackageImport[0:*];
edge class Namespace_ownedRule extends association
	 connect Namespace[*] -> Constraint[0:*];
edge class Namespace_member extends association
	 connect Namespace[*] -> NamedElement[0:*];
edge class Namespace_importedMember extends association
	 connect Namespace[*] -> PackageableElement[0:*];
edge class Namespace_ownedMember extends association
	 connect Namespace[*] -> NamedElement[0:*];

//An interface realization is a specialized realization relationship between a classifier and an interface. This relationship signifies that the realizing classifier conforms to the contract specified by the interface.
node class InterfaceRealization extends Realization;
edge class InterfaceRealization_contract extends association
	 connect InterfaceRealization[*] -> Interface[1:1];
edge class InterfaceRealization_implementingClassifier extends association
	 connect InterfaceRealization[*] -> BehavioredClassifier[1:1];

//A structured classifier is an abstract metaclass that represents any classifier whose behavior can be fully or partly described by the collaboration of owned or referenced instances.
abstract node class StructuredClassifier extends Classifier;
edge class StructuredClassifier_ownedAttribute extends association
	 connect StructuredClassifier[*] -> Property[0:*];
edge class StructuredClassifier_part extends association
	 connect StructuredClassifier[*] -> Property[0:*];
edge class StructuredClassifier_role extends association
	 connect StructuredClassifier[*] -> ConnectableElement[0:*];
edge class StructuredClassifier_ownedConnector extends association
	 connect StructuredClassifier[*] -> Connector[0:*];

//ConnectableElement is an abstract metaclass representing a set of instances that play roles of a classifier. Connectable elements may be joined by attached connectors and specify configurations of linked instances to be created within an instance of the containing classifier.
abstract node class ConnectableElement extends TypedElement;
edge class ConnectableElement_end extends association
	 connect ConnectableElement[*] -> ConnectorEnd[0:*];

//A message defines a particular communication between lifelines of an interaction.
node class Message extends NamedElement;
edge class Message_receiveEvent extends association
	 connect Message[*] -> MessageEnd[0:1];
edge class Message_sendEvent extends association
	 connect Message[*] -> MessageEnd[0:1];
edge class Message_connector extends association
	 connect Message[*] -> Connector[0:1];
edge class Message_interaction extends association
	 connect Message[*] -> Interaction[1:1];
edge class Message_argument extends association
	 connect Message[*] -> ValueSpecification[0:*];
edge class Message_signature extends association
	 connect Message[*] -> NamedElement[0:1];

//A general ordering represents a binary relation between two occurrence specifications, to describe that one occurrence specification must occur before the other in a valid trace. This mechanism provides the ability to define partial orders of occurrence cpecifications that may otherwise not have a specified order.
node class GeneralOrdering extends NamedElement;
edge class GeneralOrdering_before extends association
	 connect GeneralOrdering[*] -> OccurrenceSpecification[1:1];
edge class GeneralOrdering_after extends association
	 connect GeneralOrdering[*] -> OccurrenceSpecification[1:1];

//An execution specification is a specification of the execution of a unit of behavior or action within the lifeline. The duration of an execution specification is represented by two cccurrence specifications, the start occurrence specification and the finish occurrence specification.
abstract node class ExecutionSpecification extends InteractionFragment;
edge class ExecutionSpecification_start extends association
	 connect ExecutionSpecification[*] -> OccurrenceSpecification[1:1];
edge class ExecutionSpecification_finish extends association
	 connect ExecutionSpecification[*] -> OccurrenceSpecification[1:1];

//An occurrence specification is the basic semantic unit of interactions. The sequences of occurrences specified by them are the meanings of interactions.
node class OccurrenceSpecification extends InteractionFragment;
edge class OccurrenceSpecification_covered extends association
	 connect OccurrenceSpecification[*] -> Lifeline[1:1];
edge class OccurrenceSpecification_toAfter extends association
	 connect OccurrenceSpecification[*] -> GeneralOrdering[0:*];
edge class OccurrenceSpecification_toBefore extends association
	 connect OccurrenceSpecification[*] -> GeneralOrdering[0:*];
edge class OccurrenceSpecification_event extends association
	 connect OccurrenceSpecification[*] -> Event[1:1];

//MessageEnd is an abstract specialization of NamedElement that represents what can occur at the end of a message.
abstract node class MessageEnd extends NamedElement;
edge class MessageEnd_message extends association
	 connect MessageEnd[*] -> Message[0:1];

//A state invariant is a runtime constraint on the participants of the interaction. It may be used to specify a variety of different kinds of constraints, such as values of attributes or variables, internal or external states, and so on. A state invariant is an interaction fragment and it is placed on a lifeline.
node class StateInvariant extends InteractionFragment;
edge class StateInvariant_invariant extends association
	 connect StateInvariant[*] -> Constraint[1:1];
edge class StateInvariant_covered extends association
	 connect StateInvariant[*] -> Lifeline[1:1];

//An action execution specification is a kind of execution specification representing the execution of an action.
node class ActionExecutionSpecification extends ExecutionSpecification;
edge class ActionExecutionSpecification_action extends association
	 connect ActionExecutionSpecification[*] -> Action[1:1];

//A behavior execution specification is a kind of execution specification representing the execution of a behavior.
node class BehaviorExecutionSpecification extends ExecutionSpecification;
edge class BehaviorExecutionSpecification_behavior extends association
	 connect BehaviorExecutionSpecification[*] -> Behavior[0:1];

//An execution event models the start or finish of an execution occurrence.
node class ExecutionEvent extends Event;

//A creation event models the creation of an object.
node class CreationEvent extends Event;

//A destruction event models the destruction of an object.
node class DestructionEvent extends Event;

//A send operation event models the invocation of an operation call.
node class SendOperationEvent extends MessageEvent;
edge class SendOperationEvent_operation extends association
	 connect SendOperationEvent[*] -> Operation[1:1];

//A send signal event models the sending of a signal.
node class SendSignalEvent extends MessageEvent;
edge class SendSignalEvent_signal extends association
	 connect SendSignalEvent[*] -> Signal[1:1];

//A message occurrence specification pecifies the occurrence of message events, such as sending and receiving of signals or invoking or receiving of operation calls. A message occurrence specification is a kind of message end. Messages are generated either by synchronous operation calls or asynchronous signal sends. They are received by the execution of corresponding accept event actions.
node class MessageOccurrenceSpecification extends MessageEnd, OccurrenceSpecification;

//An execution occurrence specification represents moments in time at which actions or behaviors start or finish.
node class ExecutionOccurrenceSpecification extends OccurrenceSpecification;
edge class ExecutionOccurrenceSpecification_execution extends association
	 connect ExecutionOccurrenceSpecification[*] -> ExecutionSpecification[1:1];
edge class ExecutionOccurrenceSpecification_event extends association
	 connect ExecutionOccurrenceSpecification[*] -> ExecutionEvent[1:1];

//A receive operation event specifies the event of receiving an operation invocation for a particular operation by the target entity.
node class ReceiveOperationEvent extends MessageEvent;
edge class ReceiveOperationEvent_operation extends association
	 connect ReceiveOperationEvent[*] -> Operation[1:1];

//A receive signal event specifies the event of receiving a signal by the target entity.
node class ReceiveSignalEvent extends MessageEvent;
edge class ReceiveSignalEvent_signal extends association
	 connect ReceiveSignalEvent[*] -> Signal[1:1];

//An actor specifies a role played by a user or any other system that interacts with the subject.
node class Actor extends BehavioredClassifier;

//A relationship from an extending use case to an extended use case that specifies how and when the behavior defined in the extending use case can be inserted into the behavior defined in the extended use case.
node class Extend extends DirectedRelationship, NamedElement;
edge class Extend_extendedCase extends association
	 connect Extend[*] -> UseCase[1:1];
edge class Extend_extension extends association
	 connect Extend[*] -> UseCase[1:1];
edge class Extend_condition extends association
	 connect Extend[*] -> Constraint[0:1];
edge class Extend_extensionLocation extends association
	 connect Extend[*] -> ExtensionPoint[1:*];

//An include relationship defines that a use case contains the behavior defined in another use case.
node class Include extends DirectedRelationship, NamedElement;
edge class Include_includingCase extends association
	 connect Include[*] -> UseCase[1:1];
edge class Include_addition extends association
	 connect Include[*] -> UseCase[1:1];

//A use case is the specification of a set of actions performed by a system, which yields an observable result that is, typically, of value for one or more actors or other stakeholders of the system.
node class UseCase extends BehavioredClassifier;
edge class UseCase_include extends association
	 connect UseCase[*] -> Include[0:*];
edge class UseCase_extend extends association
	 connect UseCase[*] -> Extend[0:*];
edge class UseCase_extensionPoint extends association
	 connect UseCase[*] -> ExtensionPoint[0:*];
edge class UseCase_subject extends association
	 connect UseCase[*] -> Classifier[0:*];

//An extension point identifies a point in the behavior of a use case where that behavior can be extended by the behavior of some other (extending) use case, as specified by an extend relationship.
node class ExtensionPoint extends RedefinableElement;
edge class ExtensionPoint_useCase extends association
	 connect ExtensionPoint[*] -> UseCase[1:1];

//A classifier is a classification of instances - it describes a set of instances that have features in common. A classifier can specify a generalization hierarchy by referencing its general classifiers.
abstract node class Classifier extends RedefinableElement, Type, Namespace {
	
	isAbstract : boolean = false;
	
}
edge class Classifier_generalization extends association
	 connect Classifier[*] -> Generalization[0:*];
edge class Classifier_feature extends association
	 connect Classifier[*] -> Feature[0:*];
edge class Classifier_inheritedMember extends association
	 connect Classifier[*] -> NamedElement[0:*];
edge class Classifier_redefinedClassifier extends association
	 connect Classifier[*] -> Classifier[0:*];
edge class Classifier_general extends association
	 connect Classifier[*] -> Classifier[0:*];
edge class Classifier_substitution extends association
	 connect Classifier[*] -> Substitution[0:*];
edge class Classifier_attribute extends association
	 connect Classifier[*] -> Property[0:*];
edge class Classifier_ownedUseCase extends association
	 connect Classifier[*] -> UseCase[0:*];
edge class Classifier_useCase extends association
	 connect Classifier[*] -> UseCase[0:*];

//A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances.
abstract node class BehavioralFeature extends Feature, Namespace {
	
	isAbstract : boolean = false;
	concurrency : CallConcurrencyKind = CallConcurrencyKind::sequential;
	
}
edge class BehavioralFeature_ownedParameter extends association
	 connect BehavioralFeature[*] -> Parameter[0:*];
edge class BehavioralFeature_method extends association
	 connect BehavioralFeature[*] -> Behavior[0:*];
edge class BehavioralFeature_raisedException extends association
	 connect BehavioralFeature[*] -> Type[0:*];

//A call event models the receipt by an object of a message invoking a call of an operation.
node class CallEvent extends MessageEvent;
edge class CallEvent_operation extends association
	 connect CallEvent[*] -> Operation[1:1];

//A change event models a change in the system configuration that makes a condition true.
node class ChangeEvent extends Event;
edge class ChangeEvent_changeExpression extends association
	 connect ChangeEvent[*] -> ValueSpecification[1:1];

//An interface is a kind of classifier that represents a declaration of a set of coherent public features and obligations. An interface specifies a contract; any instance of a classifier that realizes the interface must fulfill that contract. The obligations that may be associated with an interface are in the form of various kinds of constraints (such as pre- and post-conditions) or protocol specifications, which may impose ordering restrictions on interactions through the interface.
node class Interface extends Classifier;
edge class Interface_ownedAttribute extends association
	 connect Interface[*] -> Property[0:*];
edge class Interface_ownedOperation extends association
	 connect Interface[*] -> Operation[0:*];
edge class Interface_nestedClassifier extends association
	 connect Interface[*] -> Classifier[0:*];
edge class Interface_redefinedInterface extends association
	 connect Interface[*] -> Interface[0:*];
edge class Interface_ownedReception extends association
	 connect Interface[*] -> Reception[0:*];

//A reception is a declaration stating that a classifier is prepared to react to the receipt of a signal. A reception designates a signal and specifies the expected behavioral response. The details of handling a signal are specified by the behavior associated with the reception or the classifier itself.
node class Reception extends BehavioralFeature;
edge class Reception_signal extends association
	 connect Reception[*] -> Signal[0:1];

//A signal is a specification of send request instances communicated between objects. The receiving object handles the received request instances as specified by its receptions. The data carried by a send request (which was passed to it by the send invocation occurrence that caused that request) are represented as attributes of the signal. A signal is defined independently of the classifiers handling the signal occurrence.
node class Signal extends Classifier;
edge class Signal_ownedAttribute extends association
	 connect Signal[*] -> Property[0:*];

//A signal event represents the receipt of an asynchronous signal instance. A signal event may, for example, cause a state machine to trigger a transition.
node class SignalEvent extends MessageEvent;
edge class SignalEvent_signal extends association
	 connect SignalEvent[*] -> Signal[1:1];

//A message event specifies the receipt by an object of either a call or a signal.
abstract node class MessageEvent extends Event;

//A transition trigger associated with an any receive event specifies that the transition is to be triggered by the receipt of any message that is not explicitly referenced in another transition from the same vertex.
node class AnyReceiveEvent extends MessageEvent;

//A behaviored classifier may have an interface realization.
abstract node class BehavioredClassifier extends Classifier;
edge class BehavioredClassifier_ownedBehavior extends association
	 connect BehavioredClassifier[*] -> Behavior[0:*];
edge class BehavioredClassifier_classifierBehavior extends association
	 connect BehavioredClassifier[*] -> Behavior[0:1];
edge class BehavioredClassifier_interfaceRealization extends association
	 connect BehavioredClassifier[*] -> InterfaceRealization[0:*];
edge class BehavioredClassifier_ownedTrigger extends association
	 connect BehavioredClassifier[*] -> Trigger[0:*];

//An event is the specification of some occurrence that may potentially trigger effects by an object.
abstract node class Event extends PackageableElement;

//An operation is a behavioral feature of a classifier that specifies the name, type, parameters, and constraints for invoking an associated behavior.
node class Operation extends BehavioralFeature;
edge class Operation_lower extends attribute
	 connect Operation[*] -> Integer[0:1];
edge class Operation_upper extends attribute
	 connect Operation[*] -> UnlimitedNatural[0:1];
edge class Operation_class extends association
	 connect Operation[*] -> Class[0:1];
edge class Operation_precondition extends association
	 connect Operation[*] -> Constraint[0:*];
edge class Operation_postcondition extends association
	 connect Operation[*] -> Constraint[0:*];
edge class Operation_redefinedOperation extends association
	 connect Operation[*] -> Operation[0:*];
edge class Operation_datatype extends association
	 connect Operation[*] -> DataType[0:1];
edge class Operation_bodyCondition extends association
	 connect Operation[*] -> Constraint[0:1];
edge class Operation_type extends association
	 connect Operation[*] -> Type[0:1];
edge class Operation_ownedParameter extends association
	 connect Operation[*] -> Parameter[0:*];
edge class Operation_raisedException extends association
	 connect Operation[*] -> Type[0:*];
edge class Operation_interface extends association
	 connect Operation[*] -> Interface[0:1];

//A fork node is a control node that splits a flow into multiple concurrent flows.
node class ForkNode extends ControlNode;

//A flow final node is a final node that terminates a flow.
node class FlowFinalNode extends FinalNode;

//A central buffer node is an object node for managing flows from multiple sources and destinations.
node class CentralBufferNode extends ObjectNode;

//An activity partition is a kind of activity group for identifying actions that have some characteristic in common.
node class ActivityPartition extends NamedElement, ActivityGroup;
edge class ActivityPartition_edge extends association
	 connect ActivityPartition[*] -> ActivityEdge[0:*];
edge class ActivityPartition_node extends association
	 connect ActivityPartition[*] -> ActivityNode[0:*];
edge class ActivityPartition_subpartition extends association
	 connect ActivityPartition[*] -> ActivityPartition[0:*];
edge class ActivityPartition_superPartition extends association
	 connect ActivityPartition[*] -> ActivityPartition[0:1];
edge class ActivityPartition_represents extends association
	 connect ActivityPartition[*] -> Element[0:1];

//An activity edge is an abstract class for directed connections between two activity nodes.
abstract node class ActivityEdge extends RedefinableElement;
edge class ActivityEdge_activity extends association
	 connect ActivityEdge[*] -> Activity[0:1];
edge class ActivityEdge_source extends association
	 connect ActivityEdge[*] -> ActivityNode[1:1];
edge class ActivityEdge_target extends association
	 connect ActivityEdge[*] -> ActivityNode[1:1];
edge class ActivityEdge_redefinedEdge extends association
	 connect ActivityEdge[*] -> ActivityEdge[0:*];
edge class ActivityEdge_inPartition extends association
	 connect ActivityEdge[*] -> ActivityPartition[0:*];
edge class ActivityEdge_guard extends association
	 connect ActivityEdge[*] -> ValueSpecification[1:1];
edge class ActivityEdge_inGroup extends association
	 connect ActivityEdge[*] -> ActivityGroup[0:*];

//A merge node is a control node that brings together multiple alternate flows. It is not used to synchronize concurrent flows but to accept one among several alternate flows.
node class MergeNode extends ControlNode;

//A decision node is a control node that chooses between outgoing flows.
node class DecisionNode extends ControlNode;
edge class DecisionNode_decisionInput extends association
	 connect DecisionNode[*] -> Behavior[0:1];

//A final node is an abstract control node at which a flow in an activity stops.
abstract node class FinalNode extends ControlNode;

//An activity final node is a final node that stops all flows in an activity.
node class ActivityFinalNode extends FinalNode;

//A join node is a control node that synchronizes multiple flows.
node class JoinNode extends ControlNode;

//A port is a property of a classifier that specifies a distinct interaction point between that classifier and its environment or between the (behavior of the) classifier and its internal parts. Ports are connected to properties of the classifier by connectors through which requests can be made to invoke the behavioral features of a classifier. A Port may specify the services a classifier provides (offers) to its environment as well as the services that a classifier expects (requires) of its environment.
node class Port extends Property;
edge class Port_required extends association
	 connect Port[*] -> Interface[0:*];
edge class Port_redefinedPort extends association
	 connect Port[*] -> Port[0:*];
edge class Port_provided extends association
	 connect Port[*] -> Interface[0:*];

//A classifier has the ability to own ports as specific and type checked interaction points.
abstract node class EncapsulatedClassifier extends StructuredClassifier;
edge class EncapsulatedClassifier_ownedPort extends association
	 connect EncapsulatedClassifier[*] -> Port[0:*];

//A connector end is an endpoint of a connector, which attaches the connector to a connectable element. Each connector end is part of one connector.
node class ConnectorEnd extends MultiplicityElement;
edge class ConnectorEnd_definingEnd extends association
	 connect ConnectorEnd[*] -> Property[0:1];
edge class ConnectorEnd_role extends association
	 connect ConnectorEnd[*] -> ConnectableElement[1:1];
edge class ConnectorEnd_partWithPort extends association
	 connect ConnectorEnd[*] -> Property[0:1];

//A component represents a modular part of a system that encapsulates its contents and whose manifestation is replaceable within its environment.
node class Component extends Class {
	
	isIndirectlyInstantiated : boolean = true;
	
}
edge class Component_required extends association
	 connect Component[*] -> Interface[0:*];
edge class Component_provided extends association
	 connect Component[*] -> Interface[0:*];
edge class Component_realization extends association
	 connect Component[*] -> ComponentRealization[0:*];

//The realization concept is specialized to (optionally) define the classifiers that realize the contract offered by a component in terms of its provided and required interfaces. The component forms an abstraction from these various classifiers.
node class ComponentRealization extends Realization;
edge class ComponentRealization_abstraction extends association
	 connect ComponentRealization[*] -> Component[0:1];
edge class ComponentRealization_realizingClassifier extends association
	 connect ComponentRealization[*] -> Classifier[1:1];

//Specifies a link that enables communication between two or more instances. This link may be an instance of an association, or it may represent the possibility of the instances being able to communicate because their identities are known by virtue of being passed in as parameters, held in variables or slots, or because the communicating instances are the same instance. The link may be realized by something as simple as a pointer or by something as complex as a network connection. In contrast to associations, which specify links between any instance of the associated classifiers, connectors specify links between instances playing the connected parts only.
node class Connector extends Feature;
edge class Connector_type extends association
	 connect Connector[*] -> Association[0:1];
edge class Connector_redefinedConnector extends association
	 connect Connector[*] -> Connector[0:*];
edge class Connector_end extends association
	 connect Connector[*] -> ConnectorEnd[2:*];
edge class Connector_kind extends attribute
	 connect Connector[*] -> ConnectorKind_Value[0:1];
edge class Connector_contract extends association
	 connect Connector[*] -> Behavior[0:*];

//A manifestation is the concrete physical rendering of one or more model elements by an artifact.
node class Manifestation extends Abstraction;
edge class Manifestation_utilizedElement extends association
	 connect Manifestation[*] -> PackageableElement[1:1];

//A deployment is the allocation of an artifact or artifact instance to a deployment target.
node class Deployment extends Dependency;
edge class Deployment_deployedArtifact extends association
	 connect Deployment[*] -> DeployedArtifact[0:*];
edge class Deployment_location extends association
	 connect Deployment[*] -> DeploymentTarget[1:1];

//A node is computational resource upon which artifacts may be deployed for execution. Nodes can be interconnected through communication paths to define network structures.
node class Node_ extends Class, DeploymentTarget;
edge class Node_nestedNode extends association
	 connect Node_[*] -> Node_[0:*];

//A device is a physical computational resource with processing capability upon which artifacts may be deployed for execution. Devices may be complex (i.e., they may consist of other devices).
node class Device extends Node_;

//An execution environment is a node that offers an execution environment for specific types of components that are deployed on it in the form of executable artifacts.
node class ExecutionEnvironment extends Node_;

//A deployment target is the location for a deployed artifact.
abstract node class DeploymentTarget extends NamedElement;
edge class DeploymentTarget_deployment extends association
	 connect DeploymentTarget[*] -> Deployment[0:*];
edge class DeploymentTarget_deployedElement extends association
	 connect DeploymentTarget[*] -> PackageableElement[0:*];

//A deployed artifact is an artifact or artifact instance that has been deployed to a deployment target.
abstract node class DeployedArtifact extends NamedElement;

//A communication path is an association between two deployment targets, through which they are able to exchange signals and messages.
node class CommunicationPath extends Association;

//A property is a structural feature of a classifier that characterizes instances of the classifier. A property related by ownedAttribute to a classifier (other than an association) represents an attribute and might also represent an association end. It relates an instance of the class to a value or set of values of the type of the attribute. A property related by memberEnd or its specializations to an association represents an end of the association. The type of the property is the type of the end of the association.
node class Property extends ConnectableElement, StructuralFeature, DeploymentTarget;
edge class Property_default extends attribute
	 connect Property[*] -> String[0:1];
edge class Property_class extends association
	 connect Property[*] -> Class[0:1];
edge class Property_redefinedProperty extends association
	 connect Property[*] -> Property[0:*];
edge class Property_owningAssociation extends association
	 connect Property[*] -> Association[0:1];
edge class Property_datatype extends association
	 connect Property[*] -> DataType[0:1];
edge class Property_defaultValue extends association
	 connect Property[*] -> ValueSpecification[0:1];
edge class Property_opposite extends association
	 connect Property[*] -> Property[0:1];
edge class Property_subsettedProperty extends association
	 connect Property[*] -> Property[0:*];
edge class Property_association extends association
	 connect Property[*] -> Association[0:1];

//An instance specification is a model element that represents an instance in a modeled system.
node class InstanceSpecification extends PackageableElement, DeploymentTarget, DeployedArtifact;
edge class InstanceSpecification_classifier extends association
	 connect InstanceSpecification[*] -> Classifier[0:*];
edge class InstanceSpecification_slot extends association
	 connect InstanceSpecification[*] -> Slot[0:*];
edge class InstanceSpecification_specification extends association
	 connect InstanceSpecification[*] -> ValueSpecification[0:1];

//An artifact is the specification of a physical piece of information that is used or produced by a software development process, or by deployment and operation of a system. Examples of artifacts include model files, source files, scripts, and binary executable files, a table in a database system, a development deliverable, or a word-processing document, a mail message.
node class Artifact extends Classifier, DeployedArtifact;
edge class Artifact_fileName extends attribute
	 connect Artifact[*] -> String[0:1];
edge class Artifact_nestedArtifact extends association
	 connect Artifact[*] -> Artifact[0:*];
edge class Artifact_manifestation extends association
	 connect Artifact[*] -> Manifestation[0:*];
edge class Artifact_ownedOperation extends association
	 connect Artifact[*] -> Operation[0:*];
edge class Artifact_ownedAttribute extends association
	 connect Artifact[*] -> Property[0:*];

//An interaction use refers to an interaction. The interaction use is a shorthand for copying the contents of the referenced interaction where the interaction use is. To be accurate the copying must take into account substituting parameters with arguments and connect the formal gates with the actual ones.
node class InteractionUse extends InteractionFragment;
edge class InteractionUse_refersTo extends association
	 connect InteractionUse[*] -> Interaction[1:1];
edge class InteractionUse_actualGate extends association
	 connect InteractionUse[*] -> Gate[0:*];
edge class InteractionUse_argument extends association
	 connect InteractionUse[*] -> Action[0:*];

//A part decomposition is a description of the internal interactions of one lifeline relative to an interaction.
node class PartDecomposition extends InteractionUse;

//An interaction operand is contained in a combined fragment. An interaction operand represents one operand of the expression given by the enclosing combined fragment.
node class InteractionOperand extends InteractionFragment, Namespace;
edge class InteractionOperand_guard extends association
	 connect InteractionOperand[*] -> InteractionConstraint[0:1];
edge class InteractionOperand_fragment extends association
	 connect InteractionOperand[*] -> InteractionFragment[0:*];

//An interaction constraint is a Boolean expression that guards an operand in a combined fragment.
node class InteractionConstraint extends Constraint;
edge class InteractionConstraint_minint extends association
	 connect InteractionConstraint[*] -> ValueSpecification[0:1];
edge class InteractionConstraint_maxint extends association
	 connect InteractionConstraint[*] -> ValueSpecification[0:1];

//A gate is a connection point for relating a message outside an interaction fragment with a message inside the interaction fragment.
node class Gate extends MessageEnd;

//A combined fragment defines an expression of interaction fragments. A combined fragment is defined by an interaction operator and corresponding interaction operands. Through the use of combined fragments the user will be able to describe a number of traces in a compact and concise manner.
node class CombinedFragment extends InteractionFragment;
edge class CombinedFragment_operand extends association
	 connect CombinedFragment[*] -> InteractionOperand[1:*];
edge class CombinedFragment_cfragmentGate extends association
	 connect CombinedFragment[*] -> Gate[0:*];

//An interaction is a unit of behavior that focuses on the observable exchange of information between connectable elements.
node class Interaction extends InteractionFragment, Behavior;
edge class Interaction_lifeline extends association
	 connect Interaction[*] -> Lifeline[0:*];
edge class Interaction_message extends association
	 connect Interaction[*] -> Message[0:*];
edge class Interaction_fragment extends association
	 connect Interaction[*] -> InteractionFragment[0:*];
edge class Interaction_action extends association
	 connect Interaction[*] -> Action[0:*];
edge class Interaction_formalGate extends association
	 connect Interaction[*] -> Gate[0:*];

//A lifeline represents an individual participant in the interaction. While parts and structural features may have multiplicity greater than 1, lifelines represent only one interacting entity.
node class Lifeline extends NamedElement;
edge class Lifeline_coveredBy extends association
	 connect Lifeline[*] -> InteractionFragment[0:*];
edge class Lifeline_represents extends association
	 connect Lifeline[*] -> ConnectableElement[0:1];
edge class Lifeline_interaction extends association
	 connect Lifeline[*] -> Interaction[1:1];
edge class Lifeline_selector extends association
	 connect Lifeline[*] -> ValueSpecification[0:1];
edge class Lifeline_decomposedAs extends association
	 connect Lifeline[*] -> PartDecomposition[0:1];

//A continuation is a syntactic way to define continuations of different branches of an alternative combined fragment. Continuations is intuitively similar to labels representing intermediate points in a flow of control.
node class Continuation extends InteractionFragment {
	
	setting : boolean = true;
	
}

//InteractionFragment is an abstract notion of the most general interaction unit. An interaction fragment is a piece of an interaction. Each interaction fragment is conceptually like an interaction by itself.
abstract node class InteractionFragment extends NamedElement;
edge class InteractionFragment_covered extends association
	 connect InteractionFragment[*] -> Lifeline[0:*];
edge class InteractionFragment_generalOrdering extends association
	 connect InteractionFragment[*] -> GeneralOrdering[0:*];
edge class InteractionFragment_enclosingInteraction extends association
	 connect InteractionFragment[*] -> Interaction[0:1];
edge class InteractionFragment_enclosingOperand extends association
	 connect InteractionFragment[*] -> InteractionOperand[0:1];

//A consider ignore fragment is a kind of combined fragment that is used for the consider and ignore cases, which require lists of pertinent messages to be specified.
node class ConsiderIgnoreFragment extends CombinedFragment;
edge class ConsiderIgnoreFragment_message extends association
	 connect ConsiderIgnoreFragment[*] -> NamedElement[0:*];

//A create object action is an action that creates an object that conforms to a statically specified classifier and puts it on an output pin at runtime.
node class CreateObjectAction extends Action;
edge class CreateObjectAction_classifier extends association
	 connect CreateObjectAction[*] -> Classifier[1:1];
edge class CreateObjectAction_result extends association
	 connect CreateObjectAction[*] -> OutputPin[1:1];

//A destroy object action is an action that destroys objects.
node class DestroyObjectAction extends Action;
edge class DestroyObjectAction_target extends association
	 connect DestroyObjectAction[*] -> InputPin[1:1];

//A test identity action is an action that tests if two values are identical objects.
node class TestIdentityAction extends Action;
edge class TestIdentityAction_first extends association
	 connect TestIdentityAction[*] -> InputPin[1:1];
edge class TestIdentityAction_second extends association
	 connect TestIdentityAction[*] -> InputPin[1:1];
edge class TestIdentityAction_result extends association
	 connect TestIdentityAction[*] -> OutputPin[1:1];

//A read self action is an action that retrieves the host object of an action.
node class ReadSelfAction extends Action;
edge class ReadSelfAction_result extends association
	 connect ReadSelfAction[*] -> OutputPin[1:1];

//StructuralFeatureAction is an abstract class for all structural feature actions.
abstract node class StructuralFeatureAction extends Action;
edge class StructuralFeatureAction_structuralFeature extends association
	 connect StructuralFeatureAction[*] -> StructuralFeature[1:1];
edge class StructuralFeatureAction_object extends association
	 connect StructuralFeatureAction[*] -> InputPin[1:1];

//A read structural feature action is a structural feature action that retrieves the values of a structural feature.
node class ReadStructuralFeatureAction extends StructuralFeatureAction;
edge class ReadStructuralFeatureAction_result extends association
	 connect ReadStructuralFeatureAction[*] -> OutputPin[1:1];

//WriteStructuralFeatureAction is an abstract class for structural feature actions that change structural feature values.
abstract node class WriteStructuralFeatureAction extends StructuralFeatureAction;
edge class WriteStructuralFeatureAction_value extends association
	 connect WriteStructuralFeatureAction[*] -> InputPin[1:1];

//A clear structural feature action is a structural feature action that removes all values of a structural feature.
node class ClearStructuralFeatureAction extends StructuralFeatureAction;

//A remove structural feature value action is a write structural feature action that removes values from structural features.
node class RemoveStructuralFeatureValueAction extends WriteStructuralFeatureAction {
	
	isRemoveDuplicates : boolean = false;
	
}
edge class RemoveStructuralFeatureValueAction_removeAt extends association
	 connect RemoveStructuralFeatureValueAction[*] -> InputPin[0:1];

//An add structural feature value action is a write structural feature action for adding values to a structural feature.
node class AddStructuralFeatureValueAction extends WriteStructuralFeatureAction {
	
	isReplaceAll : boolean = false;
	
}
edge class AddStructuralFeatureValueAction_insertAt extends association
	 connect AddStructuralFeatureValueAction[*] -> InputPin[0:1];

//LinkAction is an abstract class for all link actions that identify their links by the objects at the ends of the links and by the qualifiers at ends of the links.
abstract node class LinkAction extends Action;
edge class LinkAction_endData extends association
	 connect LinkAction[*] -> LinkEndData[2:*];
edge class LinkAction_inputValue extends association
	 connect LinkAction[*] -> InputPin[1:*];

//A link end data is not an action. It is an element that identifies links. It identifies one end of a link to be read or written by the children of a link action. A link cannot be passed as a runtime value to or from an action. Instead, a link is identified by its end objects and qualifier values, if any. This requires more than one piece of data, namely, the statically-specified end in the user model, the object on the end, and the qualifier values for that end, if any. These pieces are brought together around a link end data. Each association end is identified separately with an instance of the LinkEndData class.
node class LinkEndData extends Element;
edge class LinkEndData_value extends association
	 connect LinkEndData[*] -> InputPin[0:1];
edge class LinkEndData_end extends association
	 connect LinkEndData[*] -> Property[1:1];

//A read link action is a link action that navigates across associations to retrieve objects on one end.
node class ReadLinkAction extends LinkAction;
edge class ReadLinkAction_result extends association
	 connect ReadLinkAction[*] -> OutputPin[1:1];

//A link end creation data is not an action. It is an element that identifies links. It identifies one end of a link to be created by a create link action.
node class LinkEndCreationData extends LinkEndData {
	
	isReplaceAll : boolean = false;
	
}
edge class LinkEndCreationData_insertAt extends association
	 connect LinkEndCreationData[*] -> InputPin[0:1];

//A create link action is a write link action for creating links.
node class CreateLinkAction extends WriteLinkAction;
edge class CreateLinkAction_endData extends association
	 connect CreateLinkAction[*] -> LinkEndCreationData[2:*];

//A destroy link action is a write link action that destroys links and link objects.
node class DestroyLinkAction extends WriteLinkAction;
edge class DestroyLinkAction_endData extends association
	 connect DestroyLinkAction[*] -> LinkEndDestructionData[2:*];

//WriteLinkAction is an abstract class for link actions that create and destroy links.
abstract node class WriteLinkAction extends LinkAction;

//A clear association action is an action that destroys all links of an association in which a particular object participates.
node class ClearAssociationAction extends Action;
edge class ClearAssociationAction_object extends association
	 connect ClearAssociationAction[*] -> InputPin[1:1];
edge class ClearAssociationAction_association extends association
	 connect ClearAssociationAction[*] -> Association[1:1];

//A broadcast signal action is an action that transmits a signal instance to all the potential target objects in the system, which may cause the firing of a state machine transitions or the execution of associated activities of a target object. The argument values are available to the execution of associated behaviors. The requestor continues execution immediately after the signals are sent out. It does not wait for receipt. Any reply messages are ignored and are not transmitted to the requestor.
node class BroadcastSignalAction extends InvocationAction;
edge class BroadcastSignalAction_signal extends association
	 connect BroadcastSignalAction[*] -> Signal[1:1];

//A send object action is an action that transmits an object to the target object, where it may invoke behavior such as the firing of state machine transitions or the execution of an activity. The value of the object is available to the execution of invoked behaviors. The requestor continues execution immediately. Any reply message is ignored and is not transmitted to the requestor.
node class SendObjectAction extends InvocationAction;
edge class SendObjectAction_target extends association
	 connect SendObjectAction[*] -> InputPin[1:1];
edge class SendObjectAction_request extends association
	 connect SendObjectAction[*] -> InputPin[1:1];

//A link end destruction data is not an action. It is an element that identifies links. It identifies one end of a link to be destroyed by destroy link action.
node class LinkEndDestructionData extends LinkEndData {
	
	isDestroyDuplicates : boolean = false;
	
}
edge class LinkEndDestructionData_destroyAt extends association
	 connect LinkEndDestructionData[*] -> InputPin[0:1];

//A value specification action is an action that evaluates a value specification.
node class ValueSpecificationAction extends Action;
edge class ValueSpecificationAction_value extends association
	 connect ValueSpecificationAction[*] -> ValueSpecification[1:1];
edge class ValueSpecificationAction_result extends association
	 connect ValueSpecificationAction[*] -> OutputPin[1:1];

//A time expression defines a value specification that represents a time value.
node class TimeExpression extends ValueSpecification;
edge class TimeExpression_expr extends association
	 connect TimeExpression[*] -> ValueSpecification[0:1];
edge class TimeExpression_observation extends association
	 connect TimeExpression[*] -> Observation[0:*];

//Duration defines a value specification that specifies the temporal distance between two time instants.
node class Duration extends ValueSpecification;
edge class Duration_expr extends association
	 connect Duration[*] -> ValueSpecification[0:1];
edge class Duration_observation extends association
	 connect Duration[*] -> Observation[0:*];

//A duration interval defines the range between two durations.
node class DurationInterval extends Interval;
edge class DurationInterval_min extends association
	 connect DurationInterval[*] -> Duration[1:1];
edge class DurationInterval_max extends association
	 connect DurationInterval[*] -> Duration[1:1];

//A time constraint is a constraint that refers to a time interval.
node class TimeConstraint extends IntervalConstraint;
edge class TimeConstraint_specification extends association
	 connect TimeConstraint[*] -> TimeInterval[1:1];
edge class TimeConstraint_firstEvent extends attribute
	 connect TimeConstraint[*] -> Boolean[0:1];

//A time interval defines the range between two time expressions.
node class TimeInterval extends Interval;
edge class TimeInterval_max extends association
	 connect TimeInterval[*] -> TimeExpression[1:1];
edge class TimeInterval_min extends association
	 connect TimeInterval[*] -> TimeExpression[1:1];

//A duration constraint is a constraint that refers to a duration interval.
node class DurationConstraint extends IntervalConstraint;
edge class DurationConstraint_specification extends association
	 connect DurationConstraint[*] -> DurationInterval[1:1];
edge class DurationConstraint_firstEvent extends attribute
	 connect DurationConstraint[*] -> Boolean[0:2];

//An interval constraint is a constraint that refers to an interval.
node class IntervalConstraint extends Constraint;
edge class IntervalConstraint_specification extends association
	 connect IntervalConstraint[*] -> Interval[1:1];

//An interval defines the range between two value specifications.
node class Interval extends ValueSpecification;
edge class Interval_min extends association
	 connect Interval[*] -> ValueSpecification[1:1];
edge class Interval_max extends association
	 connect Interval[*] -> ValueSpecification[1:1];

//Observation is a superclass of TimeObservation and DurationObservation in order for TimeExpression and Duration to refer to either in a simple way.
abstract node class Observation extends PackageableElement;

//A time observation is a reference to a time instant during an execution. It points out the element in the model to observe and whether the observation is when this model element is entered or when it is exited.
node class TimeObservation extends Observation {
	
	firstEvent : boolean = true;
	
}
edge class TimeObservation_event extends association
	 connect TimeObservation[*] -> NamedElement[1:1];

//A duration observation is a reference to a duration during an execution. It points out the element(s) in the model to observe and whether the observations are when this model element is entered or when it is exited.
node class DurationObservation extends Observation;
edge class DurationObservation_event extends association
	 connect DurationObservation[*] -> NamedElement[1:2];
edge class DurationObservation_firstEvent extends attribute
	 connect DurationObservation[*] -> Boolean[0:2];

//InvocationAction is an abstract class for the various actions that invoke behavior.
abstract node class InvocationAction extends Action;
edge class InvocationAction_argument extends association
	 connect InvocationAction[*] -> InputPin[0:*];
edge class InvocationAction_onPort extends association
	 connect InvocationAction[*] -> Port[0:1];

//A trigger relates an event to a behavior that may affect an instance of the classifier.
node class Trigger extends NamedElement;
edge class Trigger_event extends association
	 connect Trigger[*] -> Event[1:1];
edge class Trigger_port extends association
	 connect Trigger[*] -> Port[0:*];

//State machines can be used to express the behavior of part of a system. Behavior is modeled as a traversal of a graph of state nodes interconnected by one or more joined transition arcs that are triggered by the dispatching of series of (event) occurrences. During this traversal, the state machine executes a series of activities associated with various elements of the state machine.
node class StateMachine extends Behavior;
edge class StateMachine_region extends association
	 connect StateMachine[*] -> Region[1:*];
edge class StateMachine_connectionPoint extends association
	 connect StateMachine[*] -> Pseudostate[0:*];
edge class StateMachine_extendedStateMachine extends association
	 connect StateMachine[*] -> StateMachine[0:*];
edge class StateMachine_submachineState extends association
	 connect StateMachine[*] -> State[0:*];

//A state models a situation during which some (usually implicit) invariant condition holds.
node class State extends Vertex, RedefinableElement, Namespace;
edge class State_submachine extends association
	 connect State[*] -> StateMachine[0:1];
edge class State_connection extends association
	 connect State[*] -> ConnectionPointReference[0:*];
edge class State_redefinedState extends association
	 connect State[*] -> State[0:1];
edge class State_region extends association
	 connect State[*] -> Region[0:*];
edge class State_redefinitionContext extends association
	 connect State[*] -> Classifier[1:1];
edge class State_stateInvariant extends association
	 connect State[*] -> Constraint[0:1];
edge class State_entry extends association
	 connect State[*] -> Behavior[0:1];
edge class State_exit extends association
	 connect State[*] -> Behavior[0:1];
edge class State_doActivity extends association
	 connect State[*] -> Behavior[0:1];
edge class State_connectionPoint extends association
	 connect State[*] -> Pseudostate[0:*];
edge class State_deferrableTrigger extends association
	 connect State[*] -> Trigger[0:*];

//A transition is a directed relationship between a source vertex and a target vertex. It may be part of a compound transition, which takes the state machine from one state configuration to another, representing the complete response of the state machine to an occurrence of an event of a particular type.
node class Transition extends RedefinableElement, Namespace;
edge class Transition_container extends association
	 connect Transition[*] -> Region[1:1];
edge class Transition_source extends association
	 connect Transition[*] -> Vertex[1:1];
edge class Transition_target extends association
	 connect Transition[*] -> Vertex[1:1];
edge class Transition_redefinedTransition extends association
	 connect Transition[*] -> Transition[0:1];
edge class Transition_guard extends association
	 connect Transition[*] -> Constraint[0:1];
edge class Transition_redefinitionContext extends association
	 connect Transition[*] -> Classifier[1:1];
edge class Transition_effect extends association
	 connect Transition[*] -> Behavior[0:1];
edge class Transition_trigger extends association
	 connect Transition[*] -> Trigger[0:*];

//A vertex is an abstraction of a node in a state machine graph. In general, it can be the source or destination of any number of transitions.
abstract node class Vertex extends NamedElement;
edge class Vertex_container extends association
	 connect Vertex[*] -> Region[0:1];
edge class Vertex_outgoing extends association
	 connect Vertex[*] -> Transition[0:*];
edge class Vertex_incoming extends association
	 connect Vertex[*] -> Transition[0:*];

//A pseudostate is an abstraction that encompasses different types of transient vertices in the state machine graph.
node class Pseudostate extends Vertex;
edge class Pseudostate_stateMachine extends association
	 connect Pseudostate[*] -> StateMachine[0:1];
edge class Pseudostate_state extends association
	 connect Pseudostate[*] -> State[0:1];

//A special kind of state signifying that the enclosing region is completed. If the enclosing region is directly contained in a state machine and all other regions in the state machine also are completed, then it means that the entire state machine is completed.
node class FinalState extends State;

//A connection point reference represents a usage (as part of a submachine state) of an entry/exit point defined in the statemachine reference by the submachine state.
node class ConnectionPointReference extends Vertex;
edge class ConnectionPointReference_entry extends association
	 connect ConnectionPointReference[*] -> Pseudostate[0:*];
edge class ConnectionPointReference_state extends association
	 connect ConnectionPointReference[*] -> State[0:1];
edge class ConnectionPointReference_exit extends association
	 connect ConnectionPointReference[*] -> Pseudostate[0:*];

//A region is an orthogonal part of either a composite state or a state machine. It contains states and transitions.
node class Region extends RedefinableElement, Namespace;
edge class Region_subvertex extends association
	 connect Region[*] -> Vertex[0:*];
edge class Region_transition extends association
	 connect Region[*] -> Transition[0:*];
edge class Region_stateMachine extends association
	 connect Region[*] -> StateMachine[0:1];
edge class Region_state extends association
	 connect Region[*] -> State[0:1];
edge class Region_extendedRegion extends association
	 connect Region[*] -> Region[0:1];
edge class Region_redefinitionContext extends association
	 connect Region[*] -> Classifier[1:1];

//A time event specifies a point in time. At the specified time, the event occurs.
node class TimeEvent extends Event {
	
	isRelative : boolean = false;
	
}
edge class TimeEvent_when extends association
	 connect TimeEvent[*] -> ValueSpecification[1:1];

//Variables are elements for passing data between actions indirectly. A local variable stores values shared by the actions within a structured activity group but not accessible outside it. The output of an action may be written to a variable and read for the input to a subsequent action, which is effectively an indirect data flow path. Because there is no predefined relationship between actions that read and write variables, these actions must be sequenced by control flows to prevent race conditions that may occur between actions that read or write the same variable.
node class Variable extends TypedElement, MultiplicityElement;
edge class Variable_scope extends association
	 connect Variable[*] -> StructuredActivityNode[0:1];
edge class Variable_activityScope extends association
	 connect Variable[*] -> Activity[0:1];

//A structured activity node is an executable activity node that may have an expansion into subordinate nodes as an activity group. The subordinate nodes must belong to only one structured activity node, although they may be nested.
node class StructuredActivityNode extends ActivityGroup, ExecutableNode, Namespace;
edge class StructuredActivityNode_variable extends association
	 connect StructuredActivityNode[*] -> Variable[0:*];
edge class StructuredActivityNode_node extends association
	 connect StructuredActivityNode[*] -> ActivityNode[0:*];
edge class StructuredActivityNode_activity extends association
	 connect StructuredActivityNode[*] -> Activity[0:1];

//A conditional node is a structured activity node that represents an exclusive choice among some number of alternatives.
node class ConditionalNode extends StructuredActivityNode;
edge class ConditionalNode_clause extends association
	 connect ConditionalNode[*] -> Clause[1:*];

//A loop node is a structured activity node that represents a loop with setup, test, and body sections.
node class LoopNode extends StructuredActivityNode {
	
	isTestedFirst : boolean = false;
	
}
edge class LoopNode_bodyPart extends association
	 connect LoopNode[*] -> ExecutableNode[0:*];
edge class LoopNode_setupPart extends association
	 connect LoopNode[*] -> ExecutableNode[0:*];
edge class LoopNode_decider extends association
	 connect LoopNode[*] -> OutputPin[1:1];
edge class LoopNode_test extends association
	 connect LoopNode[*] -> ExecutableNode[0:*];

//A clause is an element that represents a single branch of a conditional construct, including a test and a body section. The body section is executed only if (but not necessarily if) the test section evaluates true.
node class Clause extends Element;
edge class Clause_test extends association
	 connect Clause[*] -> ExecutableNode[0:*];
edge class Clause_body extends association
	 connect Clause[*] -> ExecutableNode[0:*];
edge class Clause_predecessorClause extends association
	 connect Clause[*] -> Clause[0:*];
edge class Clause_successorClause extends association
	 connect Clause[*] -> Clause[0:*];
edge class Clause_decider extends association
	 connect Clause[*] -> OutputPin[1:1];

//An activity is the specification of parameterized behavior as the coordinated sequencing of subordinate units whose individual elements are actions.
node class Activity extends Behavior {
	
	isReadOnly : boolean = false;
	
}
edge class Activity_edge extends association
	 connect Activity[*] -> ActivityEdge[0:*];
edge class Activity_partition extends association
	 connect Activity[*] -> ActivityPartition[0:*];
edge class Activity_structuredNode extends association
	 connect Activity[*] -> StructuredActivityNode[0:*];
edge class Activity_variable extends association
	 connect Activity[*] -> Variable[0:*];
edge class Activity_group extends association
	 connect Activity[*] -> ActivityGroup[0:*];
edge class Activity_node extends association
	 connect Activity[*] -> ActivityNode[0:*];

//ActivityNode is an abstract class for points in the flow of an activity connected by edges.
abstract node class ActivityNode extends RedefinableElement;
edge class ActivityNode_outgoing extends association
	 connect ActivityNode[*] -> ActivityEdge[0:*];
edge class ActivityNode_incoming extends association
	 connect ActivityNode[*] -> ActivityEdge[0:*];
edge class ActivityNode_redefinedNode extends association
	 connect ActivityNode[*] -> ActivityNode[0:*];
edge class ActivityNode_inPartition extends association
	 connect ActivityNode[*] -> ActivityPartition[0:*];
edge class ActivityNode_inStructuredNode extends association
	 connect ActivityNode[*] -> StructuredActivityNode[0:1];
edge class ActivityNode_inGroup extends association
	 connect ActivityNode[*] -> ActivityGroup[0:*];
edge class ActivityNode_activity extends association
	 connect ActivityNode[*] -> Activity[0:1];

//An executable node is an abstract class for activity nodes that may be executed. It is used as an attachment point for exception handlers.
abstract node class ExecutableNode extends ActivityNode;

//A sequence node is a structured activity node that executes its actions in order.
node class SequenceNode extends StructuredActivityNode;
edge class SequenceNode_executableNode extends association
	 connect SequenceNode[*] -> ExecutableNode[0:*];

//An action is a named element that is the fundamental unit of executable functionality. The execution of an action represents some transformation or processing in the modeled system, be it a computer system or otherwise.
abstract node class Action extends ExecutableNode;
edge class Action_output extends association
	 connect Action[*] -> OutputPin[0:*];
edge class Action_input extends association
	 connect Action[*] -> InputPin[0:*];
edge class Action_context extends association
	 connect Action[*] -> Classifier[0:1];

//ActivityGroup is an abstract class for defining sets of nodes and edges in an activity.
abstract node class ActivityGroup extends Element;
edge class ActivityGroup_subgroup extends association
	 connect ActivityGroup[*] -> ActivityGroup[0:*];
edge class ActivityGroup_superGroup extends association
	 connect ActivityGroup[*] -> ActivityGroup[0:1];
edge class ActivityGroup_containedEdge extends association
	 connect ActivityGroup[*] -> ActivityEdge[0:*];
edge class ActivityGroup_containedNode extends association
	 connect ActivityGroup[*] -> ActivityNode[0:*];
edge class ActivityGroup_inActivity extends association
	 connect ActivityGroup[*] -> Activity[0:1];

//An input pin is a pin that holds input values to be consumed by an action.
node class InputPin extends Pin;

//An output pin is a pin that holds output values produced by an action.
node class OutputPin extends Pin;

//A stereotype defines how an existing metaclass may be extended, and enables the use of platform or domain specific terminology or notation in place of, or in addition to, the ones used for the extended metaclass.
node class Stereotype extends Class;
edge class Stereotype_icon extends association
	 connect Stereotype[*] -> Image[0:*];

//A profile defines limited extensions to a reference metamodel with the purpose of adapting the metamodel to a specific platform or domain.
node class Profile extends Package;
edge class Profile_ownedStereotype extends association
	 connect Profile[*] -> Stereotype[0:*];
edge class Profile_metaclassReference extends association
	 connect Profile[*] -> ElementImport[0:*];
edge class Profile_metamodelReference extends association
	 connect Profile[*] -> PackageImport[0:*];

//A package is used to group elements, and provides a namespace for the grouped elements.
node class Package extends PackageableElement, Namespace;
edge class Package_packageMerge extends association
	 connect Package[*] -> PackageMerge[0:*];
edge class Package_packagedElement extends association
	 connect Package[*] -> PackageableElement[0:*];
edge class Package_ownedType extends association
	 connect Package[*] -> Type[0:*];
edge class Package_nestedPackage extends association
	 connect Package[*] -> Package[0:*];
edge class Package_nestingPackage extends association
	 connect Package[*] -> Package[0:1];
edge class Package_profileApplication extends association
	 connect Package[*] -> ProfileApplication[0:*];

//A class describes a set of objects that share the same specifications of features, constraints, and semantics.
node class Class extends BehavioredClassifier, EncapsulatedClassifier;
edge class Class_nestedClassifier extends association
	 connect Class[*] -> Classifier[0:*];
edge class Class_ownedAttribute extends association
	 connect Class[*] -> Property[0:*];
edge class Class_ownedOperation extends association
	 connect Class[*] -> Operation[0:*];
edge class Class_superClass extends association
	 connect Class[*] -> Class[0:*];
edge class Class_ownedReception extends association
	 connect Class[*] -> Reception[0:*];
edge class Class_extension extends association
	 connect Class[*] -> Extension[0:*];

//A profile application is used to show which profiles have been applied to a package.
node class ProfileApplication extends DirectedRelationship {
	
	isStrict : boolean = false;
	
}
edge class ProfileApplication_appliedProfile extends association
	 connect ProfileApplication[*] -> Profile[1:1];
edge class ProfileApplication_applyingPackage extends association
	 connect ProfileApplication[*] -> Package[1:1];

//An extension is used to indicate that the properties of a metaclass are extended through a stereotype, and gives the ability to flexibly add (and later remove) stereotypes to classes.
node class Extension extends Association {
	
	isRequired : boolean = false;
	
}
edge class Extension_metaclass extends association
	 connect Extension[*] -> Class[1:1];
edge class Extension_ownedEnd extends association
	 connect Extension[*] -> ExtensionEnd[1:1];

//Physical definition of a graphical image.
node class Image extends Element;
edge class Image_content extends attribute
	 connect Image[*] -> String[0:1];
edge class Image_location extends attribute
	 connect Image[*] -> String[0:1];
edge class Image_format extends attribute
	 connect Image[*] -> String[0:1];

//An element is a constituent of a model. As such, it has the capability of owning other elements.
abstract node class Element;
edge class Element_ownedElement extends association
	 connect Element[*] -> Element[0:*];
edge class Element_owner extends association
	 connect Element[*] -> Element[0:1];
edge class Element_ownedComment extends association
	 connect Element[*] -> Comment[0:*];

//A named element is an element in a model that may have a name.
abstract node class NamedElement extends Element;
edge class NamedElement_name extends attribute
	 connect NamedElement[*] -> String[0:1];
edge class NamedElement_visibility extends attribute
	 connect NamedElement[*] -> VisibilityKind_Value[0:1];
edge class NamedElement_qualifiedName extends attribute
	 connect NamedElement[*] -> String[0:1];
edge class NamedElement_clientDependency extends association
	 connect NamedElement[*] -> Dependency[0:*];
edge class NamedElement_namespace extends association
	 connect NamedElement[*] -> Namespace[0:1];

//An extension end is used to tie an extension to a stereotype when extending a metaclass.
node class ExtensionEnd extends Property;
edge class ExtensionEnd_type extends association
	 connect ExtensionEnd[*] -> Stereotype[1:1];
edge class ExtensionEnd_lower extends attribute
	 connect ExtensionEnd[*] -> Integer[0:1];

//VariableAction is an abstract class for actions that operate on a statically specified variable.
abstract node class VariableAction extends Action;
edge class VariableAction_variable extends association
	 connect VariableAction[*] -> Variable[1:1];

//A read variable action is a variable action that retrieves the values of a variable.
node class ReadVariableAction extends VariableAction;
edge class ReadVariableAction_result extends association
	 connect ReadVariableAction[*] -> OutputPin[1:1];

//WriteVariableAction is an abstract class for variable actions that change variable values.
abstract node class WriteVariableAction extends VariableAction;
edge class WriteVariableAction_value extends association
	 connect WriteVariableAction[*] -> InputPin[1:1];

//A clear variable action is a variable action that removes all values of a variable.
node class ClearVariableAction extends VariableAction;

//An add variable value action is a write variable action for adding values to a variable.
node class AddVariableValueAction extends WriteVariableAction {
	
	isReplaceAll : boolean = false;
	
}
edge class AddVariableValueAction_insertAt extends association
	 connect AddVariableValueAction[*] -> InputPin[0:1];

//A remove variable value action is a write variable action that removes values from variables.
node class RemoveVariableValueAction extends WriteVariableAction {
	
	isRemoveDuplicates : boolean = false;
	
}
edge class RemoveVariableValueAction_removeAt extends association
	 connect RemoveVariableValueAction[*] -> InputPin[0:1];

//A raise exception action is an action that causes an exception to occur. The input value becomes the exception object.
node class RaiseExceptionAction extends Action;
edge class RaiseExceptionAction_exception extends association
	 connect RaiseExceptionAction[*] -> InputPin[1:1];

//An action input pin is a kind of pin that executes an action to determine the values to input to another.
node class ActionInputPin extends InputPin;
edge class ActionInputPin_fromAction extends association
	 connect ActionInputPin[*] -> Action[1:1];