using JDTAST__ecore, CFG__ecore, Util;

rule CFG_handle_statements
{
	block:dom_Block;
	block -e1:dom_Block_statements-> st1:dom_Statement;
	block -e2:dom_Block_statements-> st2:dom_Statement;
	
	if { e1.index + 1 == e2.index; }

	modify {
		st1 -:org_amma_cfg_AbstractNode_toNode-> st2;
	}
}

rule CFG_handle_while
{
	while:dom_WhileStatement -cfgfalse:org_amma_cfg_AbstractNode_toNode->;
	while -:dom_WhileStatement_body-> body:dom_Statement;

	modify {
		-:org_amma_cfg_ConditionalNode_falseConditionNode<cfgfalse>->;
		while -:org_amma_cfg_ConditionalNode_trueConditionNode-> body;
		body -:org_amma_cfg_AbstractNode_toNode-> while;
	}
}

rule CFG_handle_block
{
	block:dom_Block;
	block <-cfgtrue:org_amma_cfg_ConditionalNode_trueConditionNode- while:dom_WhileStatement;
	block -endwhile:org_amma_cfg_AbstractNode_toNode-> while;

	hom(first, last);
	hom(st1, st2);
	block -st1:dom_Block_statements-> first:dom_Statement;
	block -st2:dom_Block_statements-> last:dom_Statement;

	if { st1.index == 0; }
	negative {
		block -st:dom_Block_statements->;
		if { st.index > st2.index; }
	}

	modify {
		delete(cfgtrue);
		delete(endwhile);

		while -:org_amma_cfg_ConditionalNode_trueConditionNode-> first;
		last -:org_amma_cfg_AbstractNode_toNode-> while;
	}
}

rule CFG_sweep_graph
{
	n:Node;
	negative {
		n <-:org_amma_cfg_AbstractNode_toNode->;
	}
	negative {
		n <-:org_amma_cfg_ConditionalNode_trueConditionNode->;
	}
	negative {
		n <-:org_amma_cfg_ConditionalNode_falseConditionNode->;
	}

	replace {}
}

//////////////////
// Output rules //
//////////////////
rule xmlPrefix {
	modify {
		emit("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<org.amma.cfg:MControlFlowGraph xmi:version=\"2.0\" xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:org.amma.cfg=\"org.amma.cfg\">\n");
	}
}

rule initXMLCounter : (int) {
	modify {
		return (1);
	}
}

rule addNodeNumber(var count:int) : (int) {
	n:dom_ASTNode;
	
	negative {
		n -:HelperEdge->;
	}
	negative {
		negative {
			n <-:org_amma_cfg_AbstractNode_toNode->;
		}
		negative {
			n <-:org_amma_cfg_ConditionalNode_trueConditionNode->;
		}
		negative {
			n <-:org_amma_cfg_ConditionalNode_falseConditionNode->;
		}
	}
	
	
	modify {
		n -:HelperEdge-> counter:HelperNode;
		eval {
			counter.count = count;
		}
		return (count + 1);
	}
}

rule getNodeByNumber(var number:int) : (dom_ASTNode, HelperNode, int) {
	n:dom_ASTNode -:HelperEdge-> countNode:HelperNode;
	
	if { countNode.count == number; }
	
	modify {
		return (n, countNode, number + 1);
	}
}

rule dumpName(n:dom_Expression, helper:HelperNode) {
	modify {
		exec(dumpName_Assignment(n, helper) || dumpName_SimpleName(n, helper) || dumpName_NumberLiteral(n, helper) || dumpName_InfixExpression(n, helper) || dumpName_PostfixExpression(n, helper) || dumpName_MethodInvocation(n, helper));
	}
}

test getExpressionStatementExpression(n:dom_ExpressionStatement) : (dom_Expression) {
	n -:dom_ExpressionStatement_expression-> expr:dom_Expression;
	
	return (expr);
}

test getWhileStatementExpression(n:dom_WhileStatement) : (dom_Expression) {
	n -:dom_WhileStatement_expression-> expr:dom_Expression;
	
	return (expr);
}

rule addOperatorToHelper(helper:HelperNode, assign:dom_Assignment) {
	modify {
		eval {
			helper.name = helper.name + helper.operatorMap[assign._operator]; 
		}
	}
}

rule dumpName_Assignment(assign:dom_Assignment, helper:HelperNode) {
	assign -:dom_Assignment_leftHandSide-> lhs:dom_Expression;
	assign -:dom_Assignment_rightHandSide-> rhs:dom_Expression;
	
	modify {
		exec(dumpName(lhs, helper));
		exec(addOperatorToHelper(helper, assign));
		exec(dumpName(rhs, helper));
	}
}

rule dumpName_SimpleName(name:dom_SimpleName, helper:HelperNode) {
	modify {
		eval {
			helper.name = helper.name + name._identifier; 
		}
	}
}

rule dumpName_NumberLiteral(number:dom_NumberLiteral, helper:HelperNode) {
	modify {
		eval {
			helper.name = helper.name + number._token; 
		}
	}
}

rule addInfixToHelper(helper:HelperNode, infix:dom_InfixExpression) {
	modify {
		eval {
			helper.name = helper.name + helper.infixMap[infix._operator]; 
		}
	}
}

rule dumpName_InfixExpression(expr:dom_InfixExpression, helper:HelperNode) {
	expr -:dom_InfixExpression_leftOperand-> lhs:dom_Expression;
	expr -:dom_InfixExpression_rightOperand-> rhs:dom_Expression;
	
	modify {
		exec(dumpName(lhs, helper));
		exec(addInfixToHelper(helper, expr));
		exec(dumpName(rhs, helper));
	}
}

rule addPostfixToHelper(helper:HelperNode, postfix:dom_PostfixExpression) {
	modify {
		eval {
			helper.name = helper.name + helper.postfixMap[postfix._operator]; 
		}
	}
}

rule dumpName_PostfixExpression(expr:dom_PostfixExpression, helper:HelperNode) {
	expr -:dom_PostfixExpression_operand-> op:dom_Expression;
	
	modify {
		exec(dumpName(op, helper));
		exec(addPostfixToHelper(helper, expr));
	}
}

rule dumpString(var str:string, helper:HelperNode) {
	modify {
		eval {
			helper.name = helper.name + str; 
		}
	}
}

rule dumpName_MethodInvocation(method:dom_MethodInvocation, helper:HelperNode) {
	method -:dom_MethodInvocation_name-> name:dom_SimpleName;
	method -:dom_MethodInvocation_arguments-> argument:dom_SimpleName;
	
	modify {
		exec(dumpName(name, helper));
		exec(dumpString("(", helper));
		exec(dumpName(argument, helper));
		exec(dumpString(")", helper));
	} 
}

rule dumpNode(var tag:string, n:dom_ASTNode) {
	modify {
		exec(dumpNode_Assignment(tag, n) || dumpNode_SimpleName(tag, n) || dumpNode_NumberLiteral(tag, n) || dumpNode_InfixExpression(tag, n) || dumpNode_MethodInvocation(tag, n) || dumpNode_PostfixExpression(tag, n));
	}
}

rule dumpNode_Assignment(var tag:string, assign:dom_Assignment) {
	helper:HelperNode;
	assign -:dom_Assignment_leftHandSide-> lhs:dom_Expression;
	assign -:dom_Assignment_rightHandSide-> rhs:dom_Expression;
	
	modify {
		emit("    <" + tag + " expressionName=\"" + helper.operatorNameMap[assign._operator] + "\">\n");
		exec(dumpNode("innerExpression", lhs));
		exec(dumpNode("innerExpression", rhs));
		emit("    </" + tag + ">\n");
	}
}

rule dumpNode_SimpleName(var tag:string, name:dom_SimpleName) {
	modify {
		emit("      <" + tag + " expressionName=\"" + name._identifier + "\" isIdentifier=\"true\"/>\n");
	}
}

rule dumpNode_NumberLiteral(var tag:string, number:dom_NumberLiteral) {
	modify {
		emit("      <" + tag + " expressionName=\"" + number._token + "\"/>\n");
	}
}

rule dumpNode_InfixExpression(var tag:string, expr:dom_InfixExpression) {
	helper:HelperNode;
	expr -:dom_InfixExpression_leftOperand-> lhs:dom_Expression;
	expr -:dom_InfixExpression_rightOperand-> rhs:dom_Expression;
	
	modify {
		emit("      <" + tag + " expressionName=\"" + helper.infixNameMap[expr._operator] + "\">\n");
		exec(dumpNode("innerExpression", lhs));
		exec(dumpNode("innerExpression", rhs));
		emit("      </" + tag + ">\n");
	}
}

rule dumpNode_MethodInvocation(var tag:string, method:dom_MethodInvocation) {
	method -:dom_MethodInvocation_name-> name:dom_SimpleName;
	method -:dom_MethodInvocation_arguments-> argument:dom_SimpleName;
	
	modify {
		emit("    <" + tag + " expressionName=\"" + name._identifier + "\">\n");
		exec(dumpNode("innerExpression", argument));
		emit("    </" + tag + ">\n");
	} 
}

rule dumpNode_PostfixExpression(var tag:string, expr:dom_PostfixExpression) {
	helper:HelperNode;
	expr -:dom_PostfixExpression_operand-> op:dom_Expression;
	
	modify {
		emit("    <" + tag + " expressionName=\"" + helper.postfixNameMap[expr._operator] + "\">\n");
		exec(dumpNode("innerExpression", op));
		emit("    </" + tag + ">\n");
	}
}

rule emitNodeTag(n:dom_Statement, expr:dom_Expression) {
	modify {
		exec(emitNodeTag_WhileStatement(n, expr) || emitNodeTag_ExpressionStatement(n, expr));
	}
}

rule emitFromNode(n:dom_Statement) {
	pred:dom_Statement -:org_amma_cfg_AbstractNode_toNode-> n;
	pred -:HelperEdge-> helper:HelperNode;
	
	modify {
		emit(" fromNode=\"");
		exec([emitFromNodeAttribute(n)]);
		emit("\"");
	}
}

rule emitFromNodeAttribute(n:dom_Statement) {
	pred:dom_Statement -:org_amma_cfg_AbstractNode_toNode-> n;
	pred -:HelperEdge-> helper:HelperNode;
	
	modify {
		emit("//@nodes." + helper.count + " ");
	}
}

rule emitToNode(n:dom_Statement) {
	n -:org_amma_cfg_AbstractNode_toNode-> succ:dom_Statement;
	succ -:HelperEdge-> helper:HelperNode;
	
	modify {
		emit(" toNode=\"");
		exec([emitToNodeAttribute(n)]);
		emit("\"");
	}
}

rule emitToNodeAttribute(n:dom_Statement) {
	n -:org_amma_cfg_AbstractNode_toNode-> succ:dom_Statement;
	succ -:HelperEdge-> helper:HelperNode;
	
	modify {
		emit("//@nodes." + helper.count + " ");
	}
}

rule emitFalseNode(n:dom_Statement) {
	n -:org_amma_cfg_ConditionalNode_falseConditionNode-> succ:dom_Statement;
	succ -:HelperEdge-> helper:HelperNode;
	
	modify {
		emit(" falseConditionNode=\"//@nodes." + helper.count + "\"");
	}
}

rule emitTrueNode(n:dom_Statement) {
	n -:org_amma_cfg_ConditionalNode_trueConditionNode-> succ:dom_Statement;
	succ -:HelperEdge-> helper:HelperNode;
	
	modify {
		emit(" trueConditionNode=\"//@nodes." + helper.count + "\"");
	}
}

rule emitNodeTag_WhileStatement(n:dom_WhileStatement, expr:dom_Expression) {
	n -:HelperEdge-> helper:HelperNode;
	
	modify {
		emit("  <nodes xsi:type=\"org.amma.cfg:IterativeNode\"");
		exec(emitFromNode(n));
		exec(emitToNode(n));
		emit(" name=\"While(" + helper.name + ")\"");
		exec(emitTrueNode(n));
		exec(emitFalseNode(n));
		emit(">\n");
		exec(dumpNode("expression", expr));
		emit("  </nodes>\n");
	}
}

rule emitNodeTag_ExpressionStatement(n:dom_ExpressionStatement, expr:dom_Expression) {
	n -:HelperEdge-> helper:HelperNode;
	
	modify {
		emit("  <nodes xsi:type=\"org.amma.cfg:Node\"");
		exec(emitFromNode(n));
		exec(emitToNode(n));
		emit(" name=\"" + helper.name + "\">\n");
		exec(dumpNode("expression", expr));
		emit("  </nodes>\n");
	}
}

rule xmlSuffix {
	modify {
		emit("</org.amma.cfg:MControlFlowGraph>\n");
	}
}
