//
// Initialize file output and create helper nodes
//

rule InitOutput
{
  pattern {
    :CspContainer -:processAssignments-> curPa:ProcessAssignment;
    lastPa:ProcessAssignment;
    negative { lastPa -:processAssignments->; }
  }
  modify {
    counter:Counter;
    lastPa -:processAssignments-> dummyPa:ProcessAssignment;
    
    exec(((curPa)=PAWriteProcess(curPa)[+]
        | (curPa)=PAWritePrefix(curPa)[+]
        | (curPa)=PAWriteConditionStart(curPa)
        | (curPa)=PAWriteConcurrencyStart(curPa)
        )[*] | FinishOutput(dummyPa));
  }
}

//
// Process
//

rule PAWriteProcess(curPa:ProcessAssignment) : (ProcessAssignment)
{
  pattern {
    procID:Process <-:processIdentifier- curPa -:process-> proc:Process;
    curPa -:processAssignments-> nextPa:ProcessAssignment;
  }
  modify {
    emit(procID.name, " = ", proc.name, "\n");
    return (nextPa);
  }
}

//
// Prefix
//

rule PAWritePrefix(curPa:ProcessAssignment) : (ProcessAssignment)
{
  pattern {
    procID:Process <-:processIdentifier- curPa -:process-> pre:Prefix;
    pre -:targetProcess-> tgt:Process;
    pre -:event-> ev:Event;
    curPa -:processAssignments-> nextPa:ProcessAssignment;
  }
  modify {
    emit(procID.name, " = ", ev.name, " -> ", tgt.name, "\n");
    return (nextPa);
  }
}

//
// Condition
//

rule PAWriteConditionStart(curPa:ProcessAssignment) : (ProcessAssignment)
{
  pattern {
    procID:Process <-:processIdentifier- curPa -:process-> cond:Condition;
    curPa -:processAssignments-> nextPa:ProcessAssignment;
  }
  modify {
    emit(procID.name, " = ");
    exec((PAWriteConditionNext(cond) || PAWriteConditionLast(cond)) | PAWriteConditionEnd[*]);
    emit("\n");
    return (nextPa);
  }
}

rule PAWriteConditionNext(curCond:Condition)
{
  pattern {
    thenProc:Process <-:leftHandSide- curCond -:rightHandSide-> nextCond:Condition;
    counter:Counter;
  }
  modify {
    eval {
      counter.value = counter.value + 1;
    }
    emit((counter.value > 1 ? "(" : "") + thenProc.name + " <| " + curCond.expression + " |> ");
    exec(PAWriteConditionNext(nextCond) || PAWriteConditionLast(nextCond));
  }
}

rule PAWriteConditionLast(curCond:Condition)
{
  pattern {
    thenProc:Process <-:leftHandSide- curCond -:rightHandSide-> elseProc:Process;
    counter:Counter;
  }
  modify {
    emit((counter.value > 1 ? "(" : "") + thenProc.name + " <| " + curCond.expression + " |> " + elseProc.name);
  }
}

rule PAWriteConditionEnd
{
  pattern {
    counter:Counter;
    if { counter.value > 0; }
  }
  modify {
    eval {
      counter.value = counter.value - 1;
    }
    emit(")");
  }
}

//
// Concurrency
//

rule PAWriteConcurrencyStart(curPa:ProcessAssignment) : (ProcessAssignment)
{
  pattern {
    procID:Process <-:processIdentifier- curPa -:process-> conc:Concurrency
      -:leftHandSide-> forkProc:Process;
    curPa -:processAssignments-> nextPa:ProcessAssignment;
  }
  modify {
    emit(procID.name, " = ", forkProc.name);
    exec(PAWriteConcurrencyNext(conc) || PAWriteConcurrencyLast(conc));
    emit("\n");
    return (nextPa);
  }
}

rule PAWriteConcurrencyNext(curConc:Concurrency)
{
  pattern {
    curConc -:rightHandSide-> nextConc:Concurrency -:leftHandSide-> forkProc:Process;
  }
  modify {
    emit(" || ", forkProc.name);
    exec(PAWriteConcurrencyNext(nextConc) || PAWriteConcurrencyLast(nextConc));
  }
}

rule PAWriteConcurrencyLast(curConc:Concurrency)
{
  pattern {
    curConc -:rightHandSide-> forkProc:Process;
  }
  modify {
    emit(" || ", forkProc.name);
  }
}

//
// Remove helper nodes
//

rule FinishOutput(dummyPa:ProcessAssignment)
{
  pattern {
    counter:Counter;
  }
  modify {
    delete(dummyPa);
    delete(counter);
  }
}
