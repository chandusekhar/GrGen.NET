using visit;

// Graph generator taken from Clique example

rule init : (State) {

	modify {
		s:State;
		eval {
			s.rand1 = 123456789;
			s.rand2 = 987654321;
			s.nextNodeID = 0;   // just for fun...
			s.maxNodeID = 100;
		}
		return (s);
	}
}

rule nextRandom {
	s:State;

	modify {
		eval {
			s.rand1 = 1664525 * s.rand1 + 1013904223;
			s.rand2 = 1664525 * s.rand2 + 1013904223;
		}
	}
}

rule trimRandom {
	s:State;
	if { s.rand1 >= 0 && (s.rand1 >> 8) < (0x7fffffff / s.maxNodeID) * s.maxNodeID;
		s.rand2 >= 0 && (s.rand2 >> 8) < (0x7fffffff / s.maxNodeID) * s.maxNodeID; }

	modify {
		eval {
			s.randRes1 = (s.rand1 >> 8) % s.maxNodeID;
			s.randRes2 = (s.rand2 >> 8) % s.maxNodeID;
		}
	}
}

rule newNode {
	s:State;
	if { s.nextNodeID < s.maxNodeID; }

	modify {
		n:N;
		eval {
			n.id = s.nextNodeID;
			s.nextNodeID = s.nextNodeID + 1;
		}
	}
}

rule newEdge {
	s:State;
	src:N;
	tgt:N;
	if { src.id == s.randRes1 && tgt.id == s.randRes2; }

	modify {
		src --> tgt;
	}
}

// End of graph generator rules

pattern Component(n:Node)
{
    alternative {
        more {
            n ?--? m:Node;
            c1:Component(n);
            c2:Component(m);
            
            modify {
                c1();
                c2();
            }
        }
        end {
            negative { n ?--? m:Node; }
            
            modify {
                eval {
                    visited(n, 0) = true;
                }
            }
        }
    }
    modify {}
}

rule findComponent()
{
    n:N;
    if { !visited(n, 0); }
    
    comp:Component(n);
    
    modify {
        comp();
    }
}

// calling patterns with variables is not supported yet
/*
pattern Component(n:Node, var visID:int)
{
    alternative {
        more {
            n ?--? m:Node;
            c1:Component(n, visID);
            c2:Component(m, visID);
            
            modify {
                c1();
                c2();
            }
        }
        end {
            negative { n ?--? m:Node; }
            
            modify {
                eval {
                    visited(n, visID) = true;
                }
            }
        }
    }
}

rule findComponent(var VisID:int)
{
    n:N;
    if { !visited(n, visID); }
    
    comp:Component(n, visID);
    
    modify {
        comp();
    }
}*/
