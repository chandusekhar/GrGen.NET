\chapter{Nested and Subpatterns}\indexmain{rule set language nested and subpatterns}
\label{cha:nestedsub}

This chapter describes the rule set language constructs related to nested patterns (negative application condition, positive application condition, nested pattern with cardinality, alternative patterns) and subpatterns (subpattern declaration and usage, subrule declaration and usage). We begin with the nested patterns:

\begin{rail}  
  NestedPattern: 
    NegativeApplicationCondition |
    PositiveApplicationCondition |
    NestedPatternWithCardinality |
    AlternativePatterns 
    ;
\end{rail}

\section{Negative Application Condition (NAC)}
\indexmain{negative application condition}\indexmainsee{NAC}{negative application condition}\label{nac}

\begin{rail}  
  NegativeApplicationCondition: 
    'negative' lbrace (()+PatternStatement) rbrace
    ;
\end{rail}\ixkeyw{negative}

  With negative application conditions (keyword \texttt{negative}) we can specify graph patterns which forbid the application of a rule if any of them is present in the host graph (cf.~\cite{adam}). 
  NACs possess a \indexed{scope} of their own, i.e. names defined within a NAC do not exist outside the NAC. 
  Identifiers from surrounding scopes must not be redefined.
  In general NACs do not care about bindings within the outer scope. 
   Nevertheless, if you use an \emph{identifier} that is defined in the outer scope, this specifies exactly the graph element, the identifier is bound to in the outer scope.
  \begin{example}
    We specify a node \texttt{x} which is not connected to a node of type \texttt{BadType}:
    \begin{grgen}
  x:Node;
  negative {
    x ?--? :BadType;
  }
    \end{grgen}
  \end{example}
   Because NACs have their ``own'' binding, using NACs leads to specifications which might look a bit redundant.
  \begin{example}
    Let's specify a singleton, a node of type \texttt{T} which is the only one of this type.
    The following specification is \emph{wrong} (it will never return a match):
    \begin{grgen}
  x:T;
  negative {
    y:T;
  }
    \end{grgen}
    Instead we have to specify the \emph{complete} forbidden pattern inside the NAC. This is done by:
     \begin{grgen}
  x:T;
  negative {
    x;
    y:T;
  }
    \end{grgen}
  \end{example} 

As a straight-forward generalization of negatives within positive patterns,
negatives may get nested to an arbitrary depth. Matching of the nested
negative pattern causes the matching of the nesting pattern to fail.

\begin{example}
  \begin{grgen}
test foo {
  a:NA --> b:NB;
  negative {
    a --> c:NC;
    negative {
      b --> c;
    }
  }
}
  \end{grgen}
\end{example}

The test to the left searech for a node a linked to a node b, but only if a is not connected to a further node c, with the exception that b is connected to c, too. It matches the host graph to the right, because the match of the inner negative cancels out the match of the outer negative.

%negative pattern elements get matched independent from the subpatterns utilizing them
%(explicit patternpath/pattern statement in the negative/independent needed for old behaviour)

	
\section{Positive Application Condition (PAC)}
\indexmain{positive application condition}\indexmainsee{PAC}{positive application condition} \label{pac}

\begin{rail}  
  PositiveApplicationCondition: 
    'independent' lbrace (()+PatternStatement) rbrace|
    ;
\end{rail}\ixkeyw{independent}

With positive application conditions (keyword \texttt{independent}) we can specify graph patterns which, in contrast to negative application conditions, must be present in the host graph to cause the matching of the enclosing pattern to succeed. Together with NACs they share the propertie of opening a \indexed{scope}, with elements being independent from the surrounding scope (i.e. a host graph element can easiely get matched to a pattern element and a PAC element with a different name, unless the pattern element is referenced in the PAC). 
No isomorphic matching is enforced, as in the case of the elements within one scope (unless declared homomorpic).
As it only represents an application condition, it is not possible to rewrite the matched independent block, i.e. you can't specify a nested modify/replace block.

\begin{example}
  \begin{grgen}

rule fancyRule
{
  a:A -- b:B -- c:C;
  independent {
    b -- cc:C;
  	if { cc.a=="foo"; }
  }
 
  modify {
    delete(b);
  }
}
  \end{grgen}

In the example given, three nodes a,b,c of types A,B,C connected by undirected edges are searched, and if found, b gets deleted, but only if b is connected to a further node cc of type C, with its attribute a holding the string value "foo", as specified 
by the independent; due to the independent cc might be identical with c, without the independent c and cc must be different nodes (isomorphy constraint). Only the nodes a,b,c could be deleted, the matched cc is declared in a nested scope unavailable to the outer scope.

\end{example}

  
\section{Pattern Cardinality}
\indexmain{pattern cardinality}\label{pc}

\begin{rail}  
  NestedPatternWithCardinality: 
    ('iterated' | 'multiple' | 'optional') lbrace (()+PatternStatement) rbrace |
    ;
\end{rail}\ixkeyw{iterated}\ixkeyw{multiple}\ixkeyw{optional}

The iterated block is matching the contained subpattern as often as possible
(succeeding if the contained pattern is not available, too).
You can use it to match and rewrite breadth-splitting structures,
like reversing all edges in the graph representation of a blowball.

\begin{example}
  \begin{grgen}
rule BlowballReverse {
  root:Node --> head:HeadNode;
  iterated {
    head --> n:Node;
	replace {
	  head <-- n;
	}
  }
  replace { 
    root <-- head;
  }
}
  \end{grgen}
\end{example}

Combined with subpatterns, you may match structures extending into breadth and depth,
like e.g. a spanning tree.

\begin{example}
  \begin{grgen}
pattern SpanningTree(root:Node)
{
  iterated {
    root -- next:Node;
    :SpanningTree(next);
  }
}
  \end{grgen}
\end{example}

The *multiple block* is working like the iterated block, 
but expects the contained subpattern to be available at least once,
if it is not, matching of the multiple block and thus its enclosing pattern fails.

\begin{example}
  \begin{grgen}
test OneOrMoreEdges(src:Node, tgt:Node)
{
  multiple {
    src --> tgt;
  }
}
  \end{grgen}
\end{example}

The *optional block* is working like the iterated block,
but matches the contained subpattern at most once, 
further occurences of the subpattern are left unmatched.
The follwing test matches two nodes connected by an directed edge
of unspecified direction, and optionally an undirected reflexive edge
on node 1, and optionally an arbitrarily directed edge on node 2,
in case there are some.

\begin{example}
  \begin{grgen}
test foo {
  n1:Node <--> n2:Node;
  optional {
    n1 -- n1;
  }
  optional {
    n2 ?--? n2;
  }
}
  \end{grgen}
\end{example}


\section{Alternative Patterns}
\indexmain{alternative patterns}\label{alternative}

\begin{rail}  
  AlternativePatterns: 
    'alternative' lbrace ((CaseName lbrace (()+PatternStatement) rbrace)+()) rbrace
    ;
\end{rail}\ixkeyw{alternative}

With the alternative block you can specify several nested alternative
patterns. One of them must get matched for the matching of the entire pattern
to succeed. The order of matching the alternative patterns is unspecified.

\begin{example}
  \begin{grgen}
test t {
  x:Node <-- y:Node;
  alternative {
    A {
      x --> y;
    }
    B {
      x --> z:Node;
    }
  }
}
  \end{grgen}
\end{example}


\section{Subpattern Declaration and Usage}
\indexmain{subpattern}\label{subpattern}

In addition to node declarations "Name:NodeType" and edge declarations
"-Name:EdgeType->" you can now also declare subpattern entities of some
specific shape "Name:SubpatternType()".

The shape is specified by a subpattern type specification

pattern Name() {
  // local content: nodes, edges, and even subpatterns.
}

Subpatterns can get connected to their containing pattern 
by some kind of parameters:

\begin{example}
  \begin{grgen}
test t {
  x:Node <-- y:Node;
  f:Foo(x);
}
pattern Foo(bar:Node) {
  bar --> :Node;
}
  \end{grgen}
\end{example}

Alternatives and subpatterns can be combined into recursive subpatterns
(note the negative pattern to ensure you get a longest possible match):

\begin{example}
  \begin{grgen}
pattern Chain(prev:Node) {
  alternative {
    Empty {
      negative {
        prev --> next:Node;
      }
    }
    Further {
      prev --> next:Node;
      :Chain(next);
    }
  }
}
  \end{grgen}
\end{example}

\begin{example}
  \begin{grgen}

rule fancyRule
{
  a:A -- b:B -- c:C;
  independent {
    :Chain(c,a)
  }
  
  replace {
    a; c;
  }
}

pattern Chain(src:Node, tgt:Node)
{
  alternative {
    Found {
      src --> tgt;
    }
    Further {
      src --> intermediate:Node;
      :Chain(intermediate, tgt);
    }
  }
}
  \end{grgen}

  This is an example for the interplay of subpatterns and positive application conditions; here, three nodes a,b,c of types A,B,C, connected by undirected edges are searched, and if found, b gets deleted, but only if there is an iterated path of directed edges from c to a. The path may contain the host graph node matched to b again. The same path specified in the pattern of the rule - not in the independent - would not get matched if it would go through the host graph node matched to b, as it is locked by the isomorphy constraint.

\end{example}


\section{Subrule Declaration and Usage}
\indexmain{subrule}\label{nac}

Subpatterns and alternatives may contain a dependent replacement, effectively
turning subpatterns into subrules:
The replacement part nested within the alternative case chosen in matching
will be used for carrying out the replacement. To trigger the replacement of a
subpattern, use call-syntax on the pattern entity name:

\begin{example}
  \begin{grgen}
rule R {
  sub:FancySubrule();

  modify {
    sub();        // trigger rewriting the FancySubrule instance
  }
}

pattern FancySubrule {
  x:Node <-- y:Node;
  alternative {
    A {
      x --> y;

      modify {
        x --> y2:Node;
      }
    }
    B {
      x --> z:Node;

      modify {
        delete(z);
      }
    }
  }

  modify {
    delete(y);
  }
}
  \end{grgen}
\end{example}

*The dependent replacement may get connected to the containing replacement
graph by parameters, too.

\begin{example}
  \begin{grgen}
pattern ChainFromToReverseToCommon(from:Node, to:Node) {
  alternative {
    base {
      from --> to;

      replace(common:Node) {
        from <-- to;
        from --> common;
        to --> common;
      }
    }
    rec {
      from --> intermediate:Node;
      cftrtc:ChainFromToReverseToCommon(intermediate, to);

      replace(common:Node) {
        from <-- intermediate;
        from --> common;
        cftrtc(common);
      }
    }
  }

  replace(common:Node) {
    from; to;
  }
}
  \end{grgen}
\end{example}

Creation, Deletion and Preservation of subpatterns
In addition to the fine-grain dependent replacement, 
subpatterns may get created or deleted or kept as a whole.
Creation currently works only for subpatterns without alternatives,
as the capability to choose the case to create is missing.

\begin{example}
  \begin{grgen}
rule R {
  foo:Foo();
  bar:Bar();

  replace {
    foo; // is kept
    // bar not included here - will be deleted
    blub:Blub(); // will be created
    // foo(); -- would apply dependent replacement
  }
}
  \end{grgen}
\end{example}
