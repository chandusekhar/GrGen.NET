Very short introduction into the new features of GrGen.NET 2.5
==============================================================

Changes from 1.4 to 2.0:
------------------------

*Subpatterns:
In addition to node declarations "Name:NodeType" and edge declarations
"-Name:EdgeType->" you can now also declare subpattern entities of some
specific shape "Name:SubpatternType()".

The shape is specified by a subpattern type specification

pattern Name() {
  // local content: nodes, edges, and even subpatterns.
}

Subpatterns can get connected to their containing pattern 
by some kind of parameters:

test t {
  x:Node <-- y:Node;
  f:Foo(x);
}
pattern Foo(bar:Node) {
  bar --> :Node;
}

*Alternatives:
With the alternative block you can specify several nested alternative
patterns. One of them must get matched for the matching of the entire pattern
to succeed. The order of matching the alternative patterns is unspecified.

test t {
  x:Node <-- y:Node;
  alternative {
    A {
      x --> y;
    }
    B {
      x --> z:Node;
    }
  }
}

*Alternatives and subpatterns can be combined into recursive subpatterns
(note the negative pattern to ensure you get a longest possible match):

pattern Chain(prev:Node) {
  alternative {
    Empty {
      negative {
        prev --> next:Node;
      }
    }
    Further {
      prev --> next:Node;
      :Chain(next);
    }
  }
}

*Subpatterns and alternatives may contain a dependent replacement, effectively
turning subpatterns into subrules:
The replacement part nested within the alternative case chosen in matching
will be used for carrying out the replacement. To trigger the replacement of a
subpattern, use call-syntax on the pattern entity name:

rule R {
  sub:FancySubrule();

  modify {
    sub();        // trigger rewriting the FancySubrule instance
  }
}

pattern FancySubrule {
  x:Node <-- y:Node;
  alternative {
    A {
      x --> y;

      modify {
        x --> y2:Node;
      }
    }
    B {
      x --> z:Node;

      modify {
        delete(z);
      }
    }
  }

  modify {
    delete(y);
  }
}

*The dependent replacement may get connected to the containing replacement
graph by parameters, too.

pattern ChainFromToReverseToCommon(from:Node, to:Node) {
  alternative {
    base {
      from --> to;

      replace(common:Node) {
        from <-- to;
        from --> common;
        to --> common;
      }
    }
    rec {
      from --> intermediate:Node;
      cftrtc:ChainFromToReverseToCommon(intermediate, to);

      replace(common:Node) {
        from <-- intermediate;
        from --> common;
        cftrtc(common);
      }
    }
  }

  replace(common:Node) {
    from; to;
  }
}

*Creation, Deletion and Preservation of subpatterns
In addition to the fine-grain dependent replacement, 
subpatterns may get created or deleted or kept as a whole.
Creation currently works only for subpatterns without alternatives,
as the capability to choose the case to create is missing.

rule R {
  foo:Foo();
  bar:Bar();

  replace {
    foo; // is kept
    // bar not included here - will be deleted
    blub:Blub(); // will be created
    // foo(); -- would apply dependent replacement
  }
}

*As a straight-forward generalization of negatives within positive patterns,
negatives may get nested to an arbitrary depth. Matching of the nested
negative pattern causes the matching of the nesting pattern to fail.

test foo {
  a:NA --> b:NB;
  negative {
    a --> c:NC;
    negative {
      b --> c;
    }
  }
}

*Further examples are available at the examples and tests directories,
e.g. examples/TranskriptionAbstrakt, examples/ProgramGraphs




Changes from 2.0 to 2.1:
------------------------

*New string operations
----------------------
Several operations on strings in method notation have been added.
 (examples given with n.str == "foo bar foo")
- .length() returns length of string, as int, 
 e.g. n.str.length()==11
- .indexOf(strToSearchFor) returns first position the string strToSearchFor appears at, as int, -1 if not found
 e.g. n.str.indexOf("foo")==0
- .lastIndexOf(strToSearchFor) returns last position the string strToSearchFor appears at, as int, -1 if not found
 e.g. n.str.lastIndexOf("foo")==8
- .substring(startIndex, length) returns substring of given length from startIndex on
 e.g. n.str(4,3)=="bar"
- .replace(startIndex, length, replaceStr) return string with substring from startIndex of given length replaced by replaceStr,
 e.g. n.str(4,3,"foo")=="foo foo foo"

*New attribute types set<K> and map<K,V>
========================================
with K,V = boolean|int|float|double|string|enum
with several operations on them introduced.
(Implemented by C#-Dictionary, i.e. Hashmaps)

*Changes in graph model
-----------------------

Regarding sets:
An attribute of set type is declared like f.ex.
funnySet:set<int>;
Optionally, you may initialize the sets by a set initializer
fancySet:set<string> = { "foo", "bar" };

Regarding maps:
An attribute of map type is declared like f.ex.
funnyMap:map<int, boolean>;
Optionally, you may initialize the maps by a map initializer
fancyMap:map<string, int> = { "foo"->0, "bar"->1 };

Further on you may declare them constant.

*Changes in graph rewrite rules
-------------------------------

Regarding sets:

*Assignment of sets
n.fancySet = m.fancySet; 
with value semantics like all the other attribute types, 
i.e. the set is copied, changes to one set don't show up in the other set.
The assignment is available only in the eval-block of the modify/replace-part, 
all the other/following operations are available in the if-block of the pattern, too.

*Set constructors, analogous to set initializers, they represent a base set expression
 e.g. n.fancySet = { "foo", "bar" };
but in contrast to set initializers, they may contain non constant values
 e.g. n.fancySet = { n.strVal, m.strVal, n.strVal+m.strVal }
The values must be all of the same type, if you wish implicit type casts
you have to prefix the set constructor by the set type
 e.g. n.fancySet = set<string>{ 42, intVal, "fool" };
Set constructors create and return an anonymous set,
to be written to an attribute or to be operated on by some of the following set operations:

*Operations on sets, forming expressions with sets
-Set union, intersection, difference as binary operators |,&,\
 e.g. n.fancySet \ { "la","le","lu" };
taking two sets of equal types and returning a new, computed set.
Priorities | < & < \ (higher priority binds stronger, so a&b\c|d == (a&(b\c))|d)
-Set membership in, returning whether the set contains the given element, as boolean
 e.g. 42 in intSet  or  m.boolValue = n.stringValue in { "foo", "bar" };

*Methods on sets
.size() returns the number of elements in the set, as int
e.g. n.fancySet.size()

*Parameters of set type, can be used to hand some set in.
(The result of assigning to the input set is undefined.)
test bla(var varSet:set<int>) 
{
	n:SomeType;
	if { n.foo in (varSet \ { n.a }); }
}

Regarding maps:

*Assignment of maps
n.fancySet = m.fancySet; 
with value semantics like all the other attribute types, 
i.e. the map is copied, changes to one map don't show up in the other map.
The assignment is available only in the eval-block of the modify/replace-part, 
all the other/following operations are available in the if-block of the pattern, too.

*Map constructors, analogous to map initializers, they represent a base map expression
 e.g. n.fancyMap = { "foo"->0, "bar"->1 };
but in contrast to map initializers, they may contain non constant values
 e.g. n.fancyMap = { n.strVal->m.intVal, m.strVal->n.intVal, (n.strVal+m.strVal)->(m.intVal+n.intVal) }
The values must be all of the same type, if you wish implicit type casts 
you have to prefix the map constructor by the map type
 e.g. n.fancyMap = map<string,int>{ 42->42, intVal->strVal, "fool"->42 };
Map constructors create and return an anonymous map,
to be written to an attribute or to be operated on by some of the following map operations:

*Operations on maps, forming expressions with maps
-Map union, intersection, difference as binary operators |,&,\
 e.g. n.fancyMap | { "la"->0,"le"->1,"lu"->2 };
taking two maps of equal types and returning a new, computed map.
Priorities | < & < \ (higher priority binds stronger, so a&b\c|d == (a&(b\c))|d)
Semantics of |,&,\ on maps:
 map1|map2 - new map with elements which are in at least one of the maps, with the value of map2 taking precedence
 map1&map2 - new map with elements which are in both maps, with the value of map2 taking precedence
 map1\map2 - new map with elements from map1 without the elements with a key contained in map2
-Additionally, map<K,V> \ set<K> is allowed
 e.g. m.fancyMap \ { "hui","buh" }  or  m.fancyMap = m.fancyMap \ n.fancySet
-Map membership in, returning whether the map domain contains the given element, as boolean
 e.g. 42 in intMap  or  m.boolValue = n.stringValue in { "foo"->0, "bar"->1 };
-Map access map[key] returning value in map saved under key (value in range mapped to by given key from domain)
 e.g. n.intVal = m.fancyMap["bla"] + 42;

*Methods on maps
- .size() returns the number of elements in the map, as int
 e.g. n.fancyMap.size()
- .domain() returns the set of elements in the domain of the map
 e.g. n.fancyMap.domain(), result set<K>
- .range() returns the set of elements in the range of the map
 e.g. n.fancyMap.range(), result set<V>

*Parameters of map type, can be used to hand some map in.
(The result of assigning to the input map is undefined.)
test bla(var varMap:map<int,int>) 
{
	n:SomeType;
	if {  varMap[n.foo]==42; }
}


*Changes in GrShell
-------------------

New set commands:
<var> = new set <type> - creates a new set of given type and assigns it to the variable
 e.g. v = new set string
set <setname> add <key> - adds key to set
 e.g. set n.a add "foo"
set <setname> remove <key> - removes key from set
 e.g. set v remove "bar"
set <setname> size - prints out the number of set entries
 e.g. set n.a size

New map commands:
<var> = new map <keytype> <valuetype> - creates a new map of given types and assigns it to the variable
 e.g. v = new map string int
map <mapname> add <key> <value> - adds pair (key,value) to map
 e.g. map n.a add "foo"
map <mapname> remove <key> - removes pair (key,*) from map
 e.g. map v remove "bar"
map <mapname> size - prints out the number of map entries
 e.g. map n.a size




Changes from 2.1 to 2.5:
------------------------

*Iterated block and its siblings:
---------------------------------

The *iterated block* is matching the contained subpattern as often as possible
(succeeding if the contained pattern is not available, too).
You can use it to match and rewrite breadth-splitting structures,
like reversing all edges in the graph representation of a blowball.

rule BlowballReverse {
  root:Node --> head:HeadNode;
  iterated {
    head --> n:Node;
	replace {
	  head <-- n;
	}
  }
  replace { 
    root <-- head;
  }
}

Combined with subpatterns, you may match structures extending into breadth and depth,
like e.g. a spanning tree.

pattern SpanningTree(root:Node)
{
  iterated {
    root -- next:Node;
    :SpanningTree(next);
  }
}

The *multiple block* is working like the iterated block, 
but expects the contained subpattern to be available at least once,
if it is not, matching of the multiple block and thus its enclosing pattern fails.

test OneOrMoreEdges(src:Node, tgt:Node)
{
  multiple {
    src --> tgt;
  }
}

The *optional block* is working like the iterated block,
but matches the contained subpattern at most once, 
further occurences of the subpattern are left unmatched.
The follwing test matches two nodes connected by an directed edge
of unspecified direction, and optionally an undirected reflexive edge
on node 1, and optionally an arbitrarily directed edge on node 2,
in case there are some.

test foo {
  n1:Node <--> n2:Node;
  optional {
    n1 -- n1;
  }
  optional {
    n2 ?--? n2;
  }
}

*Independent block:
-------------------

The independent block allows to specify further patterns 
to be applied as positive application conditions.
In contrast to the negative application conditions given by negative blocks,
matching its subpattern does not cause the matching of the enclosing pattern 
to fail, but is necessary in order for the matching of the enclosing pattern
to succeed. It shares with the negative pattern its independence from the 
enclosing pattern, i.e. host graph elements already matched to elements of the
enclosing pattern may get matched again in the nested pattern, they are not
locked/part of if - this is in contrast to the normal mode of matching within
one pattern, which is isomorphic by default (it is forbidden to match one 
host graph element by several pattern elements (unless explicitely specified 
by the hom(a,b) construct)). As it only represents an application condition,
it is not possible to rewrite the matched independent block,
i.e. you can't specify a nested modify/replace block.

rule fancyRule
{
  a:A -- b:B -- c:C;
  independent {
    b -- cc:C;
	if { cc.a=="foo"; }
  }
  independent {
    :Chain(c,a)
  }
  
  replace {
    a; c;
  }
}

pattern Chain(src:Node, tgt:Node)
{
  alternative {
    Found {
	  src --> tgt;
    }
    Further {
      src --> intermediate:Node;
      :Chain(intermediate, tgt);
    }
  }
}

In the example given above, three nodes a,b,c of types A,B,C
connected by undirected edges are searched, and if found, b gets deleted, but:
a) only if b is connected to a further node cc of type C,
with its attribute a holding the string value "foo", as specified 
by the first independent; note that cc might be identical with c.
b) only if there is an iterated path of directed edges from c to a.
If there would be such an path containing b in the host graph, 
it would get matched. The same path specified in the pattern of the rule 
- not in the independent - would not get matched, as b was already matched
and is thus locked by the isomorphy constraint.

 
*Import/Export:
---------------

GrGen natively supports the following formats:
 - GRS: GrShell script files (graph only; a very limited version of the normal grs)
 - GXL: Graph exchange language (graph only, see http://www.gupro.de/GXL/)
 - EMF/ECORE: Eclipse Modeling Framework (model and graph; partial and only import).
      .ecore files describe the graph models, .xmi files the graph instances.

Import:
To import a graph model and/or a graph instance you can either use
Porter.Import() from the libGr API, or use the GrShell command "import <filename>+".
In any case the file format is determined by the file extensions.
While both GRS and GXL importers expect exactly one file, the EMF/ECORE importer
expects first one or more .ecore files and following optionally a .xmi files and/or
a .grg file. To use additional custom graph models you should supply an own .grg
file which may be based on the automatically generated .grg file, if none was
supplied (see the GraBaTs09-Program-Comprehension example).

Export:
To export a graph instance you can either use Porter.Export() from the libGr API,
or use the GrShell command "export <filename>".

	
*Application programming interface:
-----------------------------------

For every action=rule or test in the Bar.grg, 
several classes are generated in namespace Action_Bar.
For example for a rule foo, you get
- a LGSPRulePattern-object Rule_foo containing:
  - a match interface IMatch_foo which defines how a match of the rule looks
    like, extending the (old) rule-unspecific IMatch interface.
  - and internal: a match implementation Match_foo.
  - and internal: a description of the pattern to match.
  - and internal: the modify methods doing the rewriting.
- an action interface IAction_foo which contains the methods:
  - Match, to match the pattern in the host graph,
     with in parameters corresponding to the in parameters of the rule,
	 returning matches of type Rule_foo.IMatch_foo.
  - Modify, to modify a given match according to the rewrite specification,
     with out parameters corresponding to the out parameters of the rule.
  - Apply, to match and modify the found match 
     with in parameters corresponding to the in parameters of the rule,
     with ref parameters corresponding to the out parameters of the rule.
- and internal: its implementation Action_foo,
   extending the (old) rule-unspecific IAction interface,
   containing the generated matcher program(s) searching for the pattern.
The action instances are available in the BarActions class,
  as member foo of type IAction_foo.
These files and classes use further classes representing the node and edge types,
which are generated in namespace Model_Bla, according to the model file Bla.gm.

The actions expect inputs of correct type; the old input parameters semantics
of silently failing rule application on a wrong type is now only available 
with the syntax "r(x:ExactType<InexactType>)", with InexactType showing up in the API,
and the rule failing if the given element is not of ExactType)

*Semantic changes:
------------------

The semantics of negative blocks regarding subpatterns/subrules were changed:
Negative pattern elements now get matched independent from the subpatterns utilizing them.
  Previously, negatives occuring within an subpattern were not completely independent 
from the subpattern derivations leading to this positions, 
the elements from outer subpatterns were locked (some - not all).
This allowed to match breath-structures (as Blowball) without the iterated
block, but was limited to one subpattern per pattern; with several subpatterns locking
was implementation dependent, and thus in essence semantically broken.
This is fixed now, negatives and independents occuring 
within subpatterns are completely independent from the subpattern derivation
path on which they get applied. Breadth-structures can get matched by the iterated
or multiple block by now, which is easier, faster and more understandable.
(Explicit patternpath/pattern statements in the negative/independent blocks
allow for the old behaviour, with the guarantee that only the elements from the derivation
path leading to the current negative/independent are locked, but using this feature is discouraged.)

Furtheron, the semantics of hom declarations were changed.
By now, they 
 - get inherited into nested negatives/independents
 - are non-transitive (hom(a,b) and hom(b,c) don't cause hom(a,c) unless specified)
  
*Further, smaller extensions and changes are given in the change log*
