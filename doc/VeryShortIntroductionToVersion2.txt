Very short introduction into the new features of GrGen.NET 2.0
--------------------------------------------------------------

*Subpatterns:
In addition to node declarations "Name:NodeType" and edge declarations
"-Name:EdgeType->" you can now also declare subpattern entities of some
specific shape "Name:SubpatternType()".

The shape is specified by a subpattern type specification

pattern Name() {
  // local content: nodes, edges, and even subpatterns.
}

Subpatterns can get connected to their containing pattern 
by some kind of parameters:

test t {
  x:Node <-- y:Node;
  f:Foo(x);
}
pattern Foo(bar:Node) {
  bar --> :Node;
}

*Alternatives:
With the alternative statement you can specify several nested alternative
patterns. One of them must get matched for the matching of the entire pattern
to succeed. The order of matching the alternative patterns is unspecified.

test t {
  x:Node <-- y:Node;
  alternative {
    A {
      x --> y;
    }
    B {
      x --> z:Node;
    }
  }
}

*Alternatives and subpatterns can be combined into recursive subpatterns
(note the negative pattern to ensure you get the longest possible match):

pattern Chain(prev:Node) {
  alternative {
    Empty {
      negative {
        prev --> next:Node;
      }
    }
    Further {
      prev --> next:Node;
      :Chain(next);
    }
  }
}

*Subpatterns and alternatives may contain a dependent replacement, effectively
turning subpatterns into subrules:
The replacement part nested within the alternative case chosen in matching
will be used for carrying out the replacement. To trigger the replacement of a
subpattern, use call-syntax on the pattern entity name:

rule R {
  sub:FancySubrule();

  modify {
    sub();        // trigger rewriting the FancySubrule instance
  }
}

pattern FancySubrule {
  x:Node <-- y:Node;
  alternative {
    A {
      x --> y;

      modify {
        x --> y2:Node;
      }
    }
    B {
      x --> z:Node;

      modify {
        delete(z);
      }
    }
  }

  modify {
    delete(y);
  }
}

*The dependent replacement may get connected to the containing replacement
graph by parameters, too.

pattern ChainFromToReverseToCommon(from:Node, to:Node) {
  alternative {
    base {
      from --> to;

      replace(common:Node) {
        from <-- to;
        from --> common;
        to --> common;
      }
    }
    rec {
      from --> intermediate:Node;
      cftrtc:ChainFromToReverseToCommon(intermediate, to);

      replace(common:Node) {
        from <-- intermediate;
        from --> common;
        cftrtc(common);
      }
    }
  }

  replace(common:Node) {
    from; to;
  }
}

*As a straight-forward generalization of negatives within positive patterns,
negatives may get nested to an arbitrary depth. Matching of the nested
negative pattern causes the matching of the nesting pattern to fail.

test foo {
  a:NA --> b:NB;
  negative {
    a --> c:NC;
    negative {
      b --> c;
    }
  }
}

*Further examples are available at the examples and tests directories,
e.g. examples/TranskriptionAbstrakt, examples/ProgramGraphs
