\chapter{Application Programming Interface}\indexmain{application programming interface}
\label{chapapi}

This chapter describes the Application Programming Interface of \GrG, i.e. of the system runtime - the LibGr - and of the assemblies generated from the model and rule specifications.
We'll have a look at
\begin{itemize}
\item the interface to the model
\item the interface to the rules
\item the porter module for importing and exporting of graphs and miscellaneous stuff
\end{itemize}

From the input file \texttt{Foo.grg} \texttt{grgen.exe} generates the output files \texttt{FooModel.cs} for the model and \texttt{FooActions.cs} for the actions,
\begin{itemize}
\item defining the exact interface, 
\item implementing the exact interface with generated code and code from the lgsp backend, i.e. entities from \texttt{de.unika.ipd.grGen.lgsp} available from lgspBackend.dll, 
\item and implementing the generic interface from \texttt{de.unika.ipd.grGen.libGr} with the entities from both points above.
\end{itemize}

\begin{note}
If you work on the API level it is helpful to keep the generated source code which normally is thrown away 
after it was compiled into the assemblies lgsp-FooModel.dll and lgsp-FooActions.dll.
Use the \texttt{-keep} option when you call \texttt{grgen.exe} to do so.
\end{note}

\section{Interface to the host graph}

The generated file \texttt{FooModel.cs} opens the namespace \texttt{de.unika.ipd.grGen.Model\_Foo} containing all the generated entities.
It contains for every node or edge class \texttt{Bar} an interface \texttt{IBar}, which offers C\# properties giving access to the attributes, and is inheriting in the same way as specified in the model file.
This builds the exact interface of the model, it is implemented by a sealed class \texttt{Bar} with generated code and with code from the lgsp backend.
Furtheron the namespace contains a model class \texttt{FooGraphModel} implementing the interface \texttt{de.unika.ipd.grGen.libGr.IGraphModel},
which supports iteration over the entities defined in the model using further, generic(i.e. inexact) interfaces from libGr.
Finally, the namespace contains a class \texttt{Foo} which defines an lgsp-graph of a model equivalent to \texttt{FooGraphModel}; 
it contains convenience functions to easily create nodes and edges of exact type in the graph.

\begin{note}
If you want to use the type-safe interface, use the interface \texttt{IBar}, and the \texttt{CreateNodeBar}-methods of \texttt{Foo} or the \texttt{CreateNode}-method of \texttt{Bar}.
If you want to use the generic interface, your entry point is the \texttt{IGraphModel}, with \texttt{INodeModel.GetType("Bar")} returning a \texttt{NodeType}, used in \texttt{IGraph.AddNode(NodeType)} returning an \texttt{INode}.
\end{note}

\section{Interface to rules}

The generated file \texttt{FooActions.cs} opens the \texttt{namespace de.unika.ipd.grGen.Action\_Foo} containing all the generated entities.
It contains for every rule or test \texttt{bar}
\begin{itemize}
\item a class \texttt{Rule\_bar} inheriting from \texttt{de.unika.ipd.grGen.lgsp.LGSPRulePattern}, which contains
the exact match interface \texttt{IMatch\_bar} which defines how a match of the rule looks like,
extending the generic rule-unspecific \texttt{IMatch} interface.
Furtheron there are (but meant only for internal use): a match class \texttt{Match\_bar} implementing the exact and inexact interface,
a description of the pattern to match, and the modify methods doing the rewriting.
\item an exact action interface \texttt{IAction\_bar} which contains the methods:
  \begin{itemize}
  \item \texttt{Match}, to match the pattern in the host graph,
     with in-parameters corresponding to the in-parameters of the rule (name and type),
	 returning matches of the exact type \texttt{Rule\_bar.IMatch\_bar}.
  \item \texttt{Modify}, to modify a given match according to the rewrite specification,
     with out-parameters corresponding to the out-parameters of the rule.
  \item \texttt{Apply}, to match and modify the found match,
     with in-parameters corresponding to the in-parameters of the rule,
     and with ref-parameters corresponding to the out-parameters of the rule.
  \end{itemize}
  Furtheron there is (but meant only for internal use) the class \texttt{Action\_bar} implementing the exact action interface as well as the generic \texttt{IAction} interface from libGr;
  it contains the generated matcher code searching for the patterns.
\end{itemize}

Moreover the namespace contains an action class \texttt{FooActions}
implementing the abstract class \texttt{de.unika.ipd.grGen.libGr.BaseActions} (in fact \texttt{de.unika.ipd.grGen.lgsp.LGSPActions}),
which supports iteration over the entities defined in the actions using further, generic(i.e. inexact) interfaces from libGr.
Additionally, at runtime it contains the instances of the actions singletons,
as member \texttt{bar} of the exact type \texttt{IAction\_bar}.
\begin{note}
If you want to use the type-safe interface, your entry point is the member \texttt{bar} of type \texttt{IAction\_bar} from \texttt{FooActions} (or \texttt{Action\_bar.Instance}).
Actions are used with named parameters of exact types.
If you want to use the generic interface, your entry point is the method \texttt{GetAction("bar")} of the interface \texttt{BaseActions} implemented by \texttt{FooActions} returning an \texttt{IAction}.
Actions are used with \texttt{object}-arrays for parameter passing.
\end{note}

\begin{note}
The old generic interface of string names and entities of node-,edge-, and object-type is implemented with the new interface of exactly typed, named entities.
Thus you will receive runtime exceptions when doing operations which are not type-safe with the generic interface, in contrast to \GrG\ $<$ v2.5.
If you need the flexibility of the old input parameters semantics of silently failing rule application on a wrong type,
you must declare it explicitly with the syntax \verb#r(x:ExactType<InexactType>)#;
then the rule parameter in the exact interface will be of type \texttt{InexactType}.
\end{note}

\begin{example}
Normally you want to use the type-safe interface of the generated code as it is much more convenient.
Only if your application must get along with models and actions unknown before it is compiled you have to fall back to the generic interface.
An extensive example showing how to cope with the latter is shipped with \GrG\ in form of the GrShell.
Here we'll show a short example on how to use \GrG\ with the type-safe API; 
further examples are given in the examples-api folder of the \GrG-distribution.

We'll start with including the namespaces of the libGr and the lgsp backend shipped with \Grg\,
plus the namespaces of our actions and models, generated from \texttt{Foo.grg}.
\begin{verbatim}
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.lgsp;
using de.unika.ipd.grGen.Action_Foo;
using de.unika.ipd.grGen.Model_Foo;
\end{verbatim}

Then we create a graph with model bound at generation time and create actions to operate on this graph.
Afterwards we create a single node of type \texttt{Bar} in the graph and save it to the variable \texttt{b}.
Finally we apply the action \texttt{bar(Bar x) : (Bar)} to the graph with \texttt{b} as input receiving the output as well.
The rule is taken from the actions via the member named as the action.
\begin{verbatim}
Foo graph = new Foo();
FooActions actions = new FooActions(graph);
Bar b = graph.CreateNodeBar();
actions.bar.Apply(graph, b, ref b); // input of type Bar, output of type Bar
\end{verbatim}

This is an example doing mostly the same in a slightly more complicated way.
Here we create the model separate from the graph, then the graph with a model not bound at generation time.
We create the actions to apply on the graph, and a single node of type \texttt{Bar} in the graph, which we assign again to a variable \texttt{b}.
Then we get the action from the actions and save it to an action variable \texttt{bar};
afterwards we use the action for finding all available matches of \texttt{bar} with input \texttt{b} -- which is different from the first version -- and remember the found matches in the matches variable with its exact type.
Finally we take the first match from the matches and execute the rewrite with it.
We could have inspected the nodes and edges of the match or their attributes before (using element names prefixed with \texttt{node\_/edge\_} or attribute names to get exactly typed entities). 
\begin{verbatim}
IGraphModel model = new FooGraphModel();
LGSPGraph graph = new LGSPGraph(model);
FooActions actions = new FooActions(graph);
Bar b = Bar.CreateNode(graph);
IAction_bar bar = Action_bar.Instance;
IMatchesExact<Rule_bar.IMatch_bar> matches = bar.Match(graph, 0, b);
bar.Modify(graph, matches.First);
\end{verbatim}

\end{example}


\section{Import/Export and miscellaneous stuff}\label{sub:imexport}

GrGen natively supports the following formats:
\begin{description}
  \item[GRS] Reduced GrShell script files (graph only, model from \texttt{.gm}; a very limited version of the normal \texttt{.grs})
  \item[GXL] Graph eXchange Language (\texttt{.gxl}-files, see \url{http://www.gupro.de/GXL/})
  \item[EMF/ECORE] Eclipse Modeling Framework (model and graph; partial and only import).
      For \texttt{.ecore} files which describe the graph models, and \texttt{.xmi} files the graph instances.
	  The EMF exporter was added for the GraBaTs program comprehension case\cite{}
	  and it is to a certain degree a special purpose solution.
	  It is not supported, but you may take it as starting point of your own work if you need this feature. 
\end{description}

While both GRS and GXL importers expect one file
(the GXL importer allows to specify a model override, see GrShell import \ref{shellgxlimport}),
the EMF/ECORE importer expects first one or more \texttt{.ecore} files and following optionally a \texttt{.xmi} files and/or
a \texttt{.grg} file. To use additional custom graph models you should supply an own \texttt{.grg}
file which may be based on the automatically generated \texttt{.grg} file, if none was
supplied (see the Program-Comprehension example in \texttt{examples/ProgramComprehension-GraBaTs09}).

To import a graph model and/or a graph instance you can use \texttt{Porter.Import()} from the libGr API (the GrShell command \texttt{import} is mapped to it)
The file format is determined by the file extensions.
To export a graph instance you can use \texttt{Porter.Export()} from the libGr API (the GrShell command \texttt{export} is mapped to it).
For an example of how to use the importer/exporter on API level see \texttt{examples-api/JavaProgramGraphsExample/JavaProgramGraphs\-Example.cs}

There are further examples available in the \texttt{examples-api} folder of the \GrG-distribution:
\begin{itemize} 
\item How to use the graph rewrite sequences offered by the libGr on API level is shown in\\
\texttt{examples-api/BusyBeaverExample/BusyBeaverExample.cs}.\\
But normally you want to use your favourite .NET programming language for control together with the type-safe interface when working on API level.
\item How to use the visited\label{apiallocvisitflag} flags on API level is shown in\\
\texttt{examples-api/VisitedExample/VisitedExample.cs}.
\item How to analyze the graph and generate (hopefully) better performing matchers based on this information is shown in\\
\texttt{examples-api/BusyBeaverExample/BusyBeaverExample.cs}.
\item How to compile a \texttt{.grg}-specification at runtime and dump a graph for visualization in \texttt{.vcg} format on the API level is shown in\\
\texttt{examples-api/HelloMutex/HelloMutex.cs}.
\item How to communicate with yComp on the API level (from your own code) is shown in\\
\texttt{examples-api/YCompExample/YCompExample.cs}.
\end{itemize}

\begin{note}
\LibGr\ allows for splitting a rule application into two steps:
Find all the subgraphs of the host graph that match the pattern first, then rewrite one of these matches. 
By returning a collection of all matches, the \LibGr\ retains the complete graph rewrite process under control.
As a \LibGr\ user have a look at the following methods of the \texttt{IAction} interface:
\begin{csharplet}
IMatches Match(IGraph graph, int maxMatches, object[] parameters);
object[] Modify(IGraph graph, IMatch match);
\end{csharplet}

In C\#, this might look like:
\begin{csharplet}
IMatches myMatches = myAction.Match(myGraph, -1, null); /* -1: get all the matches */
for(int i=0; i<myMatches.NumMatches; ++i)
{
	if(inspectCarefully(myMatches.GetMatch(i))
	{
		myAction.Modify(myGraph, myMatches.GetMatch(i));
		break;
  	}
}
\end{csharplet}
\end{note}
