\chapter{Application Programming Interface}\indexmain{application programming interface}
\label{chapapi}

This chapter describes the Application Programming Interface of GrGen.NET, i.e. of the sytem runtime - the LibGr - and of the assemblies generated from the model and rule specifications.
The LibGr offers
\begin{itemize}
\item interface to host graph
\item porter module for importing and exporting of graphs
\item interface to the rules and xgrs execution
\end{itemize}

\section{Interface to the host graph}

\section{Import/Export}

GrGen natively supports the following formats:
\begin{description}
  \item[GRS] GrShell script files (graph only; a very limited version of the normal grs)
  \item[GXL] Graph eXchange Language (graph only, see http://www.gupro.de/GXL/)
  \item[EMF/ECORE] Eclipse Modeling Framework (model and graph; partial and only import).
      .ecore files describe the graph models, .xmi files the graph instances.
\end{description}

To import a graph model and/or a graph instance you can use
\verb#Porter.Import()# from the libGr API (the GrShell command \verb#import# is mapped to it)
In any case the file format is determined by the file extensions.
While both GRS and GXL importers expect exactly one file, the EMF/ECORE importer
expects first one or more .ecore files and following optionally a .xmi files and/or
a .grg file. To use additional custom graph models you should supply an own .grg
file which may be based on the automatically generated .grg file, if none was
supplied (see the Program-Comprehension example).

To export a graph instance you can use Porter.Export() from the libGr API (
the GrShell command \verb#export# is mapped to it)


\section{Interface to rules and xgrs execution}

Graph model and rewrite rule entities are mapped to the following code entities.
For every action=rule or test in the Bar.grg, 
several classes are generated in \verb#namespace Action_Bar#.
For example for a rule foo, you get
\begin{itemize}
\item a \verb#LGSPRulePattern#-object \verb#Rule_foo# containing
  \begin{itemize}
  \item a match interface \verb#IMatch_foo# which defines how a match of the rule looks like, extending the (old) rule-unspecific \verb#IMatch# interface.
  \item and internal: a match implementation \verb#Match_foo#.
  \item and internal: a description of the pattern to match.
  \item and internal: the modify methods doing the rewriting.
  \end{itemize}
\item an action interface \verb#IAction_foo# which contains the methods:
  \begin{itemize}
  \item \verb#Match#, to match the pattern in the host graph,
     with in parameters corresponding to the in parameters of the rule,
	 returning matches of type \verb#Rule_foo.IMatch_foo#.
  \item \verb#Modify#, to modify a given match according to the rewrite specification,
     with out parameters corresponding to the out parameters of the rule.
  \item \verb#Apply#, to match and modify the found match 
     with in parameters corresponding to the in parameters of the rule,
     with ref parameters corresponding to the out parameters of the rule.
   \end{itemize}
\item and internal: its implementation \verb#Action_foo#,
   extending the (old) rule-unspecific \verb#IAction# interface,
   containing the generated matcher program(s) searching for the pattern.
\end{itemize}
The action instances are available in the \verb#BarActions# class,
  as member foo of type \verb#IAction_foo#.
These files and classes use further classes representing the node and edge types,
which are generated in \verb#namespace Model_Bla#, according to the model file Bla.gm.

The actions expect inputs of correct type; the old input parameters semantics
of silently failing rule application on a wrong type is now only available 
with the syntax \verb#r(x:ExactType<InexactType>)#, with InexactType showing up in the API,
and the rule failing if the given element is not of ExactType)

\LibGr\ allows for splitting a rule application into two steps: Find all the subgraphs of the host graph that match the pattern and rewrite one of these matches. 
By returning a collection of all matches, the \LibGr\ retains the complete graph rewrite process under control.
As a \LibGr\ user have a look at the following methods of the \verb#IAction# interface:
\begin{csharplet}
IMatches Match(IGraph graph, int maxMatches, IGraphElement[] parameters);
IGraphElement[] Modify(IGraph graph, IMatch match);
\end{csharplet}
In C\#, this might look like:
\begin{csharplet}
IMatches myMatches = myAction.Match(myGraph, -1, null); /* -1: get all the matches */
for (int i = 0; i < myMatches.NumMatches; i++)
{
	if (inspectCarefully(myMatches.GetMatch(i))
	{
		myAction.Modify(myGraph, myMatches.GetMatch(i));
		break;
  	}
}
\end{csharplet}


