\chapter{Rule application language}\indexmain{rule application language}
\label{cha:xgrs}

Graph rewrite sequences (GRS)\indexmain{graph rewrite sequence} (or extended graph rewrite sequences XGRS, to distinguish them from the older graph rewrite sequences) are a domain specific \GrG language used for controlling the application of graph rewrite rules. They may be used
\begin{itemize}
\item as an imperative enhancement to the rule set language.
\item for controlled rule application within the GrShell
\item for controlled rule application on the API level out of user programms
\end{itemize}

If they appear in rules, they get compiled, otherwise they get interpreted.
Iff used within GrShell, they are amenable to debugging.

Graph rewrite sequences are syntactically expressed as expressions similar to boolean and regular expressions.
Composing an expression out of single graph rewrite rules not only yields more complex host graph operations but also determines sort of a control flow by means of evaluation order of the operands.
Graph rewrite sequences have a boolean return value; for a single rule, \texttt{true} means the rule was successfully applied to the host graph.
A \texttt{false} return value means that the pattern was not found in the host graph.
Graph rewrite sequences can be processed \indexed{transaction}ally by using angle brackets (\texttt{<>}).
If the return value is \texttt{false}, all the related operations on the host graph will be rolled back.
Nested transactions\indexmainsee{nested transaction}{transaction} are supported.

In order to store return values of rewrite terms and to pass return values of rules to other rules, \emph{variables} can be defined.
A variable is an arbitrary identifier which is defined by assigning a graph element, a boolean value, or another variable to it.
You may use named graph elements of the enclosing rule as read-only variables.
A parameter is alive from its first assignment until the end of the enclosing \texttt{exec} statement.

Note that we have two kinds of return values in graph rewrite sequences.
Every rewrite term returns a boolean value, indicating whether the rewriting could be successfully processed.
Additionally rules may return graph elements.
These return values can be assigned to variables on the fly (see example \ref{ex:grsreturn}).
\begin{figure}[htbp]
\begin{example}
	\label{ex:grsreturn}
	The graph rewrite sequence
	\begin{grgen}	 
a = ((b,c) = R(x,y,z))
	\end{grgen}
	is valid. 
	It assigns returned graph elements from rule \texttt{R} to variables \texttt{b} and \texttt{c} and the information whether \texttt{R} mached or not to variable \texttt{a}.
\end{example}
\end{figure}

\section{Rewrite sequence}

\makeatletter

\begin{rail}
  RewriteSequence: 
    (RewriteNegTerm) (( (dollar)? (ampersand | xorhat | '|' | doubleampersand | '||' | ';>' | '<;') RewriteNegTerm )*)
	;
  RewriteNegTerm: 
    ('!')? RewriteTerm
	;
\end{rail}\ixnterm{RewriteSequence}

A graph rewrite sequence consists of several, logically linked rewrite terms.
The modifier \texttt{\$} flags the following operator to act commutative: Usually operands are executed / evaluated from left to right with respect to bracketing (left-\indexed{associative}). 
In contrast the sequences \texttt{s}, \texttt{t}, \texttt{u} in \texttt{s \$<op> t \$<op> u} are executed / evaluated in arbitrary order.
The following table gives the priorities and semantics of the operators, the more to the top the higher the priority;
Then-Left and Then-Right are of the same priority, their execution order can't be altered by the \$ operator prefix.

\begin{table}[htbp]
    \begin{tabularx}{\linewidth}{l|X}
        \bf Operator & \bf Meaning \\\hline\hline
        \verb/!s/ & Negation, evaluates \texttt{s} and returns its logical negation\\\hline
        \verb/s1 & s2/ & Strict And, evaluates \texttt{s1} then \texttt{s2}, the result is the logical conjunction\\\hline
        \verb/s1 ^ s2/ & Strict Xor, evaluates \texttt{s1} then \texttt{s2}, the result is the logical antivalence\\\hline
        \verb/s1 | s2/ & Strict Or, evaluates \texttt{s1} then \texttt{s2}, the result is the logical disjunction\\\hline
        \verb/s1 && s2/ & Lazy And, the result is the logical conjunction, evaluates \texttt{s1}, only if \texttt{s1} is true \texttt{s2} gets evaluated\\\hline
        \verb/s1 || s2/ & Lazy Or, the result is the logical disjunction, evaluates \texttt{s1}, only if \texttt{s1} is false \texttt{s2} gets evaluated\\\hline
        \verb/s1 <; s2/ & Then-Left, evaluates \texttt{s1} then \texttt{s2} and returns the result of \texttt{s1}\\
		\verb/s1 ;> s2/ & Then-Right, evaluates \texttt{s1} then \texttt{s2} and returns the result of \texttt{s2}\\\hline
    \end{tabularx}    
    \caption{Semantics and priorities of rewrite sequence operators}
    \label{tbl:sequ:op}
\end{table}

\begin{rail}
  RewriteTerm: 
    (RewriteFactor (() | ('*' | '+' | '[' Number ']' | '[' Number ':' ( Number | '*' ) ']')));
\end{rail}\ixnterm{RewriteTerm}

A rewrite term can be executed multiple times: The star (\texttt{*}) executes a sequence repeatedly as long as its execution does not fail. 
Such a sequence always returns \texttt{true}.
A sequence \verb#s+# is equivalent to \verb#s && s*#.
The brackets (\texttt{[m]}) execute a sequence repeatedly as long as its execution does not fail but \emph{m} times at most; the min-max-brackets (\texttt{[n:m]}) additionally fail if the minimum amount \emph{n} of iterations was not reached.

\section{Rewrite factor}

\begin{rail} 
  RewriteFactor: 
    RuleExecution |
    VariableHandling |
	'if' lbrace Condition ';' TrueCase ';' FalseCase rbrace |
	'if' lbrace Condition ';' TrueCase rbrace |
    '<' RewriteSequence '>' | 
    '(' RewriteSequence ')' |
    BoolLiteral;
\end{rail}\ixnterm{RewriteFactor}\ixkeyw{def}\ixkeyw{true}\ixkeyw{false}\indexmain{\texttt{<>}}
Rewrite factors are the building blocks of graph rewrite sequences.
They either act as a rule application or assign a value to a variable.

\begin{rail}    
  RuleExecution: (() | '(' (Variable+',') ')' '=') \\ (() | percent) (() | '?') ( (dollar ( Number | ()) | ()) '[' Rule ']' | Rule);   
  Rule: RuleIdent (() | '(' (Variable+',') ')');
\end{rail}\ixnterm{RuleExecution} \ixnterm{Rule} 
The \emph{RuleExecution} clause applies a single rule or test.
In case of a rule, the first found pattern match will be rewritten.
Variables and named graph elements from the enclosing rule can be passed.
The returned graph elements can be assigned to variables again.
The operator \texttt{?} switches the rule to a test, i.e.\ the rule application does not perform the rewrite part of the rule but only tests if a match exists.
The operator \texttt{\%} is a multi-purpose flag. In the \GrShell\ (see chapter \ref{chapgrshell}) it dumps the matched graph elements to \texttt{stdout}; in \texttt{debug}-mode (see section \ref{sct:debugger}) it acts as a \indexed{break point}; you are also able to use this flag for your own purposes, when using \GrG\ via its API interface (see section \ref{sct:API}).
The sqare braces (\texttt{[]}) introduce a special kind of multiple rule application: Every pattern match produced by the will be rewritten. \textbf{Be careful:} Its semantics is not equal to \texttt{Rule*}. Instead this operator collects all the matches first before starting rewritings. In particular the semantics is unsafe, i.e.\ one needs to avoid deleting a graph element that is bound by another match. If \emph{Rule} returns values, the values of \emph{one} of the executed rules will be returned.
The random-match-selector \texttt{\$n} searches for all matches and then randomly selects \texttt{n} of them to be rewritten, with \texttt{\$[r1]} being equivalent to \texttt{\$1[r1]}.

\begin{rail}
  VariableHandling: 
    (Variable (':' Type)? '=' 
	  (Variable | 
      '(' RewriteSequence ')' | 
      Literal | 
	  Variable '.' Attribute)
    ) |
	Variable '.' Attribute '=' Variable |
    Variable |
    'def' '(' (Variable+',') ')'
;
\end{rail}\ixnterm{VarAssignment}\ixnterm{Variable}\makeatother
Variables can hold graph elements, or values of attribute types, esp. boolean values.
Graph elments are initially assigned by the \emph{RuleExecution} statement.
A \emph{VarAssignment} rewrite term ist always true.
A variable in the \emph{Variable} term must contain a boolean value, accordingly.
A \texttt{def} term is successful if all the the variables are defined.

TODO: literal irgendwo definiert?

 
\section{Storages}

Storages are Set of Node / Edge 
- in contrast to the set/map in models and rules where S/T can only be primitive types or enums,
 S/T may be of node/edge typ. This is not only a may be, but this is their primary task:
 acting as sets/maps of nodes/edges, storing them and allowing iteration over them,
 giving storages/storagemaps (names chosen to resemble the storages of VMTS where this concepts originats from)

 The already known, now with set/map types, which are ... .
 
\begin{rail}
  VariableHandling: 
    Variable (SetMapTypeDecl)? '=' RHS |
    SetVariable '.' ( 'add' '(' Value ')' | 'rem' '(' Value ')' | 'clear' '(' ')' ) |
    MapVariable '.' ( 'add' '(' Key ',' Value ')' | 'rem' '(' Key ')' | 'clear' '(' ')' ) |
	Variable '.' Attribute '=' Variable |
	Variable '=' MapVariable '[' Variable ']'
    ;
\end{rail}\ixnterm{VarAssignment}\ixnterm{Variable}\makeatother

\begin{rail}
  SetMapTypeDecl: 
    ':' ('set' '<' Type '>' | 'map' '<' KeyType ',' ValueType '>')
    ;
  RHS:
    'set' '<' Type '>' |
    'map' '<' KeyType ',' ValueType '>' |
	Variable |
	Variable '.' Attribute |
    SetVariable '.' ( size '(' ')' | empty '(' ')' ) |
    MapVariable '.' ( size '(' ')' | empty '(' ')' )
    ;
\end{rail}\ixnterm{VarAssignment}\ixnterm{Variable}\makeatother

Set addition: adds value to the set, e.g. n.add("foo")
Set removal: removes value from set, e.g. n.remove("bar")
Set clearing: removes all value from the set

Map addition: adds pair (key,value) to map, e.g. n.add("foo" ',' 42)
Map removal: removes pair (key,*) from map, e.g. n.remove("bar")
Map clearing: removes all key-value-pairs from the map

Assigns to a variable, of declared set type (optional in interpreted, requires in compiled XGRS).
Assigns to a variable, of declared map type (optional in interpreted, required in compiled XGRS).
Set assignment, writes the number of set entries to the variable, e.g. n.size().
Map size assigment, writes the number of map entries to the variable, e.g. x=n.size().

- set/map membership query el in sm succeeding iff el is contained in the set/map
- map lookup assignment val=mp[el] assigning the result of a map lookup to a variable, 
     succeeding iff el is contained in mp, otherwise failing, not touching the variable
- set/map emptyness query result assignment se=sm.empty() assigning to the variable 
     whether set/map is empty, always succeeding

\begin{rail}
  RewriteFactor:
    Var 'in' SetVar |
    Var 'in' MapVar |
    'for' lbrace Var 'in' SetVar ';' RewriteSequence rbrace |
    'for' lbrace Var '->' Var 'in' MapVar ';' RewriteSequence rbrace
\end{rail}
The for command iterates over all elements in the set or all key-value pairs in the map and executes for each element / key-value pair the graph rewrite sequence; it completes successfully if all sequences executed were successful.

Example:
\verb#foreach n in x do (y)=foo(n) && u.insert(y) && foreach m in z do bar(m) || v.remove(m) od od && foreach n in x do (m)=n && (m)=foo(m)*#

\verb#x:map<Node,Edge> foreach n->e in x do (y,z)=foo(n,e) x.insert(y -> z) foreach n->e in x do bar(n,e) || x.remove(n)#

\section{Quick reference table}

Table~\ref{ruletab} lists operations of graph rewrite expressions at a glance.

\makeatletter
\begin{table}[htbp]
\begin{minipage}{\linewidth} \renewcommand{\footnoterule}{} 
\begin{tabularx}{\linewidth}{|lX|}
\hline
\texttt{s | t}		& First execute \texttt{s} afterwards execute \texttt{t}. The sequence \texttt{s | t} is successfully executed if \texttt{s} or \texttt{t} is successfully executed.\\
\texttt{s || t}	& The same as \texttt{s | t} but with lazy evaluation, i.e.\ if \texttt{s} is successful, \texttt{t} will not be executed,\\
\texttt{s \& t}	& First execute \texttt{s}, afterwards execute \texttt{t}. The sequence \texttt{s \& t} is successfully executed if \texttt{s} and \texttt{t} is successful.\\
\texttt{s \&\& t}	& The same as \texttt{s \& t} but with lazy evaluation, i.e.\ if \texttt{s} fails, \texttt{t} will not be executed.\\
\texttt{s \^\ t}	& First execute \texttt{s} afterwards execute \texttt{t}. The sequence \texttt{s \^\ t} is successfully executed if \texttt{s} is successful or \texttt{t} successfully but not both; i.e.\ this an XOR sequence.\\
\texttt{<s>}	& Execute \texttt{s} transactionally.\\
\texttt{!s}		& Switch the result of \texttt{s} from successful to fail and vice versa.\\
\texttt{\$<op>}	& Flag the operator \texttt{<op>} as commutative. \\
\texttt{s *}		& Execute \texttt{s} repeatedly as long as its execution does not fail.\\
\texttt{s +}		& Same as \texttt{s \&\& s *}.\\
\texttt{s [n]}	& Execute \texttt{s} repeatedly as long as its execution does not fail but \texttt{n} times at most.\\
\texttt{s [m:n]}	& Same as \texttt{s [n]} but fails if executed less than m times.\\
\texttt{s [m:*]}	& Same as \texttt{s *} but fails if executed less than m times.\\
\texttt{?\emph{Rule}} & Switches \emph{Rule} to a test. \\
\texttt{\%\emph{Rule}} & This is the multi-purpose flag when accessed from \LibGr. Also used for graph dumping and break points. \\
\texttt{[\emph{Rule}]} & Rewrite every pattern match produced by the action \emph{Rule}.\\
\texttt{def(\emph{Parameters})} & Check if all the variables are defined.\\
\texttt{true}	& A constant acting as a successful match.\\
\texttt{false}	& A constant acting as a failed match.\\ \hline
\end{tabularx}\indexmain{\texttt{\textasciicircum}}\indexmain{\texttt{\&\&}@\texttt{"|}}
\indexmain{\texttt{\&}}\indexmain{\texttt{\$<op>}}\indexmain{\texttt{*}}\indexmain{\texttt{"!}}
\end{minipage}\\
\\ 
{\small Let \texttt{s}, \texttt{t}, \texttt{u} be graph rewrite sequences, \texttt{v}, \texttt{w} variable identifiers, \texttt{<op>} $\in \{\texttt{|}, \texttt{||}, \texttt{\&}, \texttt{\&\&}\}$ and \texttt{n}, \texttt{m} $\in \N_0$.}
\caption{GRS expressions at a glance}
\label{ruletab}
\end{table}
\makeatother
 
 