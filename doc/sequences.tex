\chapter{Rule application language}\indexmain{rule application language}
\label{cha:xgrs}

Graph rewrite sequences (GRS)\indexmain{graph rewrite sequence} (or extended graph rewrite sequences XGRS, to distinguish them from the older graph rewrite sequences) are a domain specific GrGen.NET language used for controlling the application of graph rewrite rules. They may be used
\begin{itemize}
\item as an imperative enhancement to the rule set language.
\item for controlled rule application within the GrShell
\item for controlled rule application on the API level out of user programms
\end{itemize}

If they appear in rules, they get compiled, otherwise they get interpreted.

Graph rewrite sequences are syntactically expressed as expressions similar to boolean expressions.
Composing an expression out of single graph rewrite rules not only yields more complex host graph operations but also determines sort of a control flow by means of evaluation order of the operands.
Graph rewrite sequences have a boolean return value; for a single rule, \texttt{true} means the rule was successfully applied to the host graph.
A \texttt{false} return value means that the pattern was not found in the host graph.
Graph rewrite sequences can be processed \indexed{transaction}ally by using angle brackets (\texttt{<>}).
If the return value is \texttt{false}, all the related operations on the host graph will be rolled back.
Nested transactions\indexmainsee{nested transaction}{transaction} are supported.

In order to store return values of rewrite terms and to pass return values of rules to other rules, \emph{variables} can be defined.
A variable is an arbitrary identifier which is defined by assigning a graph element, a boolean value, or another variable to it.
You may use named graph elements of the enclosing rule as read-only variables.
A parameter is alive from its first assignment until the end of the enclosing \texttt{exec} statement.

Note that we have two kinds of return values in graph rewrite sequences.
Every rewrite term returns a boolean value, indicating whether the rewriting could be successfully processed.
Additionally rules may return graph elements.
These return values can be assigned to variables on the fly (see example \ref{ex:grsreturn}).
\begin{figure}[htbp]
\begin{example}
	\label{ex:grsreturn}
	The graph rewrite sequence
	\begin{grgen}	 
a = ((b,c) = R(x,y,z))
	\end{grgen}
	is valid. 
	It assigns returned graph elements from rule \texttt{R} to variables \texttt{b} and \texttt{c} and the information whether \texttt{R} mached or not to variable \texttt{a}.
\end{example}
\end{figure}

\section{Rewrite sequence}

\makeatletter

\begin{rail}
  RewriteSequence: 
    (('!')? RewriteTerm) (( (dollar)? (ampersand | xorhat | '|' | doubleampersand | '||') ('!')? RewriteTerm )*) ;
\end{rail}\ixnterm{RewriteSequence}

A graph rewrite sequence consists of several, logically linked rewrite terms.
The modifier \texttt{\$} flags the following operator to act commutative: Usually operands are executed / evaluated from left to right with respect to bracketing (left-\indexed{associative}). 
In contrast the sequences \texttt{s}, \texttt{t}, \texttt{u} in \texttt{s \$<op> t \$<op> u} are executed / evaluated in arbitrary order.

\begin{rail}
  RewriteTerm: 
    (RewriteFactor (() | ('*' | '+' | '[' Number ']' | '[' Number ':' ( Number | '*' ) ']')));
\end{rail}\ixnterm{RewriteTerm}

A rewrite term can be executed multiple times: The star (\texttt{*}) executes a sequence repeatedly as long as its execution does not fail. 
Such a sequence always returns \texttt{true}.
A sequence \verb#s+# is equivalent to \verb#s && s*#.
The brackets (\texttt{[m]}) execute a sequence repeatedly as long as its execution does not fail but \emph{m} times at most; the min-max-brackets (\texttt{[n:m]}) additionally fail if the minimum amount \emph{n} of iterations was not reached.

\section{Rewrite factor}

\begin{rail} 
  RewriteFactor: 
    RuleExecution |
    VarAssignment |
    '<' RewriteSequence '>' | 
    '(' RewriteSequence ')' |
    Variable |
    'def' '(' (Variable+',') ')' |
    'true' |
    'false';
\end{rail}\ixnterm{RewriteFactor}\ixkeyw{def}\ixkeyw{true}\ixkeyw{false}\indexmain{\texttt{<>}}
Rewrite factors are the building blocks of graph rewrite sequences.
They either act as a rule application or assign a value to a variable
A variable in the \emph{Variable} term must contain a boolean value, accordingly.
A \texttt{def} term is successful if all the the variables are defined.

\begin{rail}    
  RuleExecution: (() | '(' (Variable+',') ')' '=') \\ (() | percent) (() | '?') ( (dollar ( Number | ()) | ()) '[' Rule ']' | Rule);   
  Rule: RuleIdent (() | '(' (Variable+',') ')');
\end{rail}\ixnterm{RuleExecution} \ixnterm{Rule} 
The \emph{RuleExecution} clause applies a single rule or test.
In case of a rule, the first found pattern match will be rewritten.
Variables and named graph elements from the enclosing rule can be passed.
The returned graph elements can be assigned to variables again.
The operator \texttt{?} switches the rule to a test, i.e.\ the rule application does not perform the rewrite part of the rule but only tests if a match exists.
The operator \texttt{\%} is a multi-purpose flag. In the \GrShell\ (see chapter \ref{chapgrshell}) it dumps the matched graph elements to \texttt{stdout}; in \texttt{debug}-mode (see section \ref{sct:debugger}) it acts as a \indexed{break point}; you are also able to use this flag for your own purposes, when using \GrG\ via its API interface (see section \ref{sct:API}).
The sqare braces (\texttt{[]}) introduce a special kind of multiple rule application: Every pattern match produced by the will be rewritten. \textbf{Be careful:} Its semantics is not equal to \texttt{Rule*}. Instead this operator collects all the matches first before starting rewritings. In particular the semantics is unsafe, i.e.\ one needs to avoid deleting a graph element that is bound by another match. If \emph{Rule} returns values, the values of \emph{one} of the executed rules will be returned.
The random-match-selector \texttt{\$n} searches for all matches and then randomly selects \texttt{n} of them to be rewritten, with \texttt{\$[r1]} being equivalent to \texttt{\$1[r1]}.

\begin{rail}
  VarAssignment: Variable '=' (Variable | 
    '(' RewriteSequence ')' | 
    'true' | 
    'false');
\end{rail}\ixnterm{VarAssignment}\ixnterm{Variable}\makeatother
Variables can hold graph elements or boolean values.
Graph elments are initially assigned by the \emph{RuleExecution} statement.
An \emph{VarAssignment} rewrite term ist always true.

\section{Storages}

This is preliminary documentation for functionality which is not available in \GrG~2.5! It will only be available in \GrG~2.6.

Storages = Set of Node / Edge; as in VMTS; here in addition set/map of arbitrary basic types, and of Node/Edge types.

\begin{rail}
  'new' 'set' '<' Type '>'
\end{rail}\ixkeyw{new}\ixkeyw{set}
creates a new set of given type, e.g. v = new set<string>

\begin{rail}
  'NameOfSetVariable' '.' 'add' '(' Value ')'
\end{rail}\ixkeyw{add}\ixkeyw{set}
adds value to the set, e.g. n.add("foo")
Was ist mit n.a.add("foo")

\begin{rail}
  'NameOfSetVariable' '.' 'remove' '(' Value ')'
\end{rail}\ixkeyw{remove}\ixkeyw{set}
removes value from set, e.g. n.remove("bar")

\begin{rail}
  'NameOfSetVariable' '.' 'size' '(' ')'
\end{rail}\ixkeyw{size}\ixkeyw{set}
returns the number of set entries, e.g. n.size()

\begin{rail}
  'new' 'map' '<' KeyType ',' ValueType '>'
\end{rail}\ixkeyw{new}\ixkeyw{set}
creates a new map of given types, e.g. new map<string,int>

\begin{rail}
  'NameOfMapVariable' '.' 'add' '(' Key '->' Value ')'
\end{rail}\ixkeyw{add}\ixkeyw{map}
adds pair (key,value) to map, e.g. n.add("foo"->42)

\begin{rail}
  'NameOfMapVariable' '.' 'remove' '(' Key ')'
\end{rail}\ixkeyw{remove}\ixkeyw{set}
removes pair (key,*) from map, e.g. n.remove("bar")

\begin{rail}
  'NameOfMapVariable' '.' 'size' '(' ')'
\end{rail}\ixkeyw{size}\ixkeyw{set}
returns the number of map entries, e.g. n.size()

\begin{rail}
  'foreach' Variable (() | '->' Variable) 'in' Variable 'do' XGRS 'od'
\end{rail}
The foreach command iterates over all elements in the set or all key-value pairs in the map and executes for each element / key-value pair the graph rewrite sequence; it completes successfully if all sequences executed were successful.

Example:
\verb#foreach n in x do (y)=foo(n) && u.insert(y) && foreach m in z do bar(m) || v.remove(m) od od && foreach n in x do (m)=n && (m)=foo(m)*#

\verb#x:map<Node,Edge> foreach n->e in x do (y,z)=foo(n,e) x.insert(y -> z) foreach n->e in x do bar(n,e) || x.remove(n)#

\section{Quick reference table}

Table~\ref{ruletab} lists operations of graph rewrite expressions at a glance.

\makeatletter
\begin{table}[htbp]
\begin{minipage}{\linewidth} \renewcommand{\footnoterule}{} 
\begin{tabularx}{\linewidth}{|lX|}
\hline
\texttt{s | t}		& First execute \texttt{s} afterwards execute \texttt{t}. The sequence \texttt{s | t} is successfully executed if \texttt{s} or \texttt{t} is successfully executed.\\
\texttt{s || t}	& The same as \texttt{s | t} but with lazy evaluation, i.e.\ if \texttt{s} is successful, \texttt{t} will not be executed,\\
\texttt{s \& t}	& First execute \texttt{s}, afterwards execute \texttt{t}. The sequence \texttt{s \& t} is successfully executed if \texttt{s} and \texttt{t} is successful.\\
\texttt{s \&\& t}	& The same as \texttt{s \& t} but with lazy evaluation, i.e.\ if \texttt{s} fails, \texttt{t} will not be executed.\\
\texttt{s \^\ t}	& First execute \texttt{s} afterwards execute \texttt{t}. The sequence \texttt{s \^\ t} is successfully executed if \texttt{s} is successful or \texttt{t} successfully but not both; i.e.\ this an XOR sequence.\\
\texttt{<s>}	& Execute \texttt{s} transactionally.\\
\texttt{!s}		& Switch the result of \texttt{s} from successful to fail and vice versa.\\
\texttt{\$<op>}	& Flag the operator \texttt{<op>} as commutative. \\
\texttt{s *}		& Execute \texttt{s} repeatedly as long as its execution does not fail.\\
\texttt{s +}		& Same as \texttt{s \&\& s *}.\\
\texttt{s [n]}	& Execute \texttt{s} repeatedly as long as its execution does not fail but \texttt{n} times at most.\\
\texttt{s [m:n]}	& Same as \texttt{s [n]} but fails if executed less than m times.\\
\texttt{s [m:*]}	& Same as \texttt{s *} but fails if executed less than m times.\\
\texttt{?\emph{Rule}} & Switches \emph{Rule} to a test. \\
\texttt{\%\emph{Rule}} & This is the multi-purpose flag when accessed from \LibGr. Also used for graph dumping and break points. \\
\texttt{[\emph{Rule}]} & Rewrite every pattern match produced by the action \emph{Rule}.\\
\texttt{def(\emph{Parameters})} & Check if all the variables are defined.\\
\texttt{true}	& A constant acting as a successful match.\\
\texttt{false}	& A constant acting as a failed match.\\ \hline
\end{tabularx}\indexmain{\texttt{\textasciicircum}}\indexmain{\texttt{\&\&}@\texttt{"|}}
\indexmain{\texttt{\&}}\indexmain{\texttt{\$<op>}}\indexmain{\texttt{*}}\indexmain{\texttt{"!}}
\end{minipage}\\
\\ 
{\small Let \texttt{s}, \texttt{t}, \texttt{u} be graph rewrite sequences, \texttt{v}, \texttt{w} variable identifiers, \texttt{<op>} $\in \{\texttt{|}, \texttt{||}, \texttt{\&}, \texttt{\&\&}\}$ and \texttt{n}, \texttt{m} $\in \N_0$.}
\caption{GRS expressions at a glance}
\label{ruletab}
\end{table}
\makeatother
 
 