\chapter{Rule Set Language}

The rule set language forms the core of \GrG. Rule files refer to one or multiple graph models and specify a set of (usually coherent) rewriting rules. The rule language covers the pattern specification, the replace specification and optionally re-evaluation of graph element's attributes. The following rewriting rule from \cite{geiss} gives a rough picture of the language:
\begin{grgen}
rule SomeRule {
  pattern {
    n1 : NodeTypeA;
    n2 : NodeTypeA;
    hom(n1, n2);
    n1 --> n2;
    n3: NodeTypeB;
    negative {
      n3 -e1:EdgeTypeA-> n1;
      if {n3.a1 == 42*n2.a1;}
    }
    negative {
      n4: Node\NodeTypeB;
      n3 -e1:EdgeTypeB->n4;
    }
  }
  replace {
    n5: NodeTypeC<n1>;
    n3 -e1:EdgeTypeB-> n5;
    eval {
      n5.a3 = n3.a1*n1.a2;
    }
  }  
}
\end{grgen}
In this chapter we use pieces of \texttt{SomeRule} in further descriptions.

\section{Building Blocks}
\label{rulebb}

The \GrG\ rule set language is case sensitive. The language makes use of a couple of identifier specializations in order to denominate all the \GrG\ entities.\\
\\
\emph{Ident}, \emph{IdentDecl}\\ \nopagebreak
A character sequence of arbitrary length consisting of letters, digits or underscores. The first character must not be a digit. \emph{Ident} may be an identifier defined in a graph model (see \ref{modelbb}). \emph{IdentDecl} is an identifier that is just beeing defined. See \ref{annotations} for annontations on declarations.\\
\\
\emph{ModelIdent}, \emph{TypeIdent}, \emph{NodeType}, \emph{EdgeType}\\
These are (semantic) specializations of Ident. \emph{TypeIdent} matches every type identifier, i.e. a node type, an edge type, an enum type or a primitive type. All the type identifiers are actually type \emph{expressions}. See \ref{typeexpressions} for the use of type expressions.\\

\begin{rail}
  ForwardEdge: '-' EdgeRefinement '->' ;
  ReverseEdge: '<-' EdgeRefinement '-' ;  
  EdgeRefinement: () | Ident | ':' EdgeType | Ident ':' EdgeType (() | TypeConstraint) ;
\end{rail}
In general edges are specified by \texttt{-->} or \texttt{<--}. Those edges are called \emph{anonymous}. For a more detailed specification use an edge refinement clause between the arrow dashes. See \ref{typeexpressions} for \emph{TypeConstraint}.

\section{Declarations}
\label{ruledecls}
\begin{rail}
  'actions' IdentDecl 'using' ((ModelIdent)+',') ';' \\ ((TestDeclaration | RuleDeclaration)+) ;
\end{rail}
A rule set consists of the underlying graph models and several rewriting rules. In case of multiple graph models \GrG\ use the unification of the models. In this case beware of conflicting declarations.

\begin{rail}
  TestDeclaration: 'test' ActionSignature lbrace Pattern rbrace ;
  RuleDeclaration: 'rule' ActionSignature lbrace Pattern Replace rbrace ;
\end{rail}
Declares a single rewriting rule such as \texttt{SomeRule}. It consists of a pattern part (see \ref{patternpart}) together with its rewrite / modify part (see {replacepart}). A test rule has no rewrite specification. It's intended to test wether (and maybe how many times) a pattern occurs.\\
{\small \textbf{Example:} We define a test rule \texttt{SomeCond}}
\begin{grgen}
test SomeCond {
  pattern {
    n: SeldomNodeType;
  }
}
\end{grgen}
{\small and execute in GrShell:}
\begin{grshell}
  grs SomeCond & SomeRule
\end{grshell}
{\small SomeRule will only be executed, if a node of type \texttt{SeldomNodeType} exists. For regular graph rewriting sequences in GrShell see \ref{grsthings}.}

\begin{rail}  
  ActionSignature: IdentDecl (() | Parameters) (() | ':' ReturnTypes) ;
\end{rail}
The signature sets the name of a rewriting rule to \emph{IdentDecl}. Additionally you can provide parameters to the rule an specify return types.

\begin{rail}
  Parameters: '(' (IdentDecl ':' (NodeType | EdgeType) + ',') ')' ;
  ReturnTypes: '(' ((NodeType | EdgeType) + ',') ')' ;
\end{rail}
Parameters are treated as predefined graph elements for the pattern. The return values are graph elements of the replace / modify part. If no pattern is found or the \texttt{return} operator is omitted, the return values are undefined. See also \ref{replacepart}, \texttt{return}. Undefined parameters are treated as node or edge definition. That means a graph element of the specified type will be attempted to matched.\\
{\small \textbf{Example:} we extend \texttt{SomeRule} with a variable node to find, and we want it to return the rewritten graph elements \texttt{n5} and \texttt{e1}.}
\begin{grgen}
  rule SomeRuleExt(varnode: Node): (Node, EdgeTypeB) {
    pattern{
      varnode;
      n1: NodeTypeA;
      ...
    }
    replace {
      varnode;
      ...  
      return(n5, e1);
      eval {
        ...
\end{grgen}

\section{Pattern Part}
\label{patternpart}
\begin{rail}
  Pattern: 'pattern' lbrace (()+PatternStatement) rbrace ;
\end{rail}
A pattern consists of zero, one or several pattern statements. A match in a host graph must be a subset of graph elements, such that each pattern statement is fulfilled and the subset is of minimum size. Even stronger -- a graph element of the host graph, that is matched by a statement, is ``bound'', i.e. it can not be part of another pattern statement, unless you use the \texttt{hom} operator. An empty pattern always produces exactly one match.\\
Pattern statements may define variables for use by other pattern statements or replace statements. Such variables may be used before declaration.\\
Note that the application of a rule is not deterministic, specifically there may be more than one sub graph that matches the pattern and any of them may be selected.

\begin{rail}  
  PatternStatement: (PatternNode+',') ';' |
    PatternConnections ';' |
    'hom' '(' (Ident + ',') ')' |
    'negative' lbrace (()+PatternStatement) rbrace |
    'if' (BooleanExpr ';' | (lbrace (BooleanExpr ';' +) rbrace));
\end{rail}
The semantics of the various pattern statements:
\begin{description}
  \item[PatternNode.] Specify single nodes of a certain type to find.
  \item[PatternConnections.] Pattern connections specify a connected subgraph, i.e. certain node types connected by certain edge types.
  \item[Isomorphic/Homomorphic Matching.] The \texttt{hom} operator specify the nodes or edges, that may be matched homomorphically. In contrast to the default isomorphic matching, the specified graph elements \emph{may} be matched to the same graph element in the host graph. Note that the graph elements shall have a common subtype. If the match is not isomorphic, than the elements will be mapped to a common subtype.\\
  In our example \texttt{n1} and \texttt{n2} may be the same node. This is possible because they are of the  same type (\texttt{NodeTypeA}).
  \item[Negative Application Conditions (NACs).] With negative application conditions (keyword \texttt{negative}) we can specify graph patterns which forbid the application of a rule if any of them is present in the host graph (cf. \cite{adam}). NACs may not be nested. Variables defined within a NAC are not alive outside the NAC.\\
  In our example the second negative condition uses \texttt{n3} from the surrounding scope and defines \texttt{n4} and \texttt{e1}. We can safely reuse the variable name \texttt{e1} in the replace part.
  \item[Attribute Conditions.] The Java-like attribute conditions (keyword \texttt{if}) in the pattern part allows for further restriction of the applicability of a rule.
\end{description}
Keep in mind that using type constraints or the \texttt{typeof} operator might be helpful. See \ref{typeexpressions} for further information.

\begin{rail}   
  PatternNode: (IdentDecl ':' NodeType 
    | '(' (IdentDecl + ',') ')' ':' NodeType) 
     (() | TypeConstraint) ; 
\end{rail}
Specify one or multiple nodes of type \emph{NodeType} (with respect to \emph{TypeConstraint}) to find. See \ref{typeexpressions} for \emph{TypeConstraint}. The nodes can be accessed by \emph{Ident}.

\begin{rail}     
  PatternConnections: (Ident | PatternNode) (() | PatternContinuation) ;
  PatternContinuation: (ForwardEdge | ReverseEdge) (Ident | PatternNode) (() | PatternContinuation) |
    '(' (PatternContinuation+',') ')' ; 
\end{rail}
A pattern connection is specified piecewise. Start with a node and construct the subgraph with several pattern continuations. Instead of following a path by continuations you can also specify a set of continuations for a single node (for instance something like a star).\\
In our example the statement \texttt{n1 --> n2} is the node identifier \texttt{n1} followed by the pattern continuation \texttt{--> n2}.

\section{Replace / Modify Part}
\label{replacepart}
For the task of rewriting \GrG\ provides two different modes: a replace mode and a modify mode.
\begin{description}
  \item[Replace mode.] The semantics of this mode is to delete every graph element of the pattern that is not used (denoted) in the replace part, keep every graph element that is used and create denoted graph elements that are not used in the pattern part.\\
  In our example \texttt{SomeRuleExt} the nodes \texttt{varnode} and \texttt{n3} will be kept. The node \texttt{n1} is replaced by the node \texttt{n5} preserving \texttt{n1}'s edges. The anonymous edge instance between \texttt{n1} and \texttt{n2} only occurs in the pattern and therefore gets deleted.
  \item[Modify mode.] The modify mode can be regarded as a replace part in replace mode, where every pattern graph element is added (denoted) before the first replace statement. Additionally this mode supports the \texttt{delete} operator.\\
  How might our example look in modify mode? We have to denominate the anonymous edge between \texttt{n1} and \texttt{n2} in order to delete it. The node \texttt{varnode} can be omitted. So we have
\begin{grgen}
rule SomeRuleExt(varnode: Node): (Node, EdgeTypeB) {
  pattern {
    ...
    n1 -e0:Edge-> n2;
    ...
  }
  modify {
    n5 : NodeTypeC<n1>;
    n3 -e1:EdgeTypeB-> n5;
    delete(e0);
    eval {
      ...
\end{grgen}
\end{description}

\begin{rail}
  Replace: ('replace' | 'modify') lbrace (()+ReplaceStatement) rbrace ;
\end{rail}
Selects whether the replace mode or the modify mode is used. Several replace statements describe the transformation from the pattern subgraph to the destination subgraph.

\begin{rail}  
  ReplaceStatement: ((ReplaceNode+';') | 
    ReplaceConnections |
    'delete' '(' (Ident + ',') ')' |
    'eval' Evaluation |
    'return' '(' (Ident+',') ')' ) ';' ;
\end{rail}    
The semantics of the various pattern statements:
\begin{description}
  \item[ReplaceNode.] A single node that is either kept because it's a node of the pattern or added otherwise. \GrG\ supports \emph{retyping} of nodes by the \texttt{<>} operator.
  \item[ReplaceConnections.] The same as \emph{PatternConnections}, but with \emph{ReplaceNode} instead of \emph{PatternNode}.
  \item[Deletion.] The \texttt{delete} operator is only supported by the modify mode. It deletes the specified pattern graph elements. Deletion statements are executed at last of all replace statements. Multiple deletion of the same graph element is allowed.
  \item[Attribute Evaluation.] If a rule is applied, then the attributes of matched and inserted graph elements may be recalculated.
  \item[Return values.] Graph elements of the replace part can be returned according to the return types in the signature (see \ref{ruledecls}, \texttt{ActionSignature}). At most one return statement is allowed. The values have to be in the same order as the corresponding return types in the signature.
\end{description}    
    
\begin{rail}    
    ReplaceNode: IdentDecl ':' NodeType (() | '<' Ident '>') 
    | '(' (IdentDecl+',') ')' ':' NodeType ;
\end{rail}
The replace node specification supports \emph{retyping} of nodes. This enables us to keep all edged and all attributes stemming from common super types of a node while changing its type.\\ 
In our example node \texttt{n5} is a retyped node stemming from node \texttt{n1}

\begin{rail}
  ReplaceConnections: (Ident | ReplaceNode) (() | ReplaceContinuation) ;
  ReplaceContinuation:  (ForwardEdge | ReverseEdge) (Ident | ReplaceNode) (() | ReplaceContinuation) |
    '(' (ReplaceContinuation+',') ')' ;    
\end{rail}
See \ref{patternpart}, \emph{PatternConnections} and \emph{PatternContinuations}, for a description of the connections / continuations semantics.

\begin{rail}    
   Evaluation:  lbrace ((Ident ('.' Ident +) '=' Expression ';' )+) rbrace ;
\end{rail}
Several Evaluation parts are allowed within the replace part. Evaluation parts are executed before any graph elements get deleted. You can read (and write, although this doesn't make sense) attributes of deleted graph elements in modify mode or unmapped graph elements in replacement mode respectively.
