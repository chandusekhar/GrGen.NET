\chapter{Rule Set Language}

\section{Building Blocks}
\label{rulebb}

The \GrG\ rule set language makes use of a couple of identifier specializations in order to denominate all the \GrG\ entities. The language is case sensitive.\\
\\
\emph{Ident}\\ \nopagebreak
A character sequence of arbitrary length consisting of letters, digits or underscores. The first character must not be a digit. \emph{Ident} may be an identifier defines in a graph model (see \ref{modelbb}).\\
\\
\emph{RuleSetIdent}, \emph{TypeIdent}, \emph{NodeType}, \emph{EdgeType}\\
These are (semantic) specializations of Ident. \emph{TypeIdent} matches every type identifier, i.e. a node type, an edge type, an enum type or a primitive type. All the type identifiers are actually type \emph{expressions}. See \ref{typeexpressions} for the use of type expressions.\\

\begin{rail}
  ForwardEdge: '-' EdgeRefinement '->' ;
  ReverseEdge: '<-' EdgeRefinement '-' ;  
  EdgeRefinement: () | Ident | ':' EdgeType | Ident ':' EdgeType (() | TypeConstraint) ;
\end{rail}
In general edges are specified by \texttt{-->} or \texttt{<--}. Those edges are called \emph{anonymous}. For a more detailed specification use an edge refinement clause between the arrow dashes. See \ref{typeexpressions} for \emph{TypeConstraint}.

\section{Declarations}

\begin{rail}
  'actions' RuleSetIdent 'using' ((ModelName)+',') ';' \\ ((TestDeclaration | RuleDeclaration)+) ;
\end{rail}
A rule set consists of the underlying graph models and several rewriting rules. In case of multiple graph models \GrG\ use the unification of the models. In this case beware of conflicting declarations.

\begin{rail}
  TestDeclaration: 'test' ActionSignature lbrace Pattern rbrace ;
  RuleDeclaration: 'rule' ActionSignature lbrace Pattern Replace (() | Evaluation) rbrace ;
\end{rail}


\begin{rail}  
  ActionSignature: ActionIdent (() | Parameters) (() | ':' ReturnTypes) ;
  Parameters: '(' (() | (('node' Ident ':' NodeType | 'edge' Ident ':' EdgeType) + ',')) ')' ;
  ReturnTypes: '(' (() | (TypeName + ',') ) ')' ;
\end{rail}


\section{Pattern Part}
\begin{rail}
  Pattern: 'pattern' lbrace (()+PatternStatement) rbrace ;
  PatternStatement: PatternConnections ';' |
    'node' (PatternNode+',') ';' |
    'negative' lbrace (()+PatternStatement) rbrace |
    'if' (BooleanExpr ';' | (lbrace (BooleanExpr ';' +) rbrace)) |
    'return' '(' (Identifier+',') ')' ';' ;
\end{rail} 

\begin{rail}   
  PatternConnections: (Identifier | PatternNode) (() | PatternContinuation) ;
  PatternNode: (Identifier ':' NodeType 
    | '(' (Identifier + ',') ')' ':' NodeType
    | '(' Identifier (tilde Identifier+) ')' ':' NodeType ) \\
      (() | TypeConstraint) ; 
  PatternContinuation: (ForwardEdge | ReverseEdge) (Identifier | PatternNode) (() | PatternContinuation) |
    '(' (PatternContinuation+',') ')' ; 
\end{rail}

\section{Replace Part}
\emph{Note:} Although \GrG\ does -- in general -- graph re\emph{writing} (also called graph transformation) this part has a re\emph{place} semantics.
\begin{rail}
  Replace: 'replace' lbrace (()+ReplaceStatement) rbrace ;
  ReplaceStatement: (ReplaceConnections |
    'node' (ReplaceNode+';') | 
    'return' '(' (Identifier+',') ')' ) ';' ;
  ReplaceConnections: (Identifier | ReplaceNode) (() | ReplaceContinuation) ;
  ReplaceNode: Identifier ':' NodeType (() | '<' Identifier '>') 
    | '(' (Identifier+',') ')' ':' NodeType ;
  ReplaceContinuation:  (ForwardEdge | ReverseEdge) (Identifier | ReplaceNode) (() | ReplaceContinuation) |
    '(' (ReplaceContinuation+',') ')' ;    
\end{rail}

\section{Evaluation Part}
\begin{rail}
  Evaluation: 'eval' lbrace (() + Assignment) rbrace ;
  Assignment: Identifier ('.' Identifier +) '=' Expression ';'
\end{rail} 
