\chapter{Graph Model Language}\indexmain{graph model language}
\label{chapmodellang}
The key features of \GrG\ \emph{graph models}\indexmain{graph model} as described by Geiß et al.~\cite{GBGHS:06,KG:07} are given below:

\begin{description}
\item[Types] Nodes and edges are typed. 
  This is similar to classes in common programming languages, except for the concept of methods that \GrG\ nodes and edges don't support. 
\item[Attributes] Nodes and edges can possess attributes. The set of attributes assigned to a node or edge is determined by its type. The attributes themselves are typed, too.
\item[Inheritance] Node and edge types (classes) can be composed by multiple \indexed{inheritance}. \texttt{Node} and \texttt{Edge} are built-in root types of node and edge types, respectively. Inheritance eases the specification of attributes because subtypes inherit the attributes of their super types. Note that \GrG\ lacks a concept of overwriting. On a path in the \indexed{type hierarchy} graph from a type up to the built-in root type there must be exactly one declaration for each attribute identifier. Furthermore if multiple paths from a type up to the built-in root type exist, the declaring types for an attribute identifier must be the same on all such paths.
\item[Connection Assertions] To specify that certain edge types should only connect specific nodes, we include connection assertions. Furthermore the number of outgoing and incoming edges can be constrained.
\end{description}

\begin{figure}[htbf]
\begin{example}\label{ex:model:map}
The following toy example of a model of road maps gives a rough picture of the language:
\begin{grgen}
enum resident {village = 500, town = 5000, city = 50000}

node class sight;

node class city {
	size: resident;
}

const node class metropolis extends city {
  river: string;
}  

abstract node class abandoned_city extends city;
node class ghost_town extends abandoned_city;

edge class street;
edge class trail extends street;
edge class highway extends street
    connect metropolis [+] -> metropolis [+]
{
    jam: boolean;
}
\end{grgen}
\end{example}
\end{figure}
In this chapter as well as in chapter~\ref{chapgrshell} (\GrShell) we use excerpts of Example~\ref{ex:model:map} (the \texttt{Map} model) for illustration purposes.

\section{Building Blocks}
\label{modelbb}

\begin{note}
The following syntax specifications make heavy use of \newtermsee{syntax diagram}{rail diagram}s (also known as \indexed{rail diagram}s). Syntax diagrams provide a visualization of EBNF\footnote{Extended Backus–Naur Form.} grammars. Follow a path along the arrows through a diagram to get a valid sentence (or subsentence) of the language. Ellipses represent terminals whereas rectangles represent non-terminals. For further information on syntax diagrams see~\cite{MMJW:91}.
\end{note}
Basic elements of the \GrG\ graph model language are identifiers to denominate nodes, edges, and attributes. The model's name itself is given by its file name. The \GrG\ graph model language is \indexed{case sensitive}.\\
\\
\emph{Ident}, \emph{IdentDecl}\\ \indexmain{identifier}\nopagebreak
A non-empty character sequence of arbitrary length consisting of letters, digits, or underscores. The first character must not be a digit. \emph{Ident} and \emph{IdentDecl} differ in their role: While \emph{IdentDecl} is a \emph{defining} occurrence of an identifier, \emph{Ident} is a \emph{using} occurrence. An \emph{IdentDecl} non-terminal may be annotated\indexmain{annotation}. See Section~\ref{annotations} for annotations of declarations.
\begin{note}
\label{note:modeldecl}
  The \GrG\ model language does not distinguish between \indexed{declaration}s and \indexed{definition}s. More precisely, every declaration is also a definition. For instance, the following C-like pseudo \GrG\ model language code is illegal:
\begin{grgen}
node class t_node;
node class t_node {
  ...
}
\end{grgen}
Using an identifier before defining it is allowed. Every used identifier has to be defined exactly once.
\end{note}
\pagebreak
\emph{NodeType}, \emph{EdgeType}, \emph{EnumType}\\ \nopagebreak
These are (semantic) specializations of \emph{Ident} to restrict an identifier to denote a node type, an edge type, or an enum type, respectively.

\section{Type Declarations}
\label{typedecl}

\begin{rail}
  GraphModel: () + (ClassDeclaration | EnumDeclaration);
\end{rail}\ixnterm{GraphModel}
The \indexed{graph model} consists of zero or multiple type declarations. Whereas \emph{ClassDeclaration} defines a node type or an edge type, \emph{EnumDeclaration} defines an enum type for use as attribute of nodes or edges. Like all identifier definitions, types do not need to be declared\indexmain{declaration} before they are used.

\begin{rail}
  EnumDeclaration: 'enum' IdentDecl lbrace ((IdentDecl (() | '=' IntExpr)) + ',') rbrace ;
\end{rail}\ixkeyw{enum}\ixnterm{EnumDeclaration}
Defines an \indexed{enum type}.
An enum type is a collection of so called \emph{\indexed{enum item}s} that are associated with integral numbers, each.
Accordingly, a \GrG\ enum is internally represented as \texttt{int} (see Section~\ref{builtin}).
\begin{note}
	An enum type and an {\tt int} are different things, but in expressions enum values are implicitly casted to {\tt int} values 	(see section~\ref{builtin}).
\end{note}
\begin{note}
	Normally, assignments of {\tt int} values to something that has an enum type are forbidden (see section~\ref{builtin}).
	Only inside a declaration of an enum type an int value may be assigned to the enum item that is currently declared.
	This also includes the usage of items taken from other enum types (because they are implicitly casted to {\tt int}).
	However, items from other enum types must be written fully qualified in this case (which, e.g., looks like {\tt my\_enum::a}, where {\tt my\_enum} is the name of the other enum type).
\end{note}

\begin{example}
\begin{grgen}
enum Color {red, green, blue}
enum Resident {village = 500, town = 5000, city = 50000}
enum AsInC {a = 2, b, c = 1, d, e = (int)Resident::village + c}
\end{grgen}
Consider, e.g., the declaration of the enum item {\tt e}:
By implicit casts of   {\tt Resident::village } and {\tt c} to {\tt int} we get the {\tt int} value 501, which is assigned to {\tt e}.
Moreover, the semantics is as in C~\cite{Sch:1990:ANSIC}. So, the following holds: $\texttt{red} = 0$, $\texttt{green} = 1$, $\texttt{blue} = 2$, $\texttt{a}=2$, $\texttt{b}=3$, $\texttt{c}=1$, $\texttt{d}=2$, and $\texttt{e}=501$.
\end{example}
\begin{note}
	The C-like semantics of enum item declarations implies, that multiple items of one enum type can be associated with the same same {\tt int} value.
	Moreover, it implies, that an enum item must not be used \emph{before} its definition.
	This also holds for items of other enum types, meaning that the items of another enum type can only be used in the definition of an enum item, when the other enum type is defined \emph{before} the enum type currently defined.
\end{note}

\begin{rail}  
  ClassDeclaration: (() | 'abstract') (() | 'const') (NodeClass | EdgeClass);
\end{rail}\ixkeyw{abstract}\ixkeyw{const}\ixnterm{ClassDeclaration}
Defines a new node type or edge type. The keyword \texttt{abstract} indicates that you cannot instantiate graph elements of this type. Instead you have to derive non-abstract types to create graph elements. The abstract-property will not be inherited by subclasses, of course.

\begin{example}
We adjust our map model and make \texttt{city} abstract:
\begin{grgen}
abstract node class city {
	size: int;
}
abstract node class abandoned_city extends city;
node class ghost_town extends abandoned_city;
\end{grgen}
You will be able to create nodes of type \texttt{ghost\_town}, but not of type \texttt{city} or \texttt{abandoned\_city}. However, nodes of type \texttt{ghost\_town} are also of type \texttt{abandoned\_city} as well as of type \texttt{city} and they have the attribute \texttt{size}, hence.
\end{example}
The keyword \texttt{const} indicates that rules may not write to attributes (see also Section~\ref{replacepart}, \texttt{eval}). However, such attributes are still writable by \LibGr\indexmain{libGr} and \GrShell\indexmain{GrShell} directly. This property applies to attributes defined in the current class, only. It does not apply to inherited attributes. The \texttt{const} property will not be inherited by subclasses, either. If you want a subclass to have the \texttt{const} property, you have to set the \texttt{const} modifier explicitly.

\begin{rail}  
  NodeClass: 'node' 'class' IdentDecl (() | 'extends' (NodeType+',')) \\ 
    (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{node}\ixkeyw{class}\ixkeyw{extends}\ixnterm{NodeClass}
Defines a new \indexed{node type}. Node types can inherit\indexmain{inheritance} from other node types defined within the same file. If the \texttt{extends} clause is omitted, \emph{NodeType} will inherit from the built-in type \texttt{\indexed{Node}}. Optionally nodes can possess attributes.

\begin{rail}    
  EdgeClass: 'edge' 'class' IdentDecl (() | 'extends' (EdgeType+',')) \\
    (() + ConnectAssertions) (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{edge}\ixkeyw{class}\ixkeyw{extends}\ixnterm{EdgeClass}
Defines a new \indexed{edge type}. Edge types can inherit\indexmain{inheritance} from other edge types defined within the same file. If the \texttt{extends} clause is omitted, \emph{EdgeType} will inherit from the built-in type \texttt{\indexed{Edge}}. Optionally edges can possess attributes. A \newterm{connection assertion} specifies that certain edge types should only connect specific nodes. Moreover, the number of outgoing and incoming edges can be constrained.

\begin{note}
It is not forbidden to create graphs that are invalid according to \indexed{connection assertion}s. \GrG\ just enables you to check, whether a graph is valid or not. See also Section~\ref{graphcommands}, \texttt{validate}.
\end{note}

\begin{rail}  
  ConnectAssertions: 'connect' (NodeConstraint '->' NodeConstraint + ',');
  NodeConstraint: NodeType (() | '[' ('*' | '+' | Number | RangeConstraint) ']') ;
  RangeConstraint: Number ':' ('*' | Number) ;
\end{rail}\ixkeyw{connect}\ixnterm{ConnectAssertions}\ixnterm{NodeConstraint}\ixnterm{RangeConstraint}
A \indexed{connection assertion} is denoted as a pair of node types in conjunction with their multiplicities\indexmainsee{multiplicity}{connection assertion}. A corresponding edge may connect a node of the first node type or one of its subtypes (source) with a node of the second node type or one of its subtypes (target). The multiplicity is a constraint on the out-degree and in-degree\indexmainsee{degree}{connection assertion} of the source and target node type, respectively. \emph{Number} is an \texttt{int} constant as defined in Section~\ref{expressions}. See Section~\ref{graphcommands}, \texttt{validate}\ixkeyw{validate}, for an example. Table~\ref{multiplicities} describes the multiplicity definitions.
\TODO{The ConnectAssertions of an edge type are connected by a disjunction, i.e. at least one of the assertions must be fulfilled. Improve this....}
\begin{table}[htbp]
\begin{tabularx}{\linewidth}{|l|X|}\hline
	\texttt{[$n$:*]} & The number of edges incident to a node of that type is unbounded. At least $n$ edges must be incident to nodes of that type.\\ 
	\texttt{[$n$:$m$]} & At least $n$ edges must be incident to nodes of that type, but at most $m$ edges may be incident to nodes of that type ($m \geq n$ must hold).\\
	\texttt{[*]} & Abbreviation for \texttt{[0:*]}.\\
	\texttt{[+]} & Abbreviation for \texttt{[1:*]}.\\
	\texttt{[$n$]} & Abbreviation for \texttt{[$n$:$n$]}. \\ \hline
\end{tabularx}
\caption{\GrG\ node constraint multiplicities}
\label{multiplicities}
\end{table}

\begin{rail}    
  AttributeDeclarations: (() | IdentDecl ':' AttributeType ';') + ;
  AttributeType: PrimitiveType | EnumType ; 
\end{rail}\ixnterm{AttributeDeclarations}\ixnterm{AttributeType}
Defines a node or edge \indexed{attribute}. Possible types are enumeration types (\texttt{enum}) and primitive types. See Section~\ref{builtin} for a list of built-in primitive types.



