\chapter{Graph Model Language}\indexmain{graph model language}
\label{chapmodellang}
The key features of \GrG\ \emph{graph models}\indexmain{graph model} as described by Geiß et al.~\cite{GBGHS:06,KG:07} are given below:

\begin{description}
\item[Types] Nodes and edges are typed. 
  This is similar to classes in common programming languages, except for the concept of methods that \GrG\ nodes and edges don't support. \GrG\ edge types can be directed and undirected.
\item[Attributes] Nodes and edges may possess attributes. The set of attributes assigned to a node or edge is determined by its type. The attributes themselves are typed, too.
\item[Inheritance] Node and edge types (classes) can be composed by multiple \indexed{inheritance}. \texttt{Node} and \texttt{Edge} are built-in root types of node and edge types, respectively. Inheritance eases the specification of attributes because subtypes inherit the attributes of their super types. Note that \GrG\ lacks a concept of overwriting. On a path in the \indexed{type hierarchy} graph from a type up to the built-in root type there must be exactly one declaration for each attribute identifier. Furthermore, if multiple paths from a type up to the built-in root type exist, the declaring types for an attribute identifier must be the same on all such paths.
\item[Connection Assertions] To specify that certain edge types should only connect specific nodes, we include connection assertions. In particular this allows for constraints on the number of outgoing and incoming edges.
\end{description}

\begin{figure}[htbf]
\begin{example}\label{ex:model:map}
The following toy example of a model of road maps gives a rough picture of the language:
\begin{grgen}
enum Resident {VILLAGE = 500, TOWN = 5000, CITY = 50000}

node class Sight;

node class City {
	Size:Resident;
}

const node class Metropolis extends City {
  River:String;
}  

abstract node class AbandonedCity extends City;
node class GhostTown extends AbandonedCity;

edge class Street;
edge class Trail extends Street;
edge class Highway extends Street
    connect Metropolis[+] -> Metropolis[+]
{
    Jam:boolean = false;
}
\end{grgen}
\end{example}
\end{figure}
In this chapter as well as in chapter~\ref{chapgrshell} (\GrShell) we use excerpts of Example~\ref{ex:model:map} (the \texttt{Map} model) for illustration purposes.

\section{Building Blocks}
\label{modelbb}

\begin{note}
The following syntax specifications make heavy use of \newtermsee{syntax diagram}{rail diagram}s (also known as \indexed{rail diagram}s). Syntax diagrams provide a visualization of EBNF\footnote{Extended Backus–Naur Form.} grammars. Follow a path along the arrows through a diagram to get a valid sentence (or subsentence) of the language. Ellipses represent terminals whereas rectangles represent non-terminals. For further information on syntax diagrams see~\cite{MMJW:91}.
\end{note}
Basic elements of the \GrG\ graph model language are identifiers to denominate nodes, edges, and attributes. The model's name itself is given by its file name. The \GrG\ graph model language is \indexed{case sensitive}.\\
\\
\emph{Ident}, \emph{IdentDecl}\\ \indexmain{identifier}\nopagebreak
A non-empty character sequence of arbitrary length consisting of letters, digits, or underscores. The first character must not be a digit. \emph{Ident} and \emph{IdentDecl} differ in their role: While \emph{IdentDecl} is a \emph{defining} occurrence of an identifier, \emph{Ident} is a \emph{using} occurrence. An \emph{IdentDecl} non-terminal may be annotated\indexmain{annotation}. See Section~\ref{annotations} for annotations of declarations.
\begin{note}
\label{note:modeldecl}
  The \GrG\ model language does not distinguish between \indexed{declaration}s and \indexed{definition}s. More precisely, every declaration is also a definition. For instance, the following C-like pseudo \GrG\ model language code is illegal:
\begin{grgen}
node class t_node;
node class t_node {
  ...
}
\end{grgen}
Using an identifier before defining it is allowed. Every used identifier has to be defined exactly once.
\end{note}
\pagebreak
\emph{NodeType}, \emph{EdgeType}, \emph{EnumType}\\ \nopagebreak
These are (semantic) specializations of \emph{Ident} to restrict an identifier to denote a node type, an edge type, or an enum type, respectively.

\subsection{Base Types}
\label{sct:basetypes}
The \GrG\ model language has built-in types for nodes and edges.
All nodes have the attribute-less, built-in type \texttt{Node} as their ancestor.
All edges have the abstract (see Section~\ref{typedecl}), attribute-less, built-in type \texttt{\indexed{AEdge}} as their ancestor.
The \texttt{AEdge} has two non-abstract built-in children: \texttt{\indexed{UEdge}} as base type for undirected edges and \texttt{\indexed{Edge}} as base type for directed edges.
The direction for \texttt{AEdge} and its anchestors that do not inherit from \texttt{Edge} or \texttt{UEdge} is undefined or \newterm{arbitrary}.
Because there is the ``magic of direction'' linked to the edge base types, its recommended to use the keywords \texttt{directed}, \texttt{undirected}, and \texttt{arbitrary} in order to specify inheritance (see Section~\ref{typedecl}).
As soon as you decided for directed or undirected edge classes within your type hierarchie, you are not able to let anchestor classes inherited from a contradicting base type, of course.
That is, no edge may be directed \emph{and} undirected.
This is an excpetion of the concept multi-inheritance.
Figure~\ref{fig:basetypes} shows the edge \indexed{type hierarchy}.
\begin{figure}[htbp]
	\centering
	\input{fig/basetypes}
	\caption{Type Hierarchy of \GrG\ Edges}
	\label{fig:basetypes}
\end{figure}

\section{Type Declarations}
\label{typedecl}

\begin{rail}
  GraphModel: () + (ClassDeclaration | EnumDeclaration);
\end{rail}\ixnterm{GraphModel}
The \indexed{graph model} consists of zero or multiple type declarations. Whereas \emph{ClassDeclaration} defines a node type or an edge type, \emph{EnumDeclaration} defines an enum type to be used as a type for a attributes of nodes or edges. Like all identifier definitions, types do not need to be declared\indexmain{declaration} before they are used.

\begin{rail}
  EnumDeclaration: 'enum' IdentDecl lbrace ((IdentDecl (() | '=' IntExpr)) + ',') rbrace ;
\end{rail}\ixkeyw{enum}\ixnterm{EnumDeclaration}
Defines an \indexed{enum type}.
An enum type is a collection of so called \emph{\indexed{enum item}s} that are associated with integral numbers, each.
Accordingly, a \GrG\ enum is internally represented as \texttt{int} (see Section~\ref{builtin}).
\begin{note}
	An enum type and an {\tt int} are different things, but in expressions enum values are implicitly casted to {\tt int} values 	(see section~\ref{builtin}).
\end{note}
\begin{note}
	Normally, assignments of {\tt int} values to something that has an enum type are forbidden (see section~\ref{builtin}).
	Only inside a declaration of an enum type an int value may be assigned to the enum item that is currently declared.
	This also includes the usage of items taken from other enum types (because they are implicitly casted to {\tt int}).
	However, items from other enum types must be written fully qualified in this case (which, e.g., looks like {\tt MyEnum::a}, where {\tt MyEnum} is the name of the other enum type).
\end{note}

\begin{example}
\begin{grgen}
enum Color {RED, GREEN, BLUE}
enum Resident {VILLAGE = 500, TOWN = 5000, CITY = 50000}
enum AsInC {A = 2, B, C = 1, D, e = (int)Resident::VILLAGE + C}
\end{grgen}
Consider, e.g., the declaration of the enum item {\tt e}:
By implicit casts of   {\tt Resident::VILLAGE } and {\tt C} to {\tt int} we get the {\tt int} value 501, which is assigned to {\tt E}.
Moreover, the semantics is as in C~\cite{Sch:1990:ANSIC}. So, the following holds: $\texttt{RED} = 0$, $\texttt{GREEN} = 1$, $\texttt{BLUE} = 2$, $\texttt{A}=2$, $\texttt{B}=3$, $\texttt{C}=1$, $\texttt{D}=2$, and $\texttt{E}=501$.
\end{example}
\begin{note}
	The C-like semantics of enum item declarations implies, that multiple items of one enum type can be associated with the same same {\tt int} value.
	Moreover, it implies, that an enum item must not be used \emph{before} its definition.
	This also holds for items of other enum types, meaning that the items of another enum type can only be used in the definition of an enum item, when the other enum type is defined \emph{before} the enum type currently defined.
\end{note}

\begin{rail}  
  ClassDeclaration: (() | 'abstract') (() | 'const') \\
    (NodeClass | (() | (() | 'arbitrary') ('directed' | 'undirected')) EdgeClass);
\end{rail}\ixkeyw{abstract}\ixkeyw{const}\ixnterm{ClassDeclaration}\ixkeyw{arbitrary}\ixkeyw{directed}\ixkeyw{undirected}
Defines a new node type or edge type. The keyword \texttt{abstract} indicates that you cannot instantiate graph elements of this type. Instead you have to derive non-abstract types to create graph elements. The abstract-property will not be inherited by subclasses, of course.

\begin{example}
We adjust our map model and make \texttt{city} abstract:
\begin{grgen}
abstract node class City {
	Size:int;
}
abstract node class AbandonedCity extends City;
node class GhostTown extends AbandonedCity;
\end{grgen}
You will be able to create nodes of type \texttt{GhostTown}, but not of type \texttt{City} or \texttt{AbandonedCity}. However, nodes of type \texttt{GhostTown} are also of type \texttt{AbandonedCity} as well as of type \texttt{City} and they have the attribute \texttt{Size}, hence.
\end{example}
The keyword \texttt{const} indicates that rules may not write to attributes (see also Section~\ref{replacepart}, \texttt{eval}). However, such attributes are still writable by \LibGr\indexmain{libGr} and \GrShell\indexmain{GrShell} directly. This property applies to attributes defined in the current class, only. It does not apply to inherited attributes. The \texttt{const} property will not be inherited by subclasses, either. If you want a subclass to have the \texttt{const} property, you have to set the \texttt{const} modifier explicitly.

The keywords \texttt{arbitrary}, \texttt{directed}, and \texttt{undirected} specify the direction ``attribute'' of an edge class and thus its inheritance.
An \texttt{arbitrary} edge inherits from \texttt{AEdge}, it is abstract and neither directed nor undirected.
A \texttt{directed} edge inherits from \texttt{Edge}.
An \texttt{undirected} edge inherits from \texttt{UEdge}.
If you do not specify any of those keywords, a \texttt{directed} edge is choosen by default.
See also Section~\ref{sct:basetypes}

\begin{rail}  
  NodeClass: 'node' 'class' IdentDecl (() | 'extends' (NodeType+',')) \\ 
    (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{node}\ixkeyw{class}\ixkeyw{extends}\ixnterm{NodeClass}
Defines a new \indexed{node type}. Node types can inherit\indexmain{inheritance} from other node types defined within the same file. If the \texttt{extends} clause is omitted, \emph{NodeType} will inherit from the built-in type \texttt{\indexed{Node}}. Optionally nodes can possess attributes.

\begin{rail}    
  EdgeClass: 'edge' 'class' IdentDecl (() | 'extends' (EdgeType+',')) \\
    (() + ConnectAssertions) (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{edge}\ixkeyw{class}\ixkeyw{extends}\ixnterm{EdgeClass}
Defines a new \indexed{edge type}. Edge types can inherit\indexmain{inheritance} from other edge types defined within the same file. If the \texttt{extends} clause is omitted, \emph{EdgeType} will inherit from the built-in type \texttt{\indexed{Edge}}. Optionally edges can possess attributes. A \newterm{connection assertion} specifies that certain edge types should only connect specific nodes. Moreover, the number of outgoing and incoming edges can be constrained.

(see Section~\ref{sct:basetypes})

\begin{note}
It is not forbidden to create graphs that are invalid according to \indexed{connection assertion}s. \GrG\ just enables you to check, whether a graph is valid or not. See also Section~\ref{graphcommands}, \texttt{validate}.
\end{note}

\begin{rail}  
  ConnectAssertions: 'connect' ((NodeConstraint ('-->' | '<->' | '--') NodeConstraint | 'inherited') + ',');
  NodeConstraint: NodeType (() | '[' ('*' | '+' | Number | RangeConstraint) ']') ;
  RangeConstraint: Number ':' ('*' | Number) ;
\end{rail}\ixkeyw{connect}\ixkeyw{inherited}\ixnterm{ConnectAssertions}\ixnterm{NodeConstraint}\ixnterm{RangeConstraint}
A \emph{\indexed{connection assertion}} is denoted as a pair of node types in conjunction with their multiplicities\indexmainsee{multiplicity}{connection assertion}. 
A corresponding edge may connect a node of the first node type or one of its subtypes (source) with a node of the second node type or one of its subtypes (target). 
The multiplicity is a constraint on the out-degree and in-degree\indexmainsee{degree}{connection assertion} of the source and target node type, respectively. 
\emph{Number} is an \texttt{int} constant as defined in Section~\ref{expressions}. 
See Section~\ref{graphcommands}, \texttt{validate}\ixkeyw{validate}, for an example. 
Table~\ref{multiplicities} describes the multiplicity definitions. 
Multiple connection assertions are applied by conjunction, i.\,e.\ all of them must be fulfilled.

The arrow syntax is based on the \GrG\ graphlet specification (see Section~\ref{sct:graphlets}).
The different kinds of arrows distinguish between directed und undirected edges.
The \texttt{-->} arrow means---what you intuitively expect---a directed edge directing to a node of the target node type (or one of its subtypes).
The \texttt{<-->} arrow means a directed edge as well, but source node type and target node type are not determined, i.\,e.\ \texttt{A <--> B} is equivalent to \texttt{A --> B, B --> A}.
The \texttt{--} arrow is used for undirected edges.
For arbitrary edges (edges not inheriting from \texttt{Edge} or \texttt{UEdge}), a connection assertion must not be specified.

Note that even though a connection assertion applies to the specified node types \emph{including} their subtypes, subtypes of the declaring edge are not taken into account.
However, you are able to make use of the edge class hierarchy by using the keyword \texttt{inherited}.
The \texttt{inherited} assertion ``imports'' the connection assertions of the \emph{direct} ancestors of the declaring edge.
This is a purely syntactical simplification, i.\,e.\ the effect of using \texttt{inherited} is the same as copying connection assertions from direct ancestors by hand.
%\begin{note}
%	Connection assertions must be consistent according to the type hierarchy.
%	That means---roughly spoken---the assertions for subtypes must get monotonously more restrictive or monotonously less restrictive.
%	For instance, the following connection assertions are illegal for node types \texttt{A}, \texttt{B}, \texttt{C}, \texttt{D} with \texttt{A} inherits from \texttt{B} and \texttt{C} inherits from \texttt{B}:
%	\begin{grgen}
%connect A[*] -> D, B[0:5] -> D, C[*] -> D
%	\end{grgen}
%	The \GrG\ compiler will warn you, if you're using inconsistent connection assertions.
%\end{note}

\begin{table}[htbp]
\begin{tabularx}{\linewidth}{|l|X|}\hline
	\texttt{[$n$:*]} & The number of edges incident to a node of that type is unbounded. At least $n$ edges must be incident to nodes of that type.\\ 
	\texttt{[$n$:$m$]} & At least $n$ edges must be incident to nodes of that type, but at most $m$ edges may be incident to nodes of that type ($m \geq n \geq 0$ must hold).\\
	\texttt{[*]} & Abbreviation for \texttt{[0:*]}.\\
	\texttt{[+]} & Abbreviation for \texttt{[1:*]}.\\
	\texttt{[$n$]} & Abbreviation for \texttt{[$n$:$n$]}.\\
	               & Abbreviation for \texttt{[$1$]}. \\ \hline
\end{tabularx}
\caption{\GrG\ node constraint multiplicities}
\label{multiplicities}
\end{table}

\begin{rail}    
  AttributeDeclarations: (() | IdentDecl ':' AttributeType (() | '=' Expression) ';' | AttributeOverwrite) + ;
  AttributeType: PrimitiveType | EnumType ; 
  AttributeOverwrite: Ident '=' Expression
\end{rail}\ixnterm{AttributeDeclarations}\ixnterm{AttributeType}\ixnterm{AttributeOverwrite}
Defines a node or edge \indexed{attribute}. Possible types are enumeration types (\texttt{enum}) and primitive types. See Section~\ref{builtin} for a list of built-in primitive types. Optionally attributes may be initialized with a constant expression. The expression has to be of a compatible type of the declared attribute, of course. See chapter \ref{typeexpr} for the \GrG\ types and expressions reference. The \emph{AttributeOverwrite} clause lets you overwrite initialization values for attributes of super classes. The initialization values are evaluated in the order as they appear in the rule set file.
\begin{example}
	The following attribute declarations are \emph{illegal} because of the order of evaluation of initialization values:
	\begin{grgen}
x:int = y;
y:int = 42;	
	\end{grgen}
\end{example}



