\chapter{Deprecated Syntax}
\label{sct:deprecated}

This appendix describes deprecated \GrG\ constructs of versions prior to 1.4.
The following constructs may or may not work with the current \GrG\ release.
Support for such constructs will eventually be terminated.

\section{Graph Model and Rule Set Language}
The graph model and the rule set were previously introduced by keywords:
\begin{rail}
  GraphModel: 'model' Ident ';' etc;
  RuleSet: 'actions' Ident etc;
\end{rail}\ixkeyw{model}\ixkeyw{actions}
These keywords are not used any more.
The name of a graph model resp.\ a rule set is determinated by its file name.

In previous \GrG\ versions the pattern was a syntactical block within a rule:
\begin{rail}
  RuleDeclaration: ('rule' | 'test') ActionSignature lbrace 'pattern' lbrace etc rbrace etc;
\end{rail}\ixkeyw{pattern}
The current version does not use the \texttt{pattern} keyword but expects the pattern statements to be placed as direct members of the rule block (see sections \ref{ruledecls}, \ref{patternpart}).
The \texttt{pattern} keyword will be used in \GrG\ version 2.0 for a different purpose.

\section{Graph Rewrite Sequences (GRS)}
The non-extended graph rewrite sequence was part of the \GrShell.
The extended graph rewrite sequences (XGRS) are available within the \GrShell\ as well as within the rule set language (see section \ref{sct:xgrs}).

\makeatletter
\begin{rail}
  GraphRewriteSequence: (() | 'debug') 'grs' SimpleRewriteSequence ;
\end{rail}\ixkeyw{debug}\ixkeyw{grs}\indexmain{graph rewrite sequence}\indexmainsee{GRS}{graph rewrite sequence}\ixnterm{GraphRewriteSequence}
This executes the graph rewrite sequence \emph{SimpleRewriteSequence}.
\begin{rail}
  SimpleRewriteSequence: (SimpleTerm (() | ('*' | lbrace Number rbrace))) + ((() | dollar) (';' | '|' | ampersand));
  SimpleTerm: (() | '!') ('[' Rule ']' | Rule) |
    Text '=' (Text | '@' '(' Text ')') |
    'def' '(' Parameters ')' |
    'true' |
    'false' |
    '(' SimpleRewriteSequence ')' ;
  Rule: (() | '(' Parameters ')' '=') Action (() | '(' Parameters ')') ;
\end{rail}\ixnterm{SimpleRewriteSequence}\ixnterm{SimpleTerm}
\makeatother
\mbox{\quad}\\
Table~\ref{grsruletab} lists graph rewrite expressions at a glance. The operators hold the following \indexed{order of precedence}, starting with the lowest priority: 
\[ \text{\texttt{;}} \;\;\;\;\;\;\; \text{\texttt{|}} \;\;\;\;\;\;\;  \text{\texttt{\&}}\] 

\makeatletter
\begin{table}[htbp]
\begin{minipage}{\linewidth} \renewcommand{\footnoterule}{} 
\begin{tabularx}{\linewidth}{|lX|}
\hline
\texttt{s ; t}		& \textbf{Concatenation.} First execute \texttt{s} afterwards execute \texttt{t}. The sequence \texttt{s ; t} is \emph{successfully} executed iff \texttt{s} or \texttt{t} is successfully executed.\\
\texttt{s | t}		& \textbf{XOR.} First execute \texttt{s}. Only if \texttt{s} fails (i.e. can not be executed successfully) then execute \texttt{t}. The sequence \texttt{s | t} is successfully executed iff \texttt{s} or \texttt{t} is successfully executed.\\
\texttt{s \& t}	& \textbf{Transactional AND.} First execute \texttt{s}, afterwards execute \texttt{t}. If \texttt{s} or \texttt{t} fails, the action will be terminated and a rollback to the state before \texttt{s \& t} is performed.\\
\texttt{\$<op>}	& Flag the operator \texttt{<op>} as commutative. Usually operands are executed/evaluated from left to right with respect to bracketing (left-\indexed{associative}). But the sequences \texttt{s}, \texttt{t}, \texttt{u} in \texttt{s \$<op> t \$<op> u} are executed/evaluated in arbitrary order. \\
\texttt{s *}		& Execute \texttt{s} repeatedly as long as its execution does not fail.\\
\texttt{s \{n\}}	& Execute \texttt{s} repeatedly as long as its execution does not fail but \texttt{n} times at most.\\
\texttt{!}		& Dump found matches into VCG formatted files (for a VCG definition see~\cite{vcg}). Every match produces three files within the current directory:
\begin{enumerate}
  \item The complete graph that has the matched graph elements marked
  \item The complete graph with additional information about matching details
  \item A subgraph containing only the matched graph elements
\end{enumerate}\\
\texttt{\emph{Rule}} & Rewrite the first found pattern match produced by the action \emph{Rule}.\\
\texttt{[\emph{Rule}]} & Rewrite every pattern match produced by the action \emph{Rule}. \textbf{Note:} This operator is mainly added for benchmark purposes. Its semantics is not equal to \texttt{Rule*}. Instead this operator collects all the matches first before starting rewritings. In particular one needs to avoid deleting a graph element that is bound by another match. \\
\texttt{v = w}	& Assign the variable \texttt{w} to \texttt{v}. If \texttt{w} is undefined, \texttt{v} will be undefined, too.\\
\texttt{v = @(x)}	& Assign the graph element identified by \texttt{x} to the variable \texttt{v}. If \texttt{x} is not defined, \texttt{v} will be undefined, too.\\
\texttt{def(\emph{Parameters})} & Is \emph{successful} if all the graph elements in \emph{Parameters} exist, i.e.\ if all the variables are defined.\\
\texttt{true}	& A constant acting as a successful match.\\
\texttt{false}	& A constant acting as a failed match.\\ \hline
\end{tabularx}\indexmain{\texttt{;}}\indexmain{\texttt{\&\&}@\texttt{"|}}
\indexmain{\texttt{\&}}\indexmain{\texttt{\$<op>}}\indexmain{\texttt{*}}\indexmain{\texttt{"!}}
\ixkeyw{def}
\end{minipage}\\
\\ 
{\small Let \texttt{s}, \texttt{t}, \texttt{u} be graph rewrite sequences, \texttt{v}, \texttt{w} variable identifiers, \texttt{x} an identifier of a graph element, \texttt{<op>} $\in \{\texttt{;}, \texttt{|}, \texttt{\&}\}$ and \texttt{n} $\in \N_0$.}
\caption{Graph rewrite expressions}
\label{grsruletab}
\end{table}
\makeatother
