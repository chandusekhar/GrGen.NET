\chapter{Types and Expressions}
\label{typeexpr}
In the following sections \emph{Ident} refers to an identifier of the graph model language (see Section~\ref{modelbb}) or the rule set language (see Section~\ref{rulebb}). \emph{TypeIdent} is an identifier of a node type or an edge type, \emph{NodeOrEdge} is an identifier of a node or an edge.

\section{Built-In Types}
\label{builtin}
Besides user-defined node types, edge types, and enumeration types, \GrG\ supports the built-in \indexed{primitive types}\indexmainsee{built-in types}{primitive types} in Table~\ref{builtintypes}.
The exact type format is \indexed{backend} specific. 
The \indexed{LGSPBackend} maps the \GrG\ primitive types to the corresponding C\# primitive types.
\begin{table}[htbp]
\begin{tabularx}{\linewidth}{|l|X|}\hline
	\texttt{\indexed{boolean}} & Covers the values \texttt{true} and \texttt{false} \\
	\texttt{\indexed{int}} & A signed integer with at least 32 bits \\
	\texttt{\indexed{float}}, \texttt{\indexed{double}} & A floating-point number with single precision or double precision respectively \\
	\texttt{\indexed{string}} & A character sequence of arbitrary length\\
	\texttt{\indexed{object}} & Contains a .NET object\\ \hline
\end{tabularx}
\caption{\GrG\ built-in primitive types}
\label{builtintypes}
\end{table}
Table~\ref{tabcasts} lists \GrG's implicit \indexed{type cast}s and the allowed explicit type casts.
Of course you are free to express an implicit type cast by an explicit type cast as well as ``cast'' a type to itself.

According to table~\ref{tabcasts} neither implicit nor explicit casts from {\tt int} to any \indexed{enum type} are allowed.
This is because the range of an enum type is very sparse in general.
For the same reason implicit and explicit casts between enum types are also forbidden.
Thus, enum values can only be assigned to attributes having the same enum type.
A cast of an enum value to a string value will return the declared name of the enum value.
A cast of an object value to a string value will return ``null'' or it will call the \texttt{toString()} method of the .NET object.
Be careful with assignments of objects: \GrG\ does not know your .NET type hierarchy and therefore it cannot check two objects for type compatibility.
Objects of type object are not very useful for \GrG processing, but they can be used on the API level.

\begin{table}[htbp]
  \centering
  \begin{tabular}[c]{|c|ccccccc|} \hline
    \backslashbox{to}{from} & \texttt{enum} & \texttt{boolean} & \texttt{int} & \texttt{float} & \texttt{double} & \texttt{string} & \texttt{object} \\ \hline
    \texttt{enum} & $=$/--- & & & & & & \\ 
    \texttt{boolean} & & $=$ & & & & & \\
    \texttt{int} & implicit & & $=$ & \texttt{(int)} & \texttt{(int)} & & \\
    \texttt{float} & implicit & & implicit & $=$ & \texttt{(float)} & & \\
    \texttt{double} &  implicit & & implicit & implicit & $=$ & & \\
    \texttt{string} & implicit & implicit & implicit & implicit & implicit & $=$ & implicit\\
    \texttt{object} & &  & & & & & $=$ \\\hline
  \end{tabular}
  \caption{\GrG\ type casts}
  \label{tabcasts}
\end{table}

\begin{example}
  \begin{itemize}
    \item Allowed:\\
	  \texttt{x.myfloat = x.myint; x.mydouble = (float) x.myint;\\ x.mystring = (string) x.mybool;}
    \item Forbidden:\\
      \texttt{x.myfloat = x.mydouble;} and \texttt{x.myint = (int) x.mybool;}\\
      \texttt{MyEnum1 = (MyEnum1Type) int;} and \texttt{MyEnum2 = (MyEnum2Type) MyEnum1;}
  where {\tt myenum1} and {\tt myenum2} are different enum types.

  \end{itemize}
\end{example}

\begin{note}
	Unlike an {\tt eval} part (which must not contain assignments to node or edge attributes) the declaration of an enum type can contain assignments of {\tt int} values to \indexed{enum item}s (see section~\ref{typedecl}).
	The reason is, that the range of an enum type is just defined in that context.
\end{note}

TODO: set/map

\section{Expressions}

%left to right, left associative?

\label{expressions}
\begin{rail}
  Expression: BoolExpr | RelationalExpr | IntExpr | FloatExpr | StringExpr | SetExpr | MapExpr | TypeExpr | PrimaryExpr;  
\end{rail}\ixnterm{Expression}


\section{Boolean Expressions}

\begin{rail}
  BoolExpr: ((() | '!') PrimaryExpr) | (BoolExpr '?' BoolExpr ':' BoolExpr) | (BoolExpr BinBoolOperator BoolExpr) | RelationalExpr;
\end{rail}\ixnterm{BoolExpr}
The unary \texttt{!}\ operator negates a Boolean. 
The binary \emph{BinBoolOperator} is one of the operators in Table~\ref{tabboolops}.
\begin{table}[htbp] 
  \centering
  %\begin{tabularx}{0.45\linewidth}{|ll|} \hline
  \begin{tabular}[c]{|lp{0.6\linewidth}|} \hline
    \begin{tabular}[c]{l} \texttt{\^} \end{tabular} & \begin{tabular}[c]{l} Logical XOR. True, iff either the first or the second \\ Boolean expression is true. \end{tabular} \\ \hline
    \begin{tabular}[c]{l} \texttt{\&\&} \\ \texttt{||} \end{tabular} & \begin{tabular}[c]{l} Logical AND and OR. Lazy evaluation. \end{tabular}\\ \hline
    \begin{tabular}[c]{l} \texttt{\&} \\ \texttt{|} \end{tabular} & \begin{tabular}[c]{l} Logical AND and OR. Strict evaluation. \end{tabular}\\ \hline
  \end{tabular}
  \caption{Binary Boolean operators, in ascending order of precedence}\indexmain{order of precedence}\indexmainsee{precedence}{order of precedence}
  \label{tabboolops}
\end{table}
The ternary \texttt{?}\ operator is a simple if-then-else: If the first \emph{BoolExpr} is evaluated to \texttt{true}, the operator returns the second \emph{BoolExpr}, otherwise it returns the third \emph{BoolExpr}.


\section{Relational Expressions}

They compare enitites of different kinds, mapping them to boolean.

\begin{rail}
 RelationalExpr: (Expression CompareOperator Expression)
\end{rail}

The \emph{CompareOperator} is one of the following operators:
\[ \texttt{<} \;\;\;\;\; \texttt{<=} \;\;\;\;\; \texttt{==} \;\;\;\;\; \texttt{!=} \;\;\;\;\; \texttt{>=} \;\;\;\;\; \texttt{>} \]
Their semantics are type dependent.

For arithmetic expressions on \texttt{int} and \texttt{float} or \texttt{double} types 
the semantics is given by Table~\ref{compandarithmetic} (by implicit casting they can also by used with all enum types).

\begin{table}[htbp]
  \centering
  \begin{tabularx}{\linewidth}{|l|X|} \hline
    \texttt{A == B} & True, iff $A$ is the same number as $B$. \\
    \texttt{A != B} & True, iff $A$ is a different number than $B$. \\
    \texttt{A <\ \ B} & True, iff $A$ is smaller than and not equal $B$. \\
    \texttt{A >\ \ B} & True, iff $A$ is greater than and not equal $B$. \\
    \texttt{A <= B} & True, iff $A$ is smaller than (or equal) $B$. \\
    \texttt{A >= B} & True, iff $A$ is greater than (or equal) $B$. \\ \hline
  \end{tabularx}
  \caption{Compare operators on arithmetic expressions}
  \label{compandarithmetic}
\end{table}

\texttt{String} types, \texttt{boolean} types, and \texttt{object} types support only the \texttt{==} and the \texttt{!=} operators;
for strings they denote whether the strings are the same or not, 
on boolean values they denote equivalence and antivalence, 
and on object types the tell whether the references are the same, thus the objects identical.

For set and map expressions, table~\ref{compandsetmap} describes the semantics of the compare operators.
\begin{table}[htbp]
  \centering
  \begin{tabularx}{\linewidth}{|l|X|} \hline
    \texttt{A == B} & True, iff $A$ and $B$ are identical. \\
    \texttt{A != B} & True, iff $A$ and $B$ are not identical. \\
    \texttt{A <\ \ B} & True, iff $A$ is a subset/map of $B$, but $A$ and $B$ are not identical. \\
    \texttt{A >\ \ B} & True, iff $A$ is a superset/map of $B$, but $A$ and $B$ are not identical. \\
    \texttt{A <= B} & True, iff $A$ is a subset/map of $B$ or $A$ and $B$ are identical. \\
    \texttt{A >= B} & True, iff $A$ is a superset/map of $B$ or $A$ and $B$ are identical. \\ \hline
  \end{tabularx}
  \caption{Compare operators on set/map expressions}
  \label{compandsetmap}
\end{table}

For \indexed{type expression}s the semantics of compare operators are given by table~\ref{compandtypes},
the rule to remember is: types grow larger with extension/refinement. An example is given in \ref{typeexpressions}.
\begin{table}[htbp]
  \centering
  \begin{tabularx}{\linewidth}{|l|X|} \hline
    \texttt{A == B} & True, iff $A$ and $B$ are identical. Different types in a type hierarchy are \emph{not} identical. \\
    \texttt{A != B} & True, iff $A$ and $B$ are not identical. \\
    \texttt{A <\ \ B} & True, iff $A$ is a supertype of $B$, but $A$ and $B$ are not identical. \\
    \texttt{A >\ \ B} & True, iff $A$ is a subtype of $B$, but $A$ and $B$ are not identical. \\
    \texttt{A <= B} & True, iff $A$ is a supertype of $B$ or $A$ and $B$ are identical. \\
    \texttt{A >= B} & True, iff $A$ is a subtype of $B$ or $A$ and $B$ are identical. \\ \hline
  \end{tabularx}
  \caption{Compare operators on type expressions}
  \label{compandtypes}
\end{table}
\begin{note}
  \texttt{A < B} corresponds to the direction of the arrow in an \indexed{UML class diagram}.
\end{note}
\begin{note}
  \texttt{Node} and \texttt{Edge} are the least specific, thus bottom elements $\bot$ of the type hierarchy,\\
  i.e. the following holds:
  \begin{itemize}
    \item $\forall n\in Types_{Node}: Node <= n$
    \item $\forall e\in Types_{Edge}: Edge <= e$
  \end{itemize}
\end{note}


\section{Arithmetic and Bitwise Expressions}

\begin{rail}
  IntExpr: ((() | '+' | '-' | tilde) PrimaryExpr) | (BoolExpr '?' IntExpr ':' IntExpr) | (IntExpr BinIntOperator IntExpr);
\end{rail}\ixnterm{IntExpr}
The $\sim$ operator is the bitwise complement. 
That means every bit of an integer value will be flipped. 
The \texttt{?}\ operator is a simple if-then-else: If the \emph{BoolExpr} is evaluated to \texttt{true}, the operator returns the first \emph{IntExpr}, otherwise it returns the second \emph{IntExpr}. 
The \emph{BinIntOperator} is one of the operators in Table~\ref{tabbinops}.
\begin{table}[htbp] 
  \centering
  %\begin{tabularx}{0.45\linewidth}{|ll|} \hline
  \begin{tabular}[c]{|lp{0.6\linewidth}|} \hline
    \begin{tabular}[c]{l} \texttt{\^} \\ \texttt{\&} \\ \texttt{|} \end{tabular} & \begin{tabular}[c]{l} Bitwise XOR, AND and OR \end{tabular} \\ \hline
    \begin{tabular}[c]{l} \texttt{\mbox{<}\mbox{<}} \\ \texttt{\mbox{>}\mbox{>}} \\ \texttt{\mbox{>}\mbox{>}\mbox{>}} \end{tabular} & \begin{tabular}[c]{l} Bitwise shift left, bitwise shift right and \\ bitwise shift right preserving the sign \end{tabular}\\ \hline
    \begin{tabular}[c]{l} \texttt{+} \\ \texttt{-} \end{tabular} & \begin{tabular}[c]{l} Addition and subtraction \end{tabular}\\ \hline
    \begin{tabular}[c]{l} \texttt{*} \\ \texttt{/} \\ \texttt{\%} \end{tabular} & \begin{tabular}[c]{l}Multiplication, integer division, and modulo \end{tabular} \\ \hline
  \end{tabular}
  \caption{Binary integer operators, in ascending order of precedence}\indexmain{order of precedence}
  \label{tabbinops}
\end{table}

\begin{rail}  
  FloatExpr: ((() | '+' | '-') PrimaryExpr) | (BoolExpr '?' FloatExpr ':' FloatExpr) | (FloatExpr BinFloatOperator FloatExpr);
\end{rail}\ixnterm{FloatExpr}
The \texttt{?}\ operator is a simple if-then-else: If the \emph{BoolExpr} is evaluated to \texttt{true}, the operator returns the first \emph{FloatExpr}, otherwise it returns the second \emph{FloatExpr}.
The \emph{BinFloatOperator} is one of the operators in Table~\ref{tabfloatbinops}.
\begin{table}[htbp] 
  \centering
  %\begin{tabularx}{0.45\linewidth}{|ll|} \hline
  \begin{tabular}[c]{|ll|} \hline
    \begin{tabular}[c]{l} \texttt{+} \\ \texttt{-} \end{tabular} & \begin{tabular}[c]{l} Addition and subtraction \end{tabular}\\ \hline
    \begin{tabular}[c]{l} \texttt{*} \\ \texttt{/} \\ \texttt{\%} \end{tabular} & \begin{tabular}[c]{l}Multiplication, division and modulo \end{tabular} \\ \hline
  \end{tabular}
  \caption{Binary float operators, in ascending order of precedence}\indexmain{order of precedence}
  \label{tabfloatbinops}
\end{table}
\begin{note}
The \texttt{\%} operator on float values works analogous to the integer modulo operator. For instance \texttt{4.5 \% 2.3 == 2.2}.
\end{note}

\section{String Expressions}

\begin{rail}
  StringExpr: PrimaryExpr (MethodSelector)? | StringExpr '+' StringExpr;
\end{rail}\ixnterm{StringExpr}
The operator \texttt{+} concatenates two strings.
There are several operations on strings available in method call notation (MethodSelector), these are 

\begin{description}
\item[\texttt{.length()}] returns length of string, as \texttt{int}
\item[\texttt{.indexOf(strToSearchFor)}] returns first position \texttt{strToSearchFor:string} appears at, as \texttt{int}, or -1 if not found
\item[\texttt{.lastIndexOf(strToSearchFor)}] returns last position \texttt{strToSearchFor:string} appears at, as \texttt{int}, or -1 if not found
\item[\texttt{.substring(startIndex, length)}] returns substring of given \texttt{length:int} from \texttt{startIndex:int} on
\item[\texttt{.replace(startIndex, length, replaceStr)}] returns string with substring from \texttt{startIndex:int} on of given \texttt{length:int} replaced by \texttt{replaceStr:int}
\end{description}

\begin{example}
For \texttt{n.str == "foo bar foo"} the operations yield \\
\texttt{n.str.length()==11} \\
\texttt{n.str.indexOf("foo")==0} \\
\texttt{n.str.lastIndexOf("foo")==8} \\
\texttt{n.str(4,3)=="bar"} \\
\texttt{n.str(4,3,"foo")=="foo foo foo"} \\
\end{example}

\section{Set and Map Expression}

In addition to the already mentionen types \GrG~supports the types \texttt{set<K>} and \texttt{map<K,V>}, where \texttt{K} and \texttt{V} are of primitive or enumeration type.
They represent mathematical sets and maps, no type casts are applicable, but there are several operations on them available. They are implemented by C\#-Dictionaries (i.e. Hashmaps).
They were especially added to support uses in computer linguistics (and knowledge representation), where string dictionaries are needed, an area we think could profit considerably from using graph rewrite systems.

\begin{rail} 
  SetExpr: SetConstructor | PrimaryExpr (MethodSelector)? | SetExpr (backslash | ampersand | '|') SetExpr;
\end{rail}\ixnterm{SetDecl}

Operations on sets, forming expressions with sets
-Set union, intersection, difference as binary operators \verb#|,&,\#, e.g. 
\begin{grgenlet}
n.fancySet \ { "la","le","lu" };
\end{grgenlet}
taking two sets of equal types and returning a new, computed set.
Priorities \verb#| < & < \# (higher priority binds stronger, so
\verb#a&b\c|d == (a&(b\c))|d)#
-Set membership in, returning whether the set contains the given element, as boolean, e.g. \begin{grgenlet}
42 in intSet
\end{grgenlet}
or
\begin{grgenlet}
m.boolValue = n.stringValue in { "foo", "bar" };
\end{grgenlet}

Methods on sets
.size() returns the number of elements in the set, as int
e.g.
\begin{grgenlet}
n.fancySet.size()
\end{grgenlet}

Parameters of set type, can be used to hand some set in.
(The result of assigning to the input set is undefined.)
\begin{grgen}
test bla(var varSet:set<int>) 
{
	n:SomeType;
	if { n.foo in (varSet \ { n.a }); }
}
\end{grgen}

\begin{rail} 
  SetConstructor: ('set' '<' Type '>')? \\ lbrace ( Expression*',' ) rbrace ;
\end{rail}\ixnterm{SetConstructor}

Set constructors, analogous to set initializers, they represent a base set expression, e.g. 
\begin{grgenlet}
n.fancySet = { "foo", "bar" };
\end{grgenlet}
but in contrast to set initializers, they may contain non constant values, e.g. 
\begin{grgenlet}
n.fancySet = { n.strVal, m.strVal, n.strVal+m.strVal }
\end{grgenlet}
The values must be all of the same type, if you wish implicit type casts
you have to prefix the set constructor by the set type, e.g.
\begin{grgenlet}
n.fancySet = set<string>{ 42, intVal, "fool" };
\end{grgenlet}
Set constructors create and return an anonymous set,
to be written to an attribute or to be operated on by some of the following set operations:

\begin{rail}
  MapDecl: MapConstructor | PrimaryExpr (MethodSelector)? | MapExpr (backslash | ampersand | '|') MapExpr;
\end{rail}\ixnterm{MapDecl}

Operations on maps, forming expressions with maps
-Map union, intersection, difference as binary operators
\verb#|,&,\#
e.g. 
\begin{grgenlet} 
n.fancyMap | { "la"->0,"le"->1,"lu"->2 };
\end{grgenlet}
taking two maps of equal types and returning a new, computed map.
Priorities 
\begin{grgenlet}
| < & < \
\end{grgenlet}
(higher priority binds stronger, so
\verb#a&b\c|d == (a&(b\c))|d)#

Semantics of \verb#|,&,\# on maps:
\begin{grgenlet}
map1 | map2
\end{grgenlet}
 - new map with elements which are in at least one of the maps, with the value of map2 taking precedence
\begin{grgenlet}
map1 & map2
\end{grgenlet}
- new map with elements which are in both maps, with the value of map2 taking precedence
\begin{grgenlet}
map1 \ map2
\end{grgenlet}
- new map with elements from map1 without the elements with a key contained in map2
-Additionally, 
\begin{grgenlet}
map<K,V> \ set<K>
\end{grgenlet}
is allowed, e.g.
\begin{grgenlet}
m.fancyMap \ { "hui","buh" }
\end{grgenlet} 
or 
\begin{grgenlet}
m.fancyMap = m.fancyMap \ n.fancySet 
\end{grgenlet}
-Map membership in, returning whether the map domain contains the given element, as boolean, e.g. 
\begin{grgenlet}
42 in intMap
\end{grgenlet}  
or  
\begin{grgenlet}
m.boolValue = n.stringValue in { "foo"->0, "bar"->1 };
\end{grgenlet}
-Map access 
\begin{grgenlet}
map[key]
\end{grgenlet}
returning value in map saved under key (value in range mapped to by given key from domain), e.g.
\begin{grgenlet}
n.intVal = m.fancyMap["bla"] + 42;
\end{grgenlet}

Methods on maps
\begin{description}
  \item[.size()] returns the number of elements in the map, as \texttt{int}
 e.g. \texttt{n.fancyMap.size()}
  \item[.domain()] returns the set of elements in the domain of the map
 e.g. \texttt{n.fancyMap.domain()}, result \verb#set<K>#
  \item[.range()] returns the set of elements in the range of the map
 e.g. \texttt{n.fancyMap.range()}, result \verb#set<V>#
\end{description}

Parameters of map type, can be used to hand some map in.
(The result of assigning to the input map is undefined.)
\begin{grgen}
test bla(var varMap:map<int,int>) 
{
	n:SomeType;
	if {  varMap[n.foo]==42; }
}
\end{grgen}

\begin{rail}
  MapConstructor: ('map' '<' Type ',' Type '>')? \\ lbrace ( (Expression '->' Expression)*',' ) rbrace ;
\end{rail}\ixnterm{MapDecl}

Map constructors, analogous to map initializers, they represent a base map expression, e.g. 
\begin{grgenlet}
n.fancyMap = { "foo"->0, "bar"->1 };
\end{grgenlet}
but in contrast to map initializers, they may contain non constant values, e.g.
\begin{grgenlet}
n.fancyMap = { n.strVal->m.intVal, m.strVal->n.intVal, (n.strVal+m.strVal)->(m.intVal+n.intVal) } 
\end{grgenlet}
The values must be all of the same type, if you wish implicit type casts 
you have to prefix the map constructor by the map type, e.g.
\begin{grgenlet}
n.fancyMap = map<string,int>{ 42->42, intVal->strVal, "fool"->42 };
\end{grgenlet}
Map constructors create and return an anonymous map, to be written to an attribute or to be operated on by some of the following map operations:


\section{Type Expressions}\indexmain{type expression}
\label{typeexpressions}

\begin{rail}
  TypeExpr: TypeIdent | 'typeof' '(' NodeOrEdge ')' ;
\end{rail}\ixkeyw{typeof}\ixnterm{TypeExpr}
A type expression identifies a type (and---in terms of matching---also its subtypes).
A type expression is either a type identifier itself or the type of a graph element.
The type expression \texttt{typeof(x)} stands for the type of the host graph element \texttt{x} is actually bound to.

\begin{example}
\begin{tabularx}{\linewidth}{cX}
  \begin{tikzpicture}[baseline=(T.base)] \tt
    \begin{scope}[minimum size=0.5cm]
      \tikzstyle{every node}=[draw]
      \node (T)     at (1   ,4) {\texttt{T}};
      \node (T1)     at (1   ,3) {\texttt{T1}};
      \node (T2)     at (0   ,2) {\texttt{T2}};
      \node (T4)     at (0   ,1) {\texttt{T4}};
      \node (T3)     at (2   ,2) {\texttt{T3}};
    \end{scope}
    \draw[thick,-open triangle 45]  (T1) -> (T)  ;
    \draw[thick,-open triangle 45]  (T2) -> (T1)  ;
    \draw[thick,-open triangle 45]  (T3) -> (T1)  ;
    \draw[thick,-open triangle 45]  (T4) -> (T2)  ;
  \end{tikzpicture} &
  \parbox{\linewidth}{The expression \texttt{typeof(x)<=T2} applied to the type hierarchy on the left side yields \texttt{true} if \texttt{x} is a graph element of type \texttt{T} or \texttt{T1} or \texttt{T2}.
                      The expression \texttt{typeof(x)>T2} only yields \texttt{true} for \texttt{x} being a graph element of type \texttt{T4}. The expression \texttt{T1<T3} always yields \texttt{true}.}
\end{tabularx}
\end{example}



\section{Primary expressions}

After we've seen the all the ways to combine expressions, finally we'll have a look at the atoms the expressions are built of.

\begin{rail} 
  PrimaryExpr: '(' ('int' | 'float' | 'double' | 'string') ')' PrimaryExpr | '(' Expression ')' | (NodeOrEdge '.' Ident) | (EnumType '::' Ident) | ObjectIdent | Constant | 'visited' '(' NodeOrEdge (',' FlagNumber)? ')' | 'nameof' '(' NodeOrEdge? ')';
  Constant: Number | HexNumber | QuotedText | 'true' | 'false' | 'null';
\end{rail}\ixnterm{PrimaryExpr}\ixnterm{Constant}
\begin{description}
  \item[Number] Is an \texttt{int}, \texttt{float}, or \texttt{double} constant in decimal notation.
  \item[HexNumber] Is an \texttt{int} constant in hexadecimal notation starting with \texttt{0x}.
  \item[QuotedText] Is a string constant. It consists of a sequence of characters, enclosed by double quotes.
\end{description}

The \texttt{visited} query returns the status of the \indexed{visited flag} of the given number for the given graph element as \texttt{boolean}.
If no flag number is given, the default number for the first visited flag of 0 is used. The visited flags are written in the assignments of the eval statements.
The \texttt{nameof} query returns the name of the given graph element as \texttt{string}. If no graph element is given, the name of the graph is returned.
