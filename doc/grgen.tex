\documentclass[a4paper,final,11pt]{book}

\include{packages}

\selectlanguage{english}
\lstset{breaklines=true, breakautoindent=true, breakatwhitespace=true}

\lstdefinelanguage{LANGgrgen}
{morekeywords={actions,using,rule,test,pattern,replace,if,eval,negative,node,edge,path,graph,modify,delete,class,model,connect,extends,enum,abstract,const},
sensitive=true,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]",
escapeinside={/*@}{@*/},
}
\lstnewenvironment{grgen}[1][]
    {\lstset{language=LANGgrgen, basicstyle=\ttfamily\small, keywordstyle=\itshape,
        basewidth=1.1ex, numbers=left, numberstyle=\tiny, stepnumber=1,
        numbersep=5pt, tabsize=3, frame=single, #1}}
    {}
\lstnewenvironment{grgenlet}[1][]
    {\lstset{language=LANGgrgen, basicstyle=\ttfamily, keywordstyle=\itshape,
        basewidth=1.1ex, numbers=none, tabsize=3, #1}}
    {}

\lstnewenvironment{csharp}[1][]
    {\lstset{language=[Sharp]C, basicstyle=\ttfamily\small, keywordstyle=\itshape,
        basewidth=1.1ex, numbers=left, numberstyle=\tiny, stepnumber=1,
        numbersep=5pt, tabsize=3, frame=single, #1}}
    {}
\lstnewenvironment{csharplet}[1][]
    {\lstset{language=[Sharp]C, basicstyle=\ttfamily, keywordstyle=\itshape,
        basewidth=1.1ex, numbers=none, tabsize=3, #1}}
    {}


\lstdefinelanguage{LANGgrshell}
{morekeywords={},
sensitive=true,
morecomment=[l]{\#},
morestring=[b]",
}
\lstnewenvironment{grshell}[1][]
    {\lstset{language=LANGgrshell, basicstyle=\ttfamily\small, keywordstyle=\itshape,
        basewidth=1.1ex, numbers=left, numberstyle=\tiny, stepnumber=1,
        numbersep=5pt, tabsize=3, frame=single, #1}}
    {}
\lstnewenvironment{grshelllet}[1][]
    {\lstset{language=LANGgrshell, basicstyle=\ttfamily, keywordstyle=\itshape,
        basewidth=1.1ex, numbers=none, tabsize=3, #1}}
    {}




\providecommand{\GrG}{{\scshape GrGen.NET}}
\providecommand{\GrShell}{{\scshape GrShell}}
\providecommand{\LibGr}{{\scshape libGr}}
\providecommand{\yComp}{{\scshape yComp}}
\providecommand{\yFiles}{{\scshape yFiles}}

\newcommand{\newterm}[1]{\emph{#1}\index{#1}}
\newcommand{\newtermsee}[2]{\emph{#1}\index{#1|see{#2}}}
\newcommand{\indexed}[1]{#1\index{#1}}
\newcommand{\indexedsee}[2]{#1\index{#1|see{#2}}}
\newcommand{\indexmain}[1]{\index{#1}}
\newcommand{\indexmainsee}[2]{\index{#1|see{#2}}}

\newcommand{\keyw}[1]{\texttt{#1}}
\newcommand{\ixkeyw}[1]{\index{...#1@\protect\keyw{#1}}}
\newcommand{\nterm}[1]{\emph{#1}}
\newcommand{\ixnterm}[1]{\index{..#1@\protect\nterm{#1}}}


\newcommand{\lined}{\hfill \hrule\hfill\vspace{1mm} \\}
\reversemarginpar

% Pimped example environment
\newlength\sidebar
\newlength\envrule
\newlength\envborder
\setlength\sidebar{1.5mm}
\setlength\envrule{0.4pt}
\setlength\envborder{6mm}

\definecolor{exampleborder}{rgb}{0,0,.7}
\definecolor{examplebg}{rgb}{.9,.9,1}
\definecolor{statementborder}{rgb}{.9,0,0}
\definecolor{statementbg}{rgb}{1,.9,.9}
\newsavebox\envbox
\newcounter{example}
\newenvironment{example}[1][EXAMPLE]{%
  \par 
  \refstepcounter{example}%
  \SpecialEnv{#1}{exampleborder}{examplebg}{}{\theexample}%
}{%
  \endSpecialEnv
}
\newcounter{note}
\newenvironment{note}[1][NOTE]{%
  \par 
  \refstepcounter{note}%
  \SpecialEnv{#1}{statementborder}{statementbg}{}{\thenote}%
}{%
  \endSpecialEnv
}
\newenvironment{statement}[1][]{% Default statement has no title
  \par
  \SpecialEnv{#1}{statementborder}{statementbg}{statementborder}{}%
}{%
  \endSpecialEnv
}

\def\Empty{}

% #1 title (if any)
% #2 sidebar (and title bg) color
% #3 background color
% #4 border color (or null for no border)
% #5 Counter, if any.
\newenvironment{SpecialEnv}[5]{%
  \par
  \def\EnvSideC{#2}% To use later (in end)
  \def\EnvBackgroundC{#3}%
  \def\EnvFrameC{#4}%  
  \flushleft
  \setlength\leftskip{-\sidebar}%
  \addtolength\leftskip{-\envborder}%
  \noindent \nobreak
  % Check if title is null:
  \ifx\delimiter#1\delimiter\else
  % If a title is specified, then typeset it in reverse color
   \colorbox{\EnvSideC}{%
     \hspace{-\leftskip}% usually positive
     \hspace{-\fboxsep}%
     % insert counter, if any:
     \footnotesize\sffamily\bfseries\textcolor{white}{#1 \ifx\delimiter#5\delimiter\else(#5)\enspace\fi}%
     \hspace{\envborder}}%
   \par\nobreak
   \setlength\parskip{-0.2pt}% Tiny overlap to counter pixel round-off errors
   \nointerlineskip 
  \fi
  % Make side-bar
  \textcolor{\EnvSideC}{\vrule width\sidebar}%
  % collect body in \envbox:
  \begin{lrbox}\envbox 
  \begin{minipage}{\linewidth}%
  \ignorespaces
}{\par
  \end{minipage}\end{lrbox}%
  % body is collected. Add background color
  \setlength\fboxsep\envborder
  \ifx\EnvFrameC\Empty % no frame
    \colorbox{\EnvBackgroundC}{\usebox\envbox}%
  \else % frame
    \setlength\fboxrule\envrule
    \addtolength\fboxsep{-\envrule}%
    \fcolorbox{\EnvFrameC}{\EnvBackgroundC}{\usebox\envbox}%
  \fi
  \nobreak \hspace{-2\envborder}\null
  \endflushleft
}


\makeindex

\begin{document}

% dirty, to be replaced by sed
\index{...AAA}
\index{..AAA}
\index{..ZZZ}

\pagenumbering{roman}
\begin{titlepage}
  \newlength{\saveparindent}
  \setlength{\saveparindent}{\parindent}
  \setlength{\parindent}{0cm}

  \sf
  \center
	\vspace*{1cm}
	\mbox{
	  \parbox{4cm}{
			\begin{tikzpicture}[scale=0.5]
				\path[fill=black, join=round] (1,1)--(2,2)--(2,5)--(5,5)--(6,6)--(1,6)--(1,1)--(2,0)--(5,0)--(7,2)--(7,5)--(6,6)--(6,1)--cycle;
				\clip (6,6)--(5,5)--(5,2)--(2,2)--(1,1)--(6,1)--(6,6)--(5,7)--(2,7)--(0,5)--(0,2)--(1,1)--(1,6)--cycle;
				\shade[inner color=green, outer color=black] (3,4) circle(5.5cm);
			\end{tikzpicture}
	  }
	  \parbox{8cm}{
	    \LARGE Universität Karlsruhe (TH)\\
	    \large Forschungsuniversität $\cdot$ gegründet 1825\\[0.5cm]
	    \large Fakultät für Informatik\\
	    \large Institut für Programmstrukturen\\ und Datenorganisation\\
	    \large Lehrstuhl Prof. Goos
		}
	}

  \vspace*{2.5cm}
  \Huge The \GrG\ User Manual\\[1ex]
  \LARGE Refers to \GrG\ Release 1.0\\[1ex]
  \LARGE www.grgen.net\\[6ex]
  \includegraphics[width=0.9\linewidth]{fig/title}\\[6ex]
  \LARGE Jakob Blomer \qquad Rubino Gei\ss\\[3ex]
  \large \today\\
  
  \vfill
	\large Technical Report 2007-5\\
	\large ISSN 1432-7864	

  \setlength{\parindent}{\saveparindent}
\end{titlepage}
\clearpage

\chapter*{Abstract}
\GrG\ is a graph rewrite system enabling elegant and convenient development of applications with comparable performance to conventionally developed ones.
\GrG\ uses attributed, typed, and directed multigraphs with multiple inheritance on node and edge types.
Extensive graphical debugging integrated into an interactive shell complements the feature highlights of \GrG.
This user manual contains both: Normative statements in the sense of a reference manual as well as an informal guide to the features and usage of \GrG.

\chapter*{Foreword}
This manual deals with graph rewriting and graph transformation, despite the ongoing debate we don't see any difference and denote it as graph rewriting.

The \textsc{GrGen} project started in spring 2003 as a diploma thesis of Sebastian Hack.
Back than we needed a tool to find subgraphs in graph based intermediate representations used in compiler construction.
We imagined a tool that is fast, expressive and easy to integrate into our compiler infrastructure.
So far Optimix was the only system that brought together the areas of compiler construction and graph rewriting~\cite{assmann00graph}.
However its approach was to feature many provable properties of the system per se, such as termination, confluence of derivation, and coverage of graphs.
This was achieved by restricting the expressiveness of the whole formalism below Turing-completeness.
Our system \textsc{GrGen} in contrast should be Turing-complete.
Thus providing the user with strong expressiveness but leaving the task of proving such properties to the user.

To get an early prototype fast, we let the costly task of subgraph matching up to a relational database system~\cite{Hac:03}.
Albeit the performance of this implementation could be improved substantially over the years, we believed that there is more to come.
Inspired by the PhD theses of Heiko D\"orr~\cite{doerr} we reimplemented the system to use search plan based matching algorithms of its own.
These matching algorithms evolved over time~\cite{adam,Bat:05:SA,Bat:05:DA,Bat:06,BKG:07} and have been ported from C to C\#~\cite{KG:07,Kro:07}. 
In 2005 Varr\'o~\cite{gramot2005_adapt} independently proposed a similar search plan based approach.

Though we started four years ago to facilitate some compiler construction problems, in the meantime \GrG\ has grown into a general purpose tool for graph rewriting.\\[3ex]

We wish all readers of the manual---and especially all users of \GrG---a pleasant graph rewrite experience.
We hope you enjoy using \GrG\ as much as we enjoy developing it.\\[3ex]

If you find that any statement in this manual needs improvement, we encourage you to contact the maintainer of \GrG: \url{rubino@ipd.uni-karlsruhe.de}.
Thank you for using \GrG.\\[3ex]

\noindent Karlsruhe in June 2007, the authors of \GrG\\


\clearpage

\tableofcontents

\include{overview}

\include{modellang}

\include{rulelang}

\include{typexpr}

\include{grshell}

\include{examples}


\bibliographystyle{alpha}
\bibliography{diss}

\printindex

\end{document}
 


